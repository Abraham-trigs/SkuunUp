
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model PreviousSchool
 * 
 */
export type PreviousSchool = $Result.DefaultSelection<Prisma.$PreviousSchoolPayload>
/**
 * Model FamilyMember
 * 
 */
export type FamilyMember = $Result.DefaultSelection<Prisma.$FamilyMemberPayload>
/**
 * Model StaffApplication
 * 
 */
export type StaffApplication = $Result.DefaultSelection<Prisma.$StaffApplicationPayload>
/**
 * Model PreviousJob
 * 
 */
export type PreviousJob = $Result.DefaultSelection<Prisma.$PreviousJobPayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model StudentAttendance
 * 
 */
export type StudentAttendance = $Result.DefaultSelection<Prisma.$StudentAttendancePayload>
/**
 * Model StaffAttendance
 * 
 */
export type StaffAttendance = $Result.DefaultSelection<Prisma.$StaffAttendancePayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model Author
 * 
 */
export type Author = $Result.DefaultSelection<Prisma.$AuthorPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Book
 * 
 */
export type Book = $Result.DefaultSelection<Prisma.$BookPayload>
/**
 * Model Borrow
 * 
 */
export type Borrow = $Result.DefaultSelection<Prisma.$BorrowPayload>
/**
 * Model LibraryStaff
 * 
 */
export type LibraryStaff = $Result.DefaultSelection<Prisma.$LibraryStaffPayload>
/**
 * Model AdmissionPayment
 * 
 */
export type AdmissionPayment = $Result.DefaultSelection<Prisma.$AdmissionPaymentPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Finance
 * 
 */
export type Finance = $Result.DefaultSelection<Prisma.$FinancePayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Bus
 * 
 */
export type Bus = $Result.DefaultSelection<Prisma.$BusPayload>
/**
 * Model SkuunAiSession
 * 
 */
export type SkuunAiSession = $Result.DefaultSelection<Prisma.$SkuunAiSessionPayload>
/**
 * Model SkuunAiMessage
 * 
 */
export type SkuunAiMessage = $Result.DefaultSelection<Prisma.$SkuunAiMessagePayload>
/**
 * Model SkuunAiAction
 * 
 */
export type SkuunAiAction = $Result.DefaultSelection<Prisma.$SkuunAiActionPayload>
/**
 * Model SkuunAiRecommendation
 * 
 */
export type SkuunAiRecommendation = $Result.DefaultSelection<Prisma.$SkuunAiRecommendationPayload>
/**
 * Model DecisionRecord
 * 
 */
export type DecisionRecord = $Result.DefaultSelection<Prisma.$DecisionRecordPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  PRINCIPAL: 'PRINCIPAL',
  VICE_PRINCIPAL: 'VICE_PRINCIPAL',
  TEACHER: 'TEACHER',
  ASSISTANT_TEACHER: 'ASSISTANT_TEACHER',
  COUNSELOR: 'COUNSELOR',
  LIBRARIAN: 'LIBRARIAN',
  EXAM_OFFICER: 'EXAM_OFFICER',
  FINANCE: 'FINANCE',
  HR: 'HR',
  RECEPTIONIST: 'RECEPTIONIST',
  IT_SUPPORT: 'IT_SUPPORT',
  TRANSPORT: 'TRANSPORT',
  NURSE: 'NURSE',
  COOK: 'COOK',
  CLEANER: 'CLEANER',
  SECURITY: 'SECURITY',
  MAINTENANCE: 'MAINTENANCE',
  STUDENT: 'STUDENT',
  CLASS_REP: 'CLASS_REP',
  PARENT: 'PARENT',
  ALUMNI: 'ALUMNI',
  AUDITOR: 'AUDITOR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ApplicationStatus: {
  DRAFT: 'DRAFT',
  READY_FOR_REVIEW: 'READY_FOR_REVIEW',
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EXCUSED: 'EXCUSED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const FinanceType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type FinanceType = (typeof FinanceType)[keyof typeof FinanceType]


export const FeeType: {
  ADMISSION: 'ADMISSION',
  TUITION: 'TUITION',
  EXAM: 'EXAM',
  LAB: 'LAB',
  SPORTS: 'SPORTS',
  LIBRARY: 'LIBRARY',
  TRANSPORT: 'TRANSPORT',
  UNIFORM: 'UNIFORM',
  OTHER: 'OTHER'
};

export type FeeType = (typeof FeeType)[keyof typeof FeeType]


export const ActionStatus: {
  PENDING: 'PENDING',
  EXECUTED: 'EXECUTED',
  FAILED: 'FAILED'
};

export type ActionStatus = (typeof ActionStatus)[keyof typeof ActionStatus]


export const SenderType: {
  USER: 'USER',
  AI: 'AI',
  SYSTEM: 'SYSTEM'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]


export const MessageType: {
  TEXT: 'TEXT',
  JSON: 'JSON',
  IMAGE: 'IMAGE'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const AIActionType: {
  GUIDE_APPLICATION: 'GUIDE_APPLICATION',
  VALIDATE_APPLICATION: 'VALIDATE_APPLICATION',
  PREDICT_GRADE_PLACEMENT: 'PREDICT_GRADE_PLACEMENT',
  SUGGEST_SUBJECTS: 'SUGGEST_SUBJECTS',
  GENERATE_PROFILE: 'GENERATE_PROFILE',
  FLAG_SPECIAL_NEEDS: 'FLAG_SPECIAL_NEEDS',
  FLAG_AT_RISK_STUDENTS: 'FLAG_AT_RISK_STUDENTS',
  SUGGEST_INTERVENTIONS: 'SUGGEST_INTERVENTIONS',
  TRACK_APPLICATION_PROGRESS: 'TRACK_APPLICATION_PROGRESS',
  STAFF_ROLE_ALLOCATION: 'STAFF_ROLE_ALLOCATION',
  GENERATE_STAFF_SCHEDULE: 'GENERATE_STAFF_SCHEDULE',
  TRACK_STAFF_WORKLOAD: 'TRACK_STAFF_WORKLOAD',
  SUMMARIZE_PREVIOUS_JOBS: 'SUMMARIZE_PREVIOUS_JOBS',
  SUGGEST_HIRING_DECISIONS: 'SUGGEST_HIRING_DECISIONS',
  SUGGEST_CLASS_DISTRIBUTION: 'SUGGEST_CLASS_DISTRIBUTION',
  SUGGEST_SUBJECT_TEACHER_ALLOCATION: 'SUGGEST_SUBJECT_TEACHER_ALLOCATION',
  DETECT_MISSING_ASSIGNMENTS: 'DETECT_MISSING_ASSIGNMENTS',
  GENERATE_CLASS_REPORTS: 'GENERATE_CLASS_REPORTS',
  PREDICT_STUDENT_PERFORMANCE: 'PREDICT_STUDENT_PERFORMANCE',
  TRACK_EXAM_RESULTS: 'TRACK_EXAM_RESULTS',
  SUGGEST_ADAPTIVE_PATHS: 'SUGGEST_ADAPTIVE_PATHS',
  CORRELATE_SCORE_ATTENDANCE: 'CORRELATE_SCORE_ATTENDANCE',
  GENERATE_EXAM_REPORTS: 'GENERATE_EXAM_REPORTS',
  PREDICT_ATTENDANCE: 'PREDICT_ATTENDANCE',
  GENERATE_ATTENDANCE_SUMMARIES: 'GENERATE_ATTENDANCE_SUMMARIES',
  SUGGEST_ATTENDANCE_INTERVENTIONS: 'SUGGEST_ATTENDANCE_INTERVENTIONS',
  TRACK_LIBRARY_USAGE: 'TRACK_LIBRARY_USAGE',
  PREDICT_RESOURCE_NEEDS: 'PREDICT_RESOURCE_NEEDS',
  NOTIFY_OVERDUE_ITEMS: 'NOTIFY_OVERDUE_ITEMS',
  RECOMMEND_NEW_RESOURCES: 'RECOMMEND_NEW_RESOURCES',
  OPTIMIZE_LIBRARY_OPERATIONS: 'OPTIMIZE_LIBRARY_OPERATIONS',
  FINANCIAL_INSIGHTS: 'FINANCIAL_INSIGHTS',
  FLAG_LATE_PAYMENTS: 'FLAG_LATE_PAYMENTS',
  SUGGEST_BUDGET_ALLOCATIONS: 'SUGGEST_BUDGET_ALLOCATIONS',
  GENERATE_FINANCIAL_REPORTS: 'GENERATE_FINANCIAL_REPORTS',
  OPTIMIZE_BUS_ROUTES: 'OPTIMIZE_BUS_ROUTES',
  TRACK_ASSETS: 'TRACK_ASSETS',
  PREDICT_RESOURCE_SHORTAGES: 'PREDICT_RESOURCE_SHORTAGES',
  SUGGEST_ACTIVITY_SCHEDULES: 'SUGGEST_ACTIVITY_SCHEDULES',
  TRACK_TASKS: 'TRACK_TASKS',
  GENERATE_PROJECT_PLANS: 'GENERATE_PROJECT_PLANS',
  PREDICT_PROJECT_DELAYS: 'PREDICT_PROJECT_DELAYS',
  ASSIST_TASK_ALLOCATION: 'ASSIST_TASK_ALLOCATION',
  GENERATE_AI_CONTENT: 'GENERATE_AI_CONTENT',
  ALIGN_GOALS: 'ALIGN_GOALS',
  CHAT_QA: 'CHAT_QA',
  AUTOMATE_REMINDERS: 'AUTOMATE_REMINDERS',
  EXECUTE_ADMIN_ACTION: 'EXECUTE_ADMIN_ACTION',
  SUGGEST_POLICY_IMPROVEMENTS: 'SUGGEST_POLICY_IMPROVEMENTS',
  GENERATE_SUMMARIES: 'GENERATE_SUMMARIES',
  TRACK_AI_ACTIONS: 'TRACK_AI_ACTIONS',
  PREDICT_STUDENT_TRENDS: 'PREDICT_STUDENT_TRENDS',
  PREDICT_STAFF_TRENDS: 'PREDICT_STAFF_TRENDS',
  ALERT_CRITICAL_ISSUES: 'ALERT_CRITICAL_ISSUES',
  SUGGEST_INTERVENTION_PLANS: 'SUGGEST_INTERVENTION_PLANS'
};

export type AIActionType = (typeof AIActionType)[keyof typeof AIActionType]


export const DecisionStatus: {
  PROPOSED: 'PROPOSED',
  ACCEPTED: 'ACCEPTED',
  IMPLEMENTED: 'IMPLEMENTED',
  SUPERSEDED: 'SUPERSEDED'
};

export type DecisionStatus = (typeof DecisionStatus)[keyof typeof DecisionStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type FinanceType = $Enums.FinanceType

export const FinanceType: typeof $Enums.FinanceType

export type FeeType = $Enums.FeeType

export const FeeType: typeof $Enums.FeeType

export type ActionStatus = $Enums.ActionStatus

export const ActionStatus: typeof $Enums.ActionStatus

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type AIActionType = $Enums.AIActionType

export const AIActionType: typeof $Enums.AIActionType

export type DecisionStatus = $Enums.DecisionStatus

export const DecisionStatus: typeof $Enums.DecisionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Schools
 * const schools = await prisma.school.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Schools
   * const schools = await prisma.school.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.previousSchool`: Exposes CRUD operations for the **PreviousSchool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreviousSchools
    * const previousSchools = await prisma.previousSchool.findMany()
    * ```
    */
  get previousSchool(): Prisma.PreviousSchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyMember`: Exposes CRUD operations for the **FamilyMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyMembers
    * const familyMembers = await prisma.familyMember.findMany()
    * ```
    */
  get familyMember(): Prisma.FamilyMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffApplication`: Exposes CRUD operations for the **StaffApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffApplications
    * const staffApplications = await prisma.staffApplication.findMany()
    * ```
    */
  get staffApplication(): Prisma.StaffApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.previousJob`: Exposes CRUD operations for the **PreviousJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreviousJobs
    * const previousJobs = await prisma.previousJob.findMany()
    * ```
    */
  get previousJob(): Prisma.PreviousJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentAttendance`: Exposes CRUD operations for the **StudentAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAttendances
    * const studentAttendances = await prisma.studentAttendance.findMany()
    * ```
    */
  get studentAttendance(): Prisma.StudentAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffAttendance`: Exposes CRUD operations for the **StaffAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffAttendances
    * const staffAttendances = await prisma.staffAttendance.findMany()
    * ```
    */
  get staffAttendance(): Prisma.StaffAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.author`: Exposes CRUD operations for the **Author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.author.findMany()
    * ```
    */
  get author(): Prisma.AuthorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.borrow`: Exposes CRUD operations for the **Borrow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Borrows
    * const borrows = await prisma.borrow.findMany()
    * ```
    */
  get borrow(): Prisma.BorrowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.libraryStaff`: Exposes CRUD operations for the **LibraryStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryStaffs
    * const libraryStaffs = await prisma.libraryStaff.findMany()
    * ```
    */
  get libraryStaff(): Prisma.LibraryStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admissionPayment`: Exposes CRUD operations for the **AdmissionPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmissionPayments
    * const admissionPayments = await prisma.admissionPayment.findMany()
    * ```
    */
  get admissionPayment(): Prisma.AdmissionPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finance`: Exposes CRUD operations for the **Finance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Finances
    * const finances = await prisma.finance.findMany()
    * ```
    */
  get finance(): Prisma.FinanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bus`: Exposes CRUD operations for the **Bus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buses
    * const buses = await prisma.bus.findMany()
    * ```
    */
  get bus(): Prisma.BusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skuunAiSession`: Exposes CRUD operations for the **SkuunAiSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkuunAiSessions
    * const skuunAiSessions = await prisma.skuunAiSession.findMany()
    * ```
    */
  get skuunAiSession(): Prisma.SkuunAiSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skuunAiMessage`: Exposes CRUD operations for the **SkuunAiMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkuunAiMessages
    * const skuunAiMessages = await prisma.skuunAiMessage.findMany()
    * ```
    */
  get skuunAiMessage(): Prisma.SkuunAiMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skuunAiAction`: Exposes CRUD operations for the **SkuunAiAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkuunAiActions
    * const skuunAiActions = await prisma.skuunAiAction.findMany()
    * ```
    */
  get skuunAiAction(): Prisma.SkuunAiActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skuunAiRecommendation`: Exposes CRUD operations for the **SkuunAiRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkuunAiRecommendations
    * const skuunAiRecommendations = await prisma.skuunAiRecommendation.findMany()
    * ```
    */
  get skuunAiRecommendation(): Prisma.SkuunAiRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.decisionRecord`: Exposes CRUD operations for the **DecisionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DecisionRecords
    * const decisionRecords = await prisma.decisionRecord.findMany()
    * ```
    */
  get decisionRecord(): Prisma.DecisionRecordDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    School: 'School',
    User: 'User',
    Student: 'Student',
    Class: 'Class',
    Grade: 'Grade',
    Subject: 'Subject',
    Exam: 'Exam',
    Application: 'Application',
    PreviousSchool: 'PreviousSchool',
    FamilyMember: 'FamilyMember',
    StaffApplication: 'StaffApplication',
    PreviousJob: 'PreviousJob',
    Staff: 'Staff',
    Department: 'Department',
    StudentAttendance: 'StudentAttendance',
    StaffAttendance: 'StaffAttendance',
    Parent: 'Parent',
    Author: 'Author',
    Category: 'Category',
    Book: 'Book',
    Borrow: 'Borrow',
    LibraryStaff: 'LibraryStaff',
    AdmissionPayment: 'AdmissionPayment',
    Transaction: 'Transaction',
    Finance: 'Finance',
    Resource: 'Resource',
    Purchase: 'Purchase',
    Activity: 'Activity',
    Bus: 'Bus',
    SkuunAiSession: 'SkuunAiSession',
    SkuunAiMessage: 'SkuunAiMessage',
    SkuunAiAction: 'SkuunAiAction',
    SkuunAiRecommendation: 'SkuunAiRecommendation',
    DecisionRecord: 'DecisionRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "school" | "user" | "student" | "class" | "grade" | "subject" | "exam" | "application" | "previousSchool" | "familyMember" | "staffApplication" | "previousJob" | "staff" | "department" | "studentAttendance" | "staffAttendance" | "parent" | "author" | "category" | "book" | "borrow" | "libraryStaff" | "admissionPayment" | "transaction" | "finance" | "resource" | "purchase" | "activity" | "bus" | "skuunAiSession" | "skuunAiMessage" | "skuunAiAction" | "skuunAiRecommendation" | "decisionRecord"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      PreviousSchool: {
        payload: Prisma.$PreviousSchoolPayload<ExtArgs>
        fields: Prisma.PreviousSchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreviousSchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreviousSchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>
          }
          findFirst: {
            args: Prisma.PreviousSchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreviousSchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>
          }
          findMany: {
            args: Prisma.PreviousSchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>[]
          }
          create: {
            args: Prisma.PreviousSchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>
          }
          createMany: {
            args: Prisma.PreviousSchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreviousSchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>[]
          }
          delete: {
            args: Prisma.PreviousSchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>
          }
          update: {
            args: Prisma.PreviousSchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>
          }
          deleteMany: {
            args: Prisma.PreviousSchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreviousSchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PreviousSchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>[]
          }
          upsert: {
            args: Prisma.PreviousSchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousSchoolPayload>
          }
          aggregate: {
            args: Prisma.PreviousSchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreviousSchool>
          }
          groupBy: {
            args: Prisma.PreviousSchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreviousSchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreviousSchoolCountArgs<ExtArgs>
            result: $Utils.Optional<PreviousSchoolCountAggregateOutputType> | number
          }
        }
      }
      FamilyMember: {
        payload: Prisma.$FamilyMemberPayload<ExtArgs>
        fields: Prisma.FamilyMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          findFirst: {
            args: Prisma.FamilyMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          findMany: {
            args: Prisma.FamilyMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>[]
          }
          create: {
            args: Prisma.FamilyMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          createMany: {
            args: Prisma.FamilyMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FamilyMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>[]
          }
          delete: {
            args: Prisma.FamilyMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          update: {
            args: Prisma.FamilyMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          deleteMany: {
            args: Prisma.FamilyMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FamilyMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>[]
          }
          upsert: {
            args: Prisma.FamilyMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          aggregate: {
            args: Prisma.FamilyMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyMember>
          }
          groupBy: {
            args: Prisma.FamilyMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyMemberCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberCountAggregateOutputType> | number
          }
        }
      }
      StaffApplication: {
        payload: Prisma.$StaffApplicationPayload<ExtArgs>
        fields: Prisma.StaffApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>
          }
          findFirst: {
            args: Prisma.StaffApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>
          }
          findMany: {
            args: Prisma.StaffApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>[]
          }
          create: {
            args: Prisma.StaffApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>
          }
          createMany: {
            args: Prisma.StaffApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>[]
          }
          delete: {
            args: Prisma.StaffApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>
          }
          update: {
            args: Prisma.StaffApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>
          }
          deleteMany: {
            args: Prisma.StaffApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>[]
          }
          upsert: {
            args: Prisma.StaffApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffApplicationPayload>
          }
          aggregate: {
            args: Prisma.StaffApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffApplication>
          }
          groupBy: {
            args: Prisma.StaffApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<StaffApplicationCountAggregateOutputType> | number
          }
        }
      }
      PreviousJob: {
        payload: Prisma.$PreviousJobPayload<ExtArgs>
        fields: Prisma.PreviousJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreviousJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreviousJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>
          }
          findFirst: {
            args: Prisma.PreviousJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreviousJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>
          }
          findMany: {
            args: Prisma.PreviousJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>[]
          }
          create: {
            args: Prisma.PreviousJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>
          }
          createMany: {
            args: Prisma.PreviousJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreviousJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>[]
          }
          delete: {
            args: Prisma.PreviousJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>
          }
          update: {
            args: Prisma.PreviousJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>
          }
          deleteMany: {
            args: Prisma.PreviousJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreviousJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PreviousJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>[]
          }
          upsert: {
            args: Prisma.PreviousJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreviousJobPayload>
          }
          aggregate: {
            args: Prisma.PreviousJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreviousJob>
          }
          groupBy: {
            args: Prisma.PreviousJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreviousJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreviousJobCountArgs<ExtArgs>
            result: $Utils.Optional<PreviousJobCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      StudentAttendance: {
        payload: Prisma.$StudentAttendancePayload<ExtArgs>
        fields: Prisma.StudentAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findFirst: {
            args: Prisma.StudentAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findMany: {
            args: Prisma.StudentAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          create: {
            args: Prisma.StudentAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          createMany: {
            args: Prisma.StudentAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          delete: {
            args: Prisma.StudentAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          update: {
            args: Prisma.StudentAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          deleteMany: {
            args: Prisma.StudentAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          upsert: {
            args: Prisma.StudentAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          aggregate: {
            args: Prisma.StudentAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAttendance>
          }
          groupBy: {
            args: Prisma.StudentAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceCountAggregateOutputType> | number
          }
        }
      }
      StaffAttendance: {
        payload: Prisma.$StaffAttendancePayload<ExtArgs>
        fields: Prisma.StaffAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          findFirst: {
            args: Prisma.StaffAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          findMany: {
            args: Prisma.StaffAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>[]
          }
          create: {
            args: Prisma.StaffAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          createMany: {
            args: Prisma.StaffAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>[]
          }
          delete: {
            args: Prisma.StaffAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          update: {
            args: Prisma.StaffAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          deleteMany: {
            args: Prisma.StaffAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>[]
          }
          upsert: {
            args: Prisma.StaffAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffAttendancePayload>
          }
          aggregate: {
            args: Prisma.StaffAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffAttendance>
          }
          groupBy: {
            args: Prisma.StaffAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<StaffAttendanceCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      Author: {
        payload: Prisma.$AuthorPayload<ExtArgs>
        fields: Prisma.AuthorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findFirst: {
            args: Prisma.AuthorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findMany: {
            args: Prisma.AuthorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          create: {
            args: Prisma.AuthorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          createMany: {
            args: Prisma.AuthorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          delete: {
            args: Prisma.AuthorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          update: {
            args: Prisma.AuthorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          deleteMany: {
            args: Prisma.AuthorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          upsert: {
            args: Prisma.AuthorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          aggregate: {
            args: Prisma.AuthorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthor>
          }
          groupBy: {
            args: Prisma.AuthorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Book: {
        payload: Prisma.$BookPayload<ExtArgs>
        fields: Prisma.BookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findFirst: {
            args: Prisma.BookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findMany: {
            args: Prisma.BookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          create: {
            args: Prisma.BookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          createMany: {
            args: Prisma.BookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          delete: {
            args: Prisma.BookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          update: {
            args: Prisma.BookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          deleteMany: {
            args: Prisma.BookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          upsert: {
            args: Prisma.BookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          aggregate: {
            args: Prisma.BookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook>
          }
          groupBy: {
            args: Prisma.BookGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookCountArgs<ExtArgs>
            result: $Utils.Optional<BookCountAggregateOutputType> | number
          }
        }
      }
      Borrow: {
        payload: Prisma.$BorrowPayload<ExtArgs>
        fields: Prisma.BorrowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BorrowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BorrowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          findFirst: {
            args: Prisma.BorrowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BorrowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          findMany: {
            args: Prisma.BorrowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>[]
          }
          create: {
            args: Prisma.BorrowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          createMany: {
            args: Prisma.BorrowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BorrowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>[]
          }
          delete: {
            args: Prisma.BorrowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          update: {
            args: Prisma.BorrowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          deleteMany: {
            args: Prisma.BorrowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BorrowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BorrowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>[]
          }
          upsert: {
            args: Prisma.BorrowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          aggregate: {
            args: Prisma.BorrowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBorrow>
          }
          groupBy: {
            args: Prisma.BorrowGroupByArgs<ExtArgs>
            result: $Utils.Optional<BorrowGroupByOutputType>[]
          }
          count: {
            args: Prisma.BorrowCountArgs<ExtArgs>
            result: $Utils.Optional<BorrowCountAggregateOutputType> | number
          }
        }
      }
      LibraryStaff: {
        payload: Prisma.$LibraryStaffPayload<ExtArgs>
        fields: Prisma.LibraryStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>
          }
          findFirst: {
            args: Prisma.LibraryStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>
          }
          findMany: {
            args: Prisma.LibraryStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>[]
          }
          create: {
            args: Prisma.LibraryStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>
          }
          createMany: {
            args: Prisma.LibraryStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LibraryStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>[]
          }
          delete: {
            args: Prisma.LibraryStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>
          }
          update: {
            args: Prisma.LibraryStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>
          }
          deleteMany: {
            args: Prisma.LibraryStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LibraryStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>[]
          }
          upsert: {
            args: Prisma.LibraryStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryStaffPayload>
          }
          aggregate: {
            args: Prisma.LibraryStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLibraryStaff>
          }
          groupBy: {
            args: Prisma.LibraryStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<LibraryStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryStaffCountArgs<ExtArgs>
            result: $Utils.Optional<LibraryStaffCountAggregateOutputType> | number
          }
        }
      }
      AdmissionPayment: {
        payload: Prisma.$AdmissionPaymentPayload<ExtArgs>
        fields: Prisma.AdmissionPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>
          }
          findFirst: {
            args: Prisma.AdmissionPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>
          }
          findMany: {
            args: Prisma.AdmissionPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>[]
          }
          create: {
            args: Prisma.AdmissionPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>
          }
          createMany: {
            args: Prisma.AdmissionPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>[]
          }
          delete: {
            args: Prisma.AdmissionPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>
          }
          update: {
            args: Prisma.AdmissionPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdmissionPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>[]
          }
          upsert: {
            args: Prisma.AdmissionPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPaymentPayload>
          }
          aggregate: {
            args: Prisma.AdmissionPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmissionPayment>
          }
          groupBy: {
            args: Prisma.AdmissionPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionPaymentCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Finance: {
        payload: Prisma.$FinancePayload<ExtArgs>
        fields: Prisma.FinanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          findFirst: {
            args: Prisma.FinanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          findMany: {
            args: Prisma.FinanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>[]
          }
          create: {
            args: Prisma.FinanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          createMany: {
            args: Prisma.FinanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>[]
          }
          delete: {
            args: Prisma.FinanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          update: {
            args: Prisma.FinanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          deleteMany: {
            args: Prisma.FinanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>[]
          }
          upsert: {
            args: Prisma.FinanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          aggregate: {
            args: Prisma.FinanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinance>
          }
          groupBy: {
            args: Prisma.FinanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinanceCountArgs<ExtArgs>
            result: $Utils.Optional<FinanceCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Bus: {
        payload: Prisma.$BusPayload<ExtArgs>
        fields: Prisma.BusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>
          }
          findFirst: {
            args: Prisma.BusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>
          }
          findMany: {
            args: Prisma.BusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>[]
          }
          create: {
            args: Prisma.BusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>
          }
          createMany: {
            args: Prisma.BusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>[]
          }
          delete: {
            args: Prisma.BusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>
          }
          update: {
            args: Prisma.BusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>
          }
          deleteMany: {
            args: Prisma.BusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>[]
          }
          upsert: {
            args: Prisma.BusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusPayload>
          }
          aggregate: {
            args: Prisma.BusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBus>
          }
          groupBy: {
            args: Prisma.BusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusCountArgs<ExtArgs>
            result: $Utils.Optional<BusCountAggregateOutputType> | number
          }
        }
      }
      SkuunAiSession: {
        payload: Prisma.$SkuunAiSessionPayload<ExtArgs>
        fields: Prisma.SkuunAiSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkuunAiSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkuunAiSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>
          }
          findFirst: {
            args: Prisma.SkuunAiSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkuunAiSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>
          }
          findMany: {
            args: Prisma.SkuunAiSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>[]
          }
          create: {
            args: Prisma.SkuunAiSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>
          }
          createMany: {
            args: Prisma.SkuunAiSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkuunAiSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>[]
          }
          delete: {
            args: Prisma.SkuunAiSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>
          }
          update: {
            args: Prisma.SkuunAiSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>
          }
          deleteMany: {
            args: Prisma.SkuunAiSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkuunAiSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkuunAiSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>[]
          }
          upsert: {
            args: Prisma.SkuunAiSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiSessionPayload>
          }
          aggregate: {
            args: Prisma.SkuunAiSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkuunAiSession>
          }
          groupBy: {
            args: Prisma.SkuunAiSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkuunAiSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkuunAiSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SkuunAiSessionCountAggregateOutputType> | number
          }
        }
      }
      SkuunAiMessage: {
        payload: Prisma.$SkuunAiMessagePayload<ExtArgs>
        fields: Prisma.SkuunAiMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkuunAiMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkuunAiMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>
          }
          findFirst: {
            args: Prisma.SkuunAiMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkuunAiMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>
          }
          findMany: {
            args: Prisma.SkuunAiMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>[]
          }
          create: {
            args: Prisma.SkuunAiMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>
          }
          createMany: {
            args: Prisma.SkuunAiMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkuunAiMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>[]
          }
          delete: {
            args: Prisma.SkuunAiMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>
          }
          update: {
            args: Prisma.SkuunAiMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>
          }
          deleteMany: {
            args: Prisma.SkuunAiMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkuunAiMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkuunAiMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>[]
          }
          upsert: {
            args: Prisma.SkuunAiMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiMessagePayload>
          }
          aggregate: {
            args: Prisma.SkuunAiMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkuunAiMessage>
          }
          groupBy: {
            args: Prisma.SkuunAiMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkuunAiMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkuunAiMessageCountArgs<ExtArgs>
            result: $Utils.Optional<SkuunAiMessageCountAggregateOutputType> | number
          }
        }
      }
      SkuunAiAction: {
        payload: Prisma.$SkuunAiActionPayload<ExtArgs>
        fields: Prisma.SkuunAiActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkuunAiActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkuunAiActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>
          }
          findFirst: {
            args: Prisma.SkuunAiActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkuunAiActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>
          }
          findMany: {
            args: Prisma.SkuunAiActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>[]
          }
          create: {
            args: Prisma.SkuunAiActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>
          }
          createMany: {
            args: Prisma.SkuunAiActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkuunAiActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>[]
          }
          delete: {
            args: Prisma.SkuunAiActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>
          }
          update: {
            args: Prisma.SkuunAiActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>
          }
          deleteMany: {
            args: Prisma.SkuunAiActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkuunAiActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkuunAiActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>[]
          }
          upsert: {
            args: Prisma.SkuunAiActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiActionPayload>
          }
          aggregate: {
            args: Prisma.SkuunAiActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkuunAiAction>
          }
          groupBy: {
            args: Prisma.SkuunAiActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkuunAiActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkuunAiActionCountArgs<ExtArgs>
            result: $Utils.Optional<SkuunAiActionCountAggregateOutputType> | number
          }
        }
      }
      SkuunAiRecommendation: {
        payload: Prisma.$SkuunAiRecommendationPayload<ExtArgs>
        fields: Prisma.SkuunAiRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkuunAiRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkuunAiRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>
          }
          findFirst: {
            args: Prisma.SkuunAiRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkuunAiRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>
          }
          findMany: {
            args: Prisma.SkuunAiRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>[]
          }
          create: {
            args: Prisma.SkuunAiRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>
          }
          createMany: {
            args: Prisma.SkuunAiRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkuunAiRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>[]
          }
          delete: {
            args: Prisma.SkuunAiRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>
          }
          update: {
            args: Prisma.SkuunAiRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.SkuunAiRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkuunAiRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkuunAiRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.SkuunAiRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuunAiRecommendationPayload>
          }
          aggregate: {
            args: Prisma.SkuunAiRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkuunAiRecommendation>
          }
          groupBy: {
            args: Prisma.SkuunAiRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkuunAiRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkuunAiRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<SkuunAiRecommendationCountAggregateOutputType> | number
          }
        }
      }
      DecisionRecord: {
        payload: Prisma.$DecisionRecordPayload<ExtArgs>
        fields: Prisma.DecisionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DecisionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DecisionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>
          }
          findFirst: {
            args: Prisma.DecisionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DecisionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>
          }
          findMany: {
            args: Prisma.DecisionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>[]
          }
          create: {
            args: Prisma.DecisionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>
          }
          createMany: {
            args: Prisma.DecisionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DecisionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>[]
          }
          delete: {
            args: Prisma.DecisionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>
          }
          update: {
            args: Prisma.DecisionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>
          }
          deleteMany: {
            args: Prisma.DecisionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DecisionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DecisionRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>[]
          }
          upsert: {
            args: Prisma.DecisionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionRecordPayload>
          }
          aggregate: {
            args: Prisma.DecisionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecisionRecord>
          }
          groupBy: {
            args: Prisma.DecisionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<DecisionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.DecisionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<DecisionRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    school?: SchoolOmit
    user?: UserOmit
    student?: StudentOmit
    class?: ClassOmit
    grade?: GradeOmit
    subject?: SubjectOmit
    exam?: ExamOmit
    application?: ApplicationOmit
    previousSchool?: PreviousSchoolOmit
    familyMember?: FamilyMemberOmit
    staffApplication?: StaffApplicationOmit
    previousJob?: PreviousJobOmit
    staff?: StaffOmit
    department?: DepartmentOmit
    studentAttendance?: StudentAttendanceOmit
    staffAttendance?: StaffAttendanceOmit
    parent?: ParentOmit
    author?: AuthorOmit
    category?: CategoryOmit
    book?: BookOmit
    borrow?: BorrowOmit
    libraryStaff?: LibraryStaffOmit
    admissionPayment?: AdmissionPaymentOmit
    transaction?: TransactionOmit
    finance?: FinanceOmit
    resource?: ResourceOmit
    purchase?: PurchaseOmit
    activity?: ActivityOmit
    bus?: BusOmit
    skuunAiSession?: SkuunAiSessionOmit
    skuunAiMessage?: SkuunAiMessageOmit
    skuunAiAction?: SkuunAiActionOmit
    skuunAiRecommendation?: SkuunAiRecommendationOmit
    decisionRecord?: DecisionRecordOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    users: number
    classes: number
    buses: number
    finances: number
    activities: number
    resources: number
    Book: number
    applications: number
    StaffApplication: number
    Student: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    classes?: boolean | SchoolCountOutputTypeCountClassesArgs
    buses?: boolean | SchoolCountOutputTypeCountBusesArgs
    finances?: boolean | SchoolCountOutputTypeCountFinancesArgs
    activities?: boolean | SchoolCountOutputTypeCountActivitiesArgs
    resources?: boolean | SchoolCountOutputTypeCountResourcesArgs
    Book?: boolean | SchoolCountOutputTypeCountBookArgs
    applications?: boolean | SchoolCountOutputTypeCountApplicationsArgs
    StaffApplication?: boolean | SchoolCountOutputTypeCountStaffApplicationArgs
    Student?: boolean | SchoolCountOutputTypeCountStudentArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountBusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFinancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinanceWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStaffApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffApplicationWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdSubjects: number
    SkuunAiSession: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdSubjects?: boolean | UserCountOutputTypeCountCreatedSubjectsArgs
    SkuunAiSession?: boolean | UserCountOutputTypeCountSkuunAiSessionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSkuunAiSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuunAiSessionWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    subjects: number
    Exam: number
    StudentAttendance: number
    Parent: number
    Borrow: number
    Transaction: number
    Purchase: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | StudentCountOutputTypeCountSubjectsArgs
    Exam?: boolean | StudentCountOutputTypeCountExamArgs
    StudentAttendance?: boolean | StudentCountOutputTypeCountStudentAttendanceArgs
    Parent?: boolean | StudentCountOutputTypeCountParentArgs
    Borrow?: boolean | StudentCountOutputTypeCountBorrowArgs
    Transaction?: boolean | StudentCountOutputTypeCountTransactionArgs
    Purchase?: boolean | StudentCountOutputTypeCountPurchaseArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountBorrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    grades: number
    students: number
    staff: number
    exams: number
    subjects: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grades?: boolean | ClassCountOutputTypeCountGradesArgs
    students?: boolean | ClassCountOutputTypeCountStudentsArgs
    staff?: boolean | ClassCountOutputTypeCountStaffArgs
    exams?: boolean | ClassCountOutputTypeCountExamsArgs
    subjects?: boolean | ClassCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }


  /**
   * Count Type GradeCountOutputType
   */

  export type GradeCountOutputType = {
    students: number
    staff: number
    Application: number
  }

  export type GradeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | GradeCountOutputTypeCountStudentsArgs
    staff?: boolean | GradeCountOutputTypeCountStaffArgs
    Application?: boolean | GradeCountOutputTypeCountApplicationArgs
  }

  // Custom InputTypes
  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCountOutputType
     */
    select?: GradeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    exams: number
    staff: number
    students: number
    classes: number
    staffApplications: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | SubjectCountOutputTypeCountExamsArgs
    staff?: boolean | SubjectCountOutputTypeCountStaffArgs
    students?: boolean | SubjectCountOutputTypeCountStudentsArgs
    classes?: boolean | SubjectCountOutputTypeCountClassesArgs
    staffApplications?: boolean | SubjectCountOutputTypeCountStaffApplicationsArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountStaffApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffApplicationWhereInput
  }


  /**
   * Count Type ApplicationCountOutputType
   */

  export type ApplicationCountOutputType = {
    previousSchools: number
    familyMembers: number
  }

  export type ApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    previousSchools?: boolean | ApplicationCountOutputTypeCountPreviousSchoolsArgs
    familyMembers?: boolean | ApplicationCountOutputTypeCountFamilyMembersArgs
  }

  // Custom InputTypes
  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationCountOutputType
     */
    select?: ApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountPreviousSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreviousSchoolWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountFamilyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
  }


  /**
   * Count Type StaffApplicationCountOutputType
   */

  export type StaffApplicationCountOutputType = {
    subjects: number
    previousJobs: number
  }

  export type StaffApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | StaffApplicationCountOutputTypeCountSubjectsArgs
    previousJobs?: boolean | StaffApplicationCountOutputTypeCountPreviousJobsArgs
  }

  // Custom InputTypes
  /**
   * StaffApplicationCountOutputType without action
   */
  export type StaffApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplicationCountOutputType
     */
    select?: StaffApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffApplicationCountOutputType without action
   */
  export type StaffApplicationCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * StaffApplicationCountOutputType without action
   */
  export type StaffApplicationCountOutputTypeCountPreviousJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreviousJobWhereInput
  }


  /**
   * Count Type StaffCountOutputType
   */

  export type StaffCountOutputType = {
    grades: number
    subjects: number
    attendances: number
  }

  export type StaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grades?: boolean | StaffCountOutputTypeCountGradesArgs
    subjects?: boolean | StaffCountOutputTypeCountSubjectsArgs
    attendances?: boolean | StaffCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffAttendanceWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    staff: number
    LibraryStaff: number
    StaffApplication: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | DepartmentCountOutputTypeCountStaffArgs
    LibraryStaff?: boolean | DepartmentCountOutputTypeCountLibraryStaffArgs
    StaffApplication?: boolean | DepartmentCountOutputTypeCountStaffApplicationArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountLibraryStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryStaffWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStaffApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffApplicationWhereInput
  }


  /**
   * Count Type AuthorCountOutputType
   */

  export type AuthorCountOutputType = {
    books: number
  }

  export type AuthorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | AuthorCountOutputTypeCountBooksArgs
  }

  // Custom InputTypes
  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorCountOutputType
     */
    select?: AuthorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    books: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | CategoryCountOutputTypeCountBooksArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }


  /**
   * Count Type BookCountOutputType
   */

  export type BookCountOutputType = {
    borrows: number
  }

  export type BookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrows?: boolean | BookCountOutputTypeCountBorrowsArgs
  }

  // Custom InputTypes
  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCountOutputType
     */
    select?: BookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountBorrowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
  }


  /**
   * Count Type AdmissionPaymentCountOutputType
   */

  export type AdmissionPaymentCountOutputType = {
    Application: number
  }

  export type AdmissionPaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | AdmissionPaymentCountOutputTypeCountApplicationArgs
  }

  // Custom InputTypes
  /**
   * AdmissionPaymentCountOutputType without action
   */
  export type AdmissionPaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPaymentCountOutputType
     */
    select?: AdmissionPaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdmissionPaymentCountOutputType without action
   */
  export type AdmissionPaymentCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    purchases: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | ResourceCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Count Type SkuunAiSessionCountOutputType
   */

  export type SkuunAiSessionCountOutputType = {
    messages: number
    actions: number
    SkuunAiRecommendation: number
  }

  export type SkuunAiSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | SkuunAiSessionCountOutputTypeCountMessagesArgs
    actions?: boolean | SkuunAiSessionCountOutputTypeCountActionsArgs
    SkuunAiRecommendation?: boolean | SkuunAiSessionCountOutputTypeCountSkuunAiRecommendationArgs
  }

  // Custom InputTypes
  /**
   * SkuunAiSessionCountOutputType without action
   */
  export type SkuunAiSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSessionCountOutputType
     */
    select?: SkuunAiSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkuunAiSessionCountOutputType without action
   */
  export type SkuunAiSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuunAiMessageWhereInput
  }

  /**
   * SkuunAiSessionCountOutputType without action
   */
  export type SkuunAiSessionCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuunAiActionWhereInput
  }

  /**
   * SkuunAiSessionCountOutputType without action
   */
  export type SkuunAiSessionCountOutputTypeCountSkuunAiRecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuunAiRecommendationWhereInput
  }


  /**
   * Count Type DecisionRecordCountOutputType
   */

  export type DecisionRecordCountOutputType = {
    supersededBy: number
  }

  export type DecisionRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supersededBy?: boolean | DecisionRecordCountOutputTypeCountSupersededByArgs
  }

  // Custom InputTypes
  /**
   * DecisionRecordCountOutputType without action
   */
  export type DecisionRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecordCountOutputType
     */
    select?: DecisionRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DecisionRecordCountOutputType without action
   */
  export type DecisionRecordCountOutputTypeCountSupersededByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    email: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    name: string
    domain: string
    email: string
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | School$usersArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    buses?: boolean | School$busesArgs<ExtArgs>
    finances?: boolean | School$financesArgs<ExtArgs>
    activities?: boolean | School$activitiesArgs<ExtArgs>
    resources?: boolean | School$resourcesArgs<ExtArgs>
    Book?: boolean | School$BookArgs<ExtArgs>
    applications?: boolean | School$applicationsArgs<ExtArgs>
    StaffApplication?: boolean | School$StaffApplicationArgs<ExtArgs>
    Student?: boolean | School$StudentArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "domain" | "email" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | School$usersArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    buses?: boolean | School$busesArgs<ExtArgs>
    finances?: boolean | School$financesArgs<ExtArgs>
    activities?: boolean | School$activitiesArgs<ExtArgs>
    resources?: boolean | School$resourcesArgs<ExtArgs>
    Book?: boolean | School$BookArgs<ExtArgs>
    applications?: boolean | School$applicationsArgs<ExtArgs>
    StaffApplication?: boolean | School$StaffApplicationArgs<ExtArgs>
    Student?: boolean | School$StudentArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      buses: Prisma.$BusPayload<ExtArgs>[]
      finances: Prisma.$FinancePayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      resources: Prisma.$ResourcePayload<ExtArgs>[]
      Book: Prisma.$BookPayload<ExtArgs>[]
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
      StaffApplication: Prisma.$StaffApplicationPayload<ExtArgs>[]
      Student: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string
      email: string
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends School$classesArgs<ExtArgs> = {}>(args?: Subset<T, School$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buses<T extends School$busesArgs<ExtArgs> = {}>(args?: Subset<T, School$busesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    finances<T extends School$financesArgs<ExtArgs> = {}>(args?: Subset<T, School$financesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends School$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, School$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends School$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, School$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Book<T extends School$BookArgs<ExtArgs> = {}>(args?: Subset<T, School$BookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applications<T extends School$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, School$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StaffApplication<T extends School$StaffApplicationArgs<ExtArgs> = {}>(args?: Subset<T, School$StaffApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Student<T extends School$StudentArgs<ExtArgs> = {}>(args?: Subset<T, School$StudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly domain: FieldRef<"School", 'String'>
    readonly email: FieldRef<"School", 'String'>
    readonly address: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School.classes
   */
  export type School$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * School.buses
   */
  export type School$busesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    where?: BusWhereInput
    orderBy?: BusOrderByWithRelationInput | BusOrderByWithRelationInput[]
    cursor?: BusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusScalarFieldEnum | BusScalarFieldEnum[]
  }

  /**
   * School.finances
   */
  export type School$financesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    where?: FinanceWhereInput
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    cursor?: FinanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinanceScalarFieldEnum | FinanceScalarFieldEnum[]
  }

  /**
   * School.activities
   */
  export type School$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * School.resources
   */
  export type School$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * School.Book
   */
  export type School$BookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * School.applications
   */
  export type School$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * School.StaffApplication
   */
  export type School$StaffApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    where?: StaffApplicationWhereInput
    orderBy?: StaffApplicationOrderByWithRelationInput | StaffApplicationOrderByWithRelationInput[]
    cursor?: StaffApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffApplicationScalarFieldEnum | StaffApplicationScalarFieldEnum[]
  }

  /**
   * School.Student
   */
  export type School$StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    surname: string | null
    firstName: string | null
    otherNames: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    surname: string | null
    firstName: string | null
    otherNames: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    surname: number
    firstName: number
    otherNames: number
    email: number
    password: number
    role: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    surname?: true
    firstName?: true
    otherNames?: true
    email?: true
    password?: true
    role?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    surname?: true
    firstName?: true
    otherNames?: true
    email?: true
    password?: true
    role?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    surname?: true
    firstName?: true
    otherNames?: true
    email?: true
    password?: true
    role?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    surname: string
    firstName: string
    otherNames: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surname?: boolean
    firstName?: boolean
    otherNames?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    LibraryStaff?: boolean | User$LibraryStaffArgs<ExtArgs>
    createdSubjects?: boolean | User$createdSubjectsArgs<ExtArgs>
    application?: boolean | User$applicationArgs<ExtArgs>
    SkuunAiSession?: boolean | User$SkuunAiSessionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surname?: boolean
    firstName?: boolean
    otherNames?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surname?: boolean
    firstName?: boolean
    otherNames?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    surname?: boolean
    firstName?: boolean
    otherNames?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "surname" | "firstName" | "otherNames" | "email" | "password" | "role" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    LibraryStaff?: boolean | User$LibraryStaffArgs<ExtArgs>
    createdSubjects?: boolean | User$createdSubjectsArgs<ExtArgs>
    application?: boolean | User$applicationArgs<ExtArgs>
    SkuunAiSession?: boolean | User$SkuunAiSessionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs> | null
      LibraryStaff: Prisma.$LibraryStaffPayload<ExtArgs> | null
      createdSubjects: Prisma.$SubjectPayload<ExtArgs>[]
      application: Prisma.$ApplicationPayload<ExtArgs> | null
      SkuunAiSession: Prisma.$SkuunAiSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surname: string
      firstName: string
      otherNames: string | null
      email: string
      password: string
      role: $Enums.Role
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staff<T extends User$staffArgs<ExtArgs> = {}>(args?: Subset<T, User$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    LibraryStaff<T extends User$LibraryStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$LibraryStaffArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdSubjects<T extends User$createdSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    application<T extends User$applicationArgs<ExtArgs> = {}>(args?: Subset<T, User$applicationArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SkuunAiSession<T extends User$SkuunAiSessionArgs<ExtArgs> = {}>(args?: Subset<T, User$SkuunAiSessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly surname: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly otherNames: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly schoolId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.staff
   */
  export type User$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * User.LibraryStaff
   */
  export type User$LibraryStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    where?: LibraryStaffWhereInput
  }

  /**
   * User.createdSubjects
   */
  export type User$createdSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * User.application
   */
  export type User$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
  }

  /**
   * User.SkuunAiSession
   */
  export type User$SkuunAiSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    where?: SkuunAiSessionWhereInput
    orderBy?: SkuunAiSessionOrderByWithRelationInput | SkuunAiSessionOrderByWithRelationInput[]
    cursor?: SkuunAiSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuunAiSessionScalarFieldEnum | SkuunAiSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    schoolId: string | null
    enrolledAt: Date | null
    classId: string | null
    gradeId: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    schoolId: string | null
    enrolledAt: Date | null
    classId: string | null
    gradeId: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    schoolId: number
    enrolledAt: number
    classId: number
    gradeId: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    schoolId?: true
    enrolledAt?: true
    classId?: true
    gradeId?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    schoolId?: true
    enrolledAt?: true
    classId?: true
    gradeId?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    schoolId?: true
    enrolledAt?: true
    classId?: true
    gradeId?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    name: string | null
    schoolId: string
    enrolledAt: Date
    classId: string | null
    gradeId: string | null
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    schoolId?: boolean
    enrolledAt?: boolean
    classId?: boolean
    gradeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    subjects?: boolean | Student$subjectsArgs<ExtArgs>
    application?: boolean | Student$applicationArgs<ExtArgs>
    Class?: boolean | Student$ClassArgs<ExtArgs>
    Exam?: boolean | Student$ExamArgs<ExtArgs>
    StudentAttendance?: boolean | Student$StudentAttendanceArgs<ExtArgs>
    Parent?: boolean | Student$ParentArgs<ExtArgs>
    Borrow?: boolean | Student$BorrowArgs<ExtArgs>
    Transaction?: boolean | Student$TransactionArgs<ExtArgs>
    Purchase?: boolean | Student$PurchaseArgs<ExtArgs>
    Grade?: boolean | Student$GradeArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    schoolId?: boolean
    enrolledAt?: boolean
    classId?: boolean
    gradeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    Class?: boolean | Student$ClassArgs<ExtArgs>
    Grade?: boolean | Student$GradeArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    schoolId?: boolean
    enrolledAt?: boolean
    classId?: boolean
    gradeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    Class?: boolean | Student$ClassArgs<ExtArgs>
    Grade?: boolean | Student$GradeArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    schoolId?: boolean
    enrolledAt?: boolean
    classId?: boolean
    gradeId?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "schoolId" | "enrolledAt" | "classId" | "gradeId", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    subjects?: boolean | Student$subjectsArgs<ExtArgs>
    application?: boolean | Student$applicationArgs<ExtArgs>
    Class?: boolean | Student$ClassArgs<ExtArgs>
    Exam?: boolean | Student$ExamArgs<ExtArgs>
    StudentAttendance?: boolean | Student$StudentAttendanceArgs<ExtArgs>
    Parent?: boolean | Student$ParentArgs<ExtArgs>
    Borrow?: boolean | Student$BorrowArgs<ExtArgs>
    Transaction?: boolean | Student$TransactionArgs<ExtArgs>
    Purchase?: boolean | Student$PurchaseArgs<ExtArgs>
    Grade?: boolean | Student$GradeArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    Class?: boolean | Student$ClassArgs<ExtArgs>
    Grade?: boolean | Student$GradeArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    Class?: boolean | Student$ClassArgs<ExtArgs>
    Grade?: boolean | Student$GradeArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      application: Prisma.$ApplicationPayload<ExtArgs> | null
      Class: Prisma.$ClassPayload<ExtArgs> | null
      Exam: Prisma.$ExamPayload<ExtArgs>[]
      StudentAttendance: Prisma.$StudentAttendancePayload<ExtArgs>[]
      Parent: Prisma.$ParentPayload<ExtArgs>[]
      Borrow: Prisma.$BorrowPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      Purchase: Prisma.$PurchasePayload<ExtArgs>[]
      Grade: Prisma.$GradePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string | null
      schoolId: string
      enrolledAt: Date
      classId: string | null
      gradeId: string | null
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subjects<T extends Student$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Student$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    application<T extends Student$applicationArgs<ExtArgs> = {}>(args?: Subset<T, Student$applicationArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Class<T extends Student$ClassArgs<ExtArgs> = {}>(args?: Subset<T, Student$ClassArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Exam<T extends Student$ExamArgs<ExtArgs> = {}>(args?: Subset<T, Student$ExamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentAttendance<T extends Student$StudentAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Student$StudentAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Parent<T extends Student$ParentArgs<ExtArgs> = {}>(args?: Subset<T, Student$ParentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Borrow<T extends Student$BorrowArgs<ExtArgs> = {}>(args?: Subset<T, Student$BorrowArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Student$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Student$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Purchase<T extends Student$PurchaseArgs<ExtArgs> = {}>(args?: Subset<T, Student$PurchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Grade<T extends Student$GradeArgs<ExtArgs> = {}>(args?: Subset<T, Student$GradeArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly name: FieldRef<"Student", 'String'>
    readonly schoolId: FieldRef<"Student", 'String'>
    readonly enrolledAt: FieldRef<"Student", 'DateTime'>
    readonly classId: FieldRef<"Student", 'String'>
    readonly gradeId: FieldRef<"Student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.subjects
   */
  export type Student$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Student.application
   */
  export type Student$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
  }

  /**
   * Student.Class
   */
  export type Student$ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Student.Exam
   */
  export type Student$ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Student.StudentAttendance
   */
  export type Student$StudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * Student.Parent
   */
  export type Student$ParentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    cursor?: ParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Student.Borrow
   */
  export type Student$BorrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    cursor?: BorrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Student.Transaction
   */
  export type Student$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Student.Purchase
   */
  export type Student$PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Student.Grade
   */
  export type Student$GradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    grades?: boolean | Class$gradesArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    staff?: boolean | Class$staffArgs<ExtArgs>
    exams?: boolean | Class$examsArgs<ExtArgs>
    subjects?: boolean | Class$subjectsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    grades?: boolean | Class$gradesArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    staff?: boolean | Class$staffArgs<ExtArgs>
    exams?: boolean | Class$examsArgs<ExtArgs>
    subjects?: boolean | Class$subjectsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      grades: Prisma.$GradePayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      staff: Prisma.$StaffPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grades<T extends Class$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Class$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Class$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Class$staffArgs<ExtArgs> = {}>(args?: Subset<T, Class$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends Class$examsArgs<ExtArgs> = {}>(args?: Subset<T, Class$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Class$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Class$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly schoolId: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.grades
   */
  export type Class$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Class.students
   */
  export type Class$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class.staff
   */
  export type Class$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Class.exams
   */
  export type Class$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Class.subjects
   */
  export type Class$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    name: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    name: number
    classId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GradeMinAggregateInputType = {
    id?: true
    name?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    name?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    name?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    name: string
    classId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GradeCountAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | Grade$classArgs<ExtArgs>
    students?: boolean | Grade$studentsArgs<ExtArgs>
    staff?: boolean | Grade$staffArgs<ExtArgs>
    Application?: boolean | Grade$ApplicationArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | Grade$classArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | Grade$classArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    name?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "classId" | "createdAt" | "updatedAt", ExtArgs["result"]["grade"]>
  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Grade$classArgs<ExtArgs>
    students?: boolean | Grade$studentsArgs<ExtArgs>
    staff?: boolean | Grade$staffArgs<ExtArgs>
    Application?: boolean | Grade$ApplicationArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Grade$classArgs<ExtArgs>
  }
  export type GradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Grade$classArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      students: Prisma.$StudentPayload<ExtArgs>[]
      staff: Prisma.$StaffPayload<ExtArgs>[]
      Application: Prisma.$ApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      classId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {GradeUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends Grade$classArgs<ExtArgs> = {}>(args?: Subset<T, Grade$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends Grade$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Grade$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Grade$staffArgs<ExtArgs> = {}>(args?: Subset<T, Grade$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Application<T extends Grade$ApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Grade$ApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly name: FieldRef<"Grade", 'String'>
    readonly classId: FieldRef<"Grade", 'String'>
    readonly createdAt: FieldRef<"Grade", 'DateTime'>
    readonly updatedAt: FieldRef<"Grade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade updateManyAndReturn
   */
  export type GradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grade.class
   */
  export type Grade$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Grade.students
   */
  export type Grade$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Grade.staff
   */
  export type Grade$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Grade.Application
   */
  export type Grade$ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    code: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    code: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
    exams?: boolean | Subject$examsArgs<ExtArgs>
    staff?: boolean | Subject$staffArgs<ExtArgs>
    students?: boolean | Subject$studentsArgs<ExtArgs>
    classes?: boolean | Subject$classesArgs<ExtArgs>
    staffApplications?: boolean | Subject$staffApplicationsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
    exams?: boolean | Subject$examsArgs<ExtArgs>
    staff?: boolean | Subject$staffArgs<ExtArgs>
    students?: boolean | Subject$studentsArgs<ExtArgs>
    classes?: boolean | Subject$classesArgs<ExtArgs>
    staffApplications?: boolean | Subject$staffApplicationsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      exams: Prisma.$ExamPayload<ExtArgs>[]
      staff: Prisma.$StaffPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      staffApplications: Prisma.$StaffApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Subject$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Subject$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    exams<T extends Subject$examsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Subject$staffArgs<ExtArgs> = {}>(args?: Subset<T, Subject$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Subject$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Subject$classesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staffApplications<T extends Subject$staffApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$staffApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
    readonly createdById: FieldRef<"Subject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.createdBy
   */
  export type Subject$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Subject.exams
   */
  export type Subject$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Subject.staff
   */
  export type Subject$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Subject.students
   */
  export type Subject$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Subject.classes
   */
  export type Subject$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Subject.staffApplications
   */
  export type Subject$staffApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    where?: StaffApplicationWhereInput
    orderBy?: StaffApplicationOrderByWithRelationInput | StaffApplicationOrderByWithRelationInput[]
    cursor?: StaffApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffApplicationScalarFieldEnum | StaffApplicationScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    score: number | null
    maxScore: number | null
  }

  export type ExamSumAggregateOutputType = {
    score: number | null
    maxScore: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    studentId: string | null
    classId: string | null
    subjectId: string | null
    score: number | null
    maxScore: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    studentId: string | null
    classId: string | null
    subjectId: string | null
    score: number | null
    maxScore: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    studentId: number
    classId: number
    subjectId: number
    score: number
    maxScore: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    score?: true
    maxScore?: true
  }

  export type ExamSumAggregateInputType = {
    score?: true
    maxScore?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    studentId?: true
    classId?: true
    subjectId?: true
    score?: true
    maxScore?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    studentId?: true
    classId?: true
    subjectId?: true
    score?: true
    maxScore?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    studentId?: true
    classId?: true
    subjectId?: true
    score?: true
    maxScore?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    title: string
    studentId: string | null
    classId: string | null
    subjectId: string
    score: number | null
    maxScore: number | null
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    studentId?: boolean
    classId?: boolean
    subjectId?: boolean
    score?: boolean
    maxScore?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Exam$studentArgs<ExtArgs>
    class?: boolean | Exam$classArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    studentId?: boolean
    classId?: boolean
    subjectId?: boolean
    score?: boolean
    maxScore?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Exam$studentArgs<ExtArgs>
    class?: boolean | Exam$classArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    studentId?: boolean
    classId?: boolean
    subjectId?: boolean
    score?: boolean
    maxScore?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Exam$studentArgs<ExtArgs>
    class?: boolean | Exam$classArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    studentId?: boolean
    classId?: boolean
    subjectId?: boolean
    score?: boolean
    maxScore?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "studentId" | "classId" | "subjectId" | "score" | "maxScore" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["exam"]>
  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Exam$studentArgs<ExtArgs>
    class?: boolean | Exam$classArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Exam$studentArgs<ExtArgs>
    class?: boolean | Exam$classArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Exam$studentArgs<ExtArgs>
    class?: boolean | Exam$classArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      class: Prisma.$ClassPayload<ExtArgs> | null
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      studentId: string | null
      classId: string | null
      subjectId: string
      score: number | null
      maxScore: number | null
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends Exam$studentArgs<ExtArgs> = {}>(args?: Subset<T, Exam$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    class<T extends Exam$classArgs<ExtArgs> = {}>(args?: Subset<T, Exam$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly studentId: FieldRef<"Exam", 'String'>
    readonly classId: FieldRef<"Exam", 'String'>
    readonly subjectId: FieldRef<"Exam", 'String'>
    readonly score: FieldRef<"Exam", 'Float'>
    readonly maxScore: FieldRef<"Exam", 'Float'>
    readonly date: FieldRef<"Exam", 'DateTime'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam.student
   */
  export type Exam$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Exam.class
   */
  export type Exam$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationAvgAggregateOutputType = {
    numberOfSiblings: number | null
    siblingsOlder: number | null
    siblingsYounger: number | null
    progress: number | null
  }

  export type ApplicationSumAggregateOutputType = {
    numberOfSiblings: number | null
    siblingsOlder: number | null
    siblingsYounger: number | null
    progress: number | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    userId: string | null
    schoolId: string | null
    admissionPaymentId: string | null
    dateOfBirth: Date | null
    nationality: string | null
    sex: string | null
    gradeId: string | null
    mothersTongue: string | null
    religion: string | null
    denomination: string | null
    hometown: string | null
    region: string | null
    profilePicture: string | null
    wardLivesWith: string | null
    numberOfSiblings: number | null
    siblingsOlder: number | null
    siblingsYounger: number | null
    postalAddress: string | null
    residentialAddress: string | null
    wardMobile: string | null
    emergencyContact: string | null
    emergencyMedicalContact: string | null
    medicalSummary: string | null
    bloodType: string | null
    specialDisability: string | null
    feesAcknowledged: boolean | null
    declarationSigned: boolean | null
    signature: string | null
    submissionDate: Date | null
    classification: string | null
    submittedBy: string | null
    receivedBy: string | null
    receivedDate: Date | null
    remarks: string | null
    status: $Enums.ApplicationStatus | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    userId: string | null
    schoolId: string | null
    admissionPaymentId: string | null
    dateOfBirth: Date | null
    nationality: string | null
    sex: string | null
    gradeId: string | null
    mothersTongue: string | null
    religion: string | null
    denomination: string | null
    hometown: string | null
    region: string | null
    profilePicture: string | null
    wardLivesWith: string | null
    numberOfSiblings: number | null
    siblingsOlder: number | null
    siblingsYounger: number | null
    postalAddress: string | null
    residentialAddress: string | null
    wardMobile: string | null
    emergencyContact: string | null
    emergencyMedicalContact: string | null
    medicalSummary: string | null
    bloodType: string | null
    specialDisability: string | null
    feesAcknowledged: boolean | null
    declarationSigned: boolean | null
    signature: string | null
    submissionDate: Date | null
    classification: string | null
    submittedBy: string | null
    receivedBy: string | null
    receivedDate: Date | null
    remarks: string | null
    status: $Enums.ApplicationStatus | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    studentId: number
    userId: number
    schoolId: number
    admissionPaymentId: number
    dateOfBirth: number
    nationality: number
    sex: number
    languages: number
    gradeId: number
    mothersTongue: number
    religion: number
    denomination: number
    hometown: number
    region: number
    profilePicture: number
    wardLivesWith: number
    numberOfSiblings: number
    siblingsOlder: number
    siblingsYounger: number
    postalAddress: number
    residentialAddress: number
    wardMobile: number
    emergencyContact: number
    emergencyMedicalContact: number
    medicalSummary: number
    bloodType: number
    specialDisability: number
    feesAcknowledged: number
    declarationSigned: number
    signature: number
    submissionDate: number
    classification: number
    submittedBy: number
    receivedBy: number
    receivedDate: number
    remarks: number
    status: number
    progress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApplicationAvgAggregateInputType = {
    numberOfSiblings?: true
    siblingsOlder?: true
    siblingsYounger?: true
    progress?: true
  }

  export type ApplicationSumAggregateInputType = {
    numberOfSiblings?: true
    siblingsOlder?: true
    siblingsYounger?: true
    progress?: true
  }

  export type ApplicationMinAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    schoolId?: true
    admissionPaymentId?: true
    dateOfBirth?: true
    nationality?: true
    sex?: true
    gradeId?: true
    mothersTongue?: true
    religion?: true
    denomination?: true
    hometown?: true
    region?: true
    profilePicture?: true
    wardLivesWith?: true
    numberOfSiblings?: true
    siblingsOlder?: true
    siblingsYounger?: true
    postalAddress?: true
    residentialAddress?: true
    wardMobile?: true
    emergencyContact?: true
    emergencyMedicalContact?: true
    medicalSummary?: true
    bloodType?: true
    specialDisability?: true
    feesAcknowledged?: true
    declarationSigned?: true
    signature?: true
    submissionDate?: true
    classification?: true
    submittedBy?: true
    receivedBy?: true
    receivedDate?: true
    remarks?: true
    status?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    schoolId?: true
    admissionPaymentId?: true
    dateOfBirth?: true
    nationality?: true
    sex?: true
    gradeId?: true
    mothersTongue?: true
    religion?: true
    denomination?: true
    hometown?: true
    region?: true
    profilePicture?: true
    wardLivesWith?: true
    numberOfSiblings?: true
    siblingsOlder?: true
    siblingsYounger?: true
    postalAddress?: true
    residentialAddress?: true
    wardMobile?: true
    emergencyContact?: true
    emergencyMedicalContact?: true
    medicalSummary?: true
    bloodType?: true
    specialDisability?: true
    feesAcknowledged?: true
    declarationSigned?: true
    signature?: true
    submissionDate?: true
    classification?: true
    submittedBy?: true
    receivedBy?: true
    receivedDate?: true
    remarks?: true
    status?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    schoolId?: true
    admissionPaymentId?: true
    dateOfBirth?: true
    nationality?: true
    sex?: true
    languages?: true
    gradeId?: true
    mothersTongue?: true
    religion?: true
    denomination?: true
    hometown?: true
    region?: true
    profilePicture?: true
    wardLivesWith?: true
    numberOfSiblings?: true
    siblingsOlder?: true
    siblingsYounger?: true
    postalAddress?: true
    residentialAddress?: true
    wardMobile?: true
    emergencyContact?: true
    emergencyMedicalContact?: true
    medicalSummary?: true
    bloodType?: true
    specialDisability?: true
    feesAcknowledged?: true
    declarationSigned?: true
    signature?: true
    submissionDate?: true
    classification?: true
    submittedBy?: true
    receivedBy?: true
    receivedDate?: true
    remarks?: true
    status?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _avg?: ApplicationAvgAggregateInputType
    _sum?: ApplicationSumAggregateInputType
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: string
    studentId: string | null
    userId: string | null
    schoolId: string | null
    admissionPaymentId: string | null
    dateOfBirth: Date | null
    nationality: string | null
    sex: string | null
    languages: string[]
    gradeId: string | null
    mothersTongue: string | null
    religion: string | null
    denomination: string | null
    hometown: string | null
    region: string | null
    profilePicture: string | null
    wardLivesWith: string | null
    numberOfSiblings: number | null
    siblingsOlder: number | null
    siblingsYounger: number | null
    postalAddress: string | null
    residentialAddress: string | null
    wardMobile: string | null
    emergencyContact: string | null
    emergencyMedicalContact: string | null
    medicalSummary: string | null
    bloodType: string | null
    specialDisability: string | null
    feesAcknowledged: boolean
    declarationSigned: boolean
    signature: string | null
    submissionDate: Date | null
    classification: string | null
    submittedBy: string | null
    receivedBy: string | null
    receivedDate: Date | null
    remarks: string | null
    status: $Enums.ApplicationStatus
    progress: number
    createdAt: Date
    updatedAt: Date
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    userId?: boolean
    schoolId?: boolean
    admissionPaymentId?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    sex?: boolean
    languages?: boolean
    gradeId?: boolean
    mothersTongue?: boolean
    religion?: boolean
    denomination?: boolean
    hometown?: boolean
    region?: boolean
    profilePicture?: boolean
    wardLivesWith?: boolean
    numberOfSiblings?: boolean
    siblingsOlder?: boolean
    siblingsYounger?: boolean
    postalAddress?: boolean
    residentialAddress?: boolean
    wardMobile?: boolean
    emergencyContact?: boolean
    emergencyMedicalContact?: boolean
    medicalSummary?: boolean
    bloodType?: boolean
    specialDisability?: boolean
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: boolean
    submissionDate?: boolean
    classification?: boolean
    submittedBy?: boolean
    receivedBy?: boolean
    receivedDate?: boolean
    remarks?: boolean
    status?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Application$studentArgs<ExtArgs>
    user?: boolean | Application$userArgs<ExtArgs>
    school?: boolean | Application$schoolArgs<ExtArgs>
    admissionPayment?: boolean | Application$admissionPaymentArgs<ExtArgs>
    previousSchools?: boolean | Application$previousSchoolsArgs<ExtArgs>
    familyMembers?: boolean | Application$familyMembersArgs<ExtArgs>
    grade?: boolean | Application$gradeArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    userId?: boolean
    schoolId?: boolean
    admissionPaymentId?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    sex?: boolean
    languages?: boolean
    gradeId?: boolean
    mothersTongue?: boolean
    religion?: boolean
    denomination?: boolean
    hometown?: boolean
    region?: boolean
    profilePicture?: boolean
    wardLivesWith?: boolean
    numberOfSiblings?: boolean
    siblingsOlder?: boolean
    siblingsYounger?: boolean
    postalAddress?: boolean
    residentialAddress?: boolean
    wardMobile?: boolean
    emergencyContact?: boolean
    emergencyMedicalContact?: boolean
    medicalSummary?: boolean
    bloodType?: boolean
    specialDisability?: boolean
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: boolean
    submissionDate?: boolean
    classification?: boolean
    submittedBy?: boolean
    receivedBy?: boolean
    receivedDate?: boolean
    remarks?: boolean
    status?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Application$studentArgs<ExtArgs>
    user?: boolean | Application$userArgs<ExtArgs>
    school?: boolean | Application$schoolArgs<ExtArgs>
    admissionPayment?: boolean | Application$admissionPaymentArgs<ExtArgs>
    grade?: boolean | Application$gradeArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    userId?: boolean
    schoolId?: boolean
    admissionPaymentId?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    sex?: boolean
    languages?: boolean
    gradeId?: boolean
    mothersTongue?: boolean
    religion?: boolean
    denomination?: boolean
    hometown?: boolean
    region?: boolean
    profilePicture?: boolean
    wardLivesWith?: boolean
    numberOfSiblings?: boolean
    siblingsOlder?: boolean
    siblingsYounger?: boolean
    postalAddress?: boolean
    residentialAddress?: boolean
    wardMobile?: boolean
    emergencyContact?: boolean
    emergencyMedicalContact?: boolean
    medicalSummary?: boolean
    bloodType?: boolean
    specialDisability?: boolean
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: boolean
    submissionDate?: boolean
    classification?: boolean
    submittedBy?: boolean
    receivedBy?: boolean
    receivedDate?: boolean
    remarks?: boolean
    status?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Application$studentArgs<ExtArgs>
    user?: boolean | Application$userArgs<ExtArgs>
    school?: boolean | Application$schoolArgs<ExtArgs>
    admissionPayment?: boolean | Application$admissionPaymentArgs<ExtArgs>
    grade?: boolean | Application$gradeArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectScalar = {
    id?: boolean
    studentId?: boolean
    userId?: boolean
    schoolId?: boolean
    admissionPaymentId?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    sex?: boolean
    languages?: boolean
    gradeId?: boolean
    mothersTongue?: boolean
    religion?: boolean
    denomination?: boolean
    hometown?: boolean
    region?: boolean
    profilePicture?: boolean
    wardLivesWith?: boolean
    numberOfSiblings?: boolean
    siblingsOlder?: boolean
    siblingsYounger?: boolean
    postalAddress?: boolean
    residentialAddress?: boolean
    wardMobile?: boolean
    emergencyContact?: boolean
    emergencyMedicalContact?: boolean
    medicalSummary?: boolean
    bloodType?: boolean
    specialDisability?: boolean
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: boolean
    submissionDate?: boolean
    classification?: boolean
    submittedBy?: boolean
    receivedBy?: boolean
    receivedDate?: boolean
    remarks?: boolean
    status?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "userId" | "schoolId" | "admissionPaymentId" | "dateOfBirth" | "nationality" | "sex" | "languages" | "gradeId" | "mothersTongue" | "religion" | "denomination" | "hometown" | "region" | "profilePicture" | "wardLivesWith" | "numberOfSiblings" | "siblingsOlder" | "siblingsYounger" | "postalAddress" | "residentialAddress" | "wardMobile" | "emergencyContact" | "emergencyMedicalContact" | "medicalSummary" | "bloodType" | "specialDisability" | "feesAcknowledged" | "declarationSigned" | "signature" | "submissionDate" | "classification" | "submittedBy" | "receivedBy" | "receivedDate" | "remarks" | "status" | "progress" | "createdAt" | "updatedAt", ExtArgs["result"]["application"]>
  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Application$studentArgs<ExtArgs>
    user?: boolean | Application$userArgs<ExtArgs>
    school?: boolean | Application$schoolArgs<ExtArgs>
    admissionPayment?: boolean | Application$admissionPaymentArgs<ExtArgs>
    previousSchools?: boolean | Application$previousSchoolsArgs<ExtArgs>
    familyMembers?: boolean | Application$familyMembersArgs<ExtArgs>
    grade?: boolean | Application$gradeArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Application$studentArgs<ExtArgs>
    user?: boolean | Application$userArgs<ExtArgs>
    school?: boolean | Application$schoolArgs<ExtArgs>
    admissionPayment?: boolean | Application$admissionPaymentArgs<ExtArgs>
    grade?: boolean | Application$gradeArgs<ExtArgs>
  }
  export type ApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Application$studentArgs<ExtArgs>
    user?: boolean | Application$userArgs<ExtArgs>
    school?: boolean | Application$schoolArgs<ExtArgs>
    admissionPayment?: boolean | Application$admissionPaymentArgs<ExtArgs>
    grade?: boolean | Application$gradeArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs> | null
      admissionPayment: Prisma.$AdmissionPaymentPayload<ExtArgs> | null
      previousSchools: Prisma.$PreviousSchoolPayload<ExtArgs>[]
      familyMembers: Prisma.$FamilyMemberPayload<ExtArgs>[]
      grade: Prisma.$GradePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string | null
      userId: string | null
      schoolId: string | null
      admissionPaymentId: string | null
      dateOfBirth: Date | null
      nationality: string | null
      sex: string | null
      languages: string[]
      gradeId: string | null
      mothersTongue: string | null
      religion: string | null
      denomination: string | null
      hometown: string | null
      region: string | null
      profilePicture: string | null
      wardLivesWith: string | null
      numberOfSiblings: number | null
      siblingsOlder: number | null
      siblingsYounger: number | null
      postalAddress: string | null
      residentialAddress: string | null
      wardMobile: string | null
      emergencyContact: string | null
      emergencyMedicalContact: string | null
      medicalSummary: string | null
      bloodType: string | null
      specialDisability: string | null
      feesAcknowledged: boolean
      declarationSigned: boolean
      signature: string | null
      submissionDate: Date | null
      classification: string | null
      submittedBy: string | null
      receivedBy: string | null
      receivedDate: Date | null
      remarks: string | null
      status: $Enums.ApplicationStatus
      progress: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications and returns the data updated in the database.
     * @param {ApplicationUpdateManyAndReturnArgs} args - Arguments to update many Applications.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends Application$studentArgs<ExtArgs> = {}>(args?: Subset<T, Application$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Application$userArgs<ExtArgs> = {}>(args?: Subset<T, Application$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends Application$schoolArgs<ExtArgs> = {}>(args?: Subset<T, Application$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admissionPayment<T extends Application$admissionPaymentArgs<ExtArgs> = {}>(args?: Subset<T, Application$admissionPaymentArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    previousSchools<T extends Application$previousSchoolsArgs<ExtArgs> = {}>(args?: Subset<T, Application$previousSchoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    familyMembers<T extends Application$familyMembersArgs<ExtArgs> = {}>(args?: Subset<T, Application$familyMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grade<T extends Application$gradeArgs<ExtArgs> = {}>(args?: Subset<T, Application$gradeArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'String'>
    readonly studentId: FieldRef<"Application", 'String'>
    readonly userId: FieldRef<"Application", 'String'>
    readonly schoolId: FieldRef<"Application", 'String'>
    readonly admissionPaymentId: FieldRef<"Application", 'String'>
    readonly dateOfBirth: FieldRef<"Application", 'DateTime'>
    readonly nationality: FieldRef<"Application", 'String'>
    readonly sex: FieldRef<"Application", 'String'>
    readonly languages: FieldRef<"Application", 'String[]'>
    readonly gradeId: FieldRef<"Application", 'String'>
    readonly mothersTongue: FieldRef<"Application", 'String'>
    readonly religion: FieldRef<"Application", 'String'>
    readonly denomination: FieldRef<"Application", 'String'>
    readonly hometown: FieldRef<"Application", 'String'>
    readonly region: FieldRef<"Application", 'String'>
    readonly profilePicture: FieldRef<"Application", 'String'>
    readonly wardLivesWith: FieldRef<"Application", 'String'>
    readonly numberOfSiblings: FieldRef<"Application", 'Int'>
    readonly siblingsOlder: FieldRef<"Application", 'Int'>
    readonly siblingsYounger: FieldRef<"Application", 'Int'>
    readonly postalAddress: FieldRef<"Application", 'String'>
    readonly residentialAddress: FieldRef<"Application", 'String'>
    readonly wardMobile: FieldRef<"Application", 'String'>
    readonly emergencyContact: FieldRef<"Application", 'String'>
    readonly emergencyMedicalContact: FieldRef<"Application", 'String'>
    readonly medicalSummary: FieldRef<"Application", 'String'>
    readonly bloodType: FieldRef<"Application", 'String'>
    readonly specialDisability: FieldRef<"Application", 'String'>
    readonly feesAcknowledged: FieldRef<"Application", 'Boolean'>
    readonly declarationSigned: FieldRef<"Application", 'Boolean'>
    readonly signature: FieldRef<"Application", 'String'>
    readonly submissionDate: FieldRef<"Application", 'DateTime'>
    readonly classification: FieldRef<"Application", 'String'>
    readonly submittedBy: FieldRef<"Application", 'String'>
    readonly receivedBy: FieldRef<"Application", 'String'>
    readonly receivedDate: FieldRef<"Application", 'DateTime'>
    readonly remarks: FieldRef<"Application", 'String'>
    readonly status: FieldRef<"Application", 'ApplicationStatus'>
    readonly progress: FieldRef<"Application", 'Int'>
    readonly createdAt: FieldRef<"Application", 'DateTime'>
    readonly updatedAt: FieldRef<"Application", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
  }

  /**
   * Application updateManyAndReturn
   */
  export type ApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to delete.
     */
    limit?: number
  }

  /**
   * Application.student
   */
  export type Application$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Application.user
   */
  export type Application$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Application.school
   */
  export type Application$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * Application.admissionPayment
   */
  export type Application$admissionPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    where?: AdmissionPaymentWhereInput
  }

  /**
   * Application.previousSchools
   */
  export type Application$previousSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    where?: PreviousSchoolWhereInput
    orderBy?: PreviousSchoolOrderByWithRelationInput | PreviousSchoolOrderByWithRelationInput[]
    cursor?: PreviousSchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreviousSchoolScalarFieldEnum | PreviousSchoolScalarFieldEnum[]
  }

  /**
   * Application.familyMembers
   */
  export type Application$familyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    cursor?: FamilyMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * Application.grade
   */
  export type Application$gradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model PreviousSchool
   */

  export type AggregatePreviousSchool = {
    _count: PreviousSchoolCountAggregateOutputType | null
    _min: PreviousSchoolMinAggregateOutputType | null
    _max: PreviousSchoolMaxAggregateOutputType | null
  }

  export type PreviousSchoolMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    name: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreviousSchoolMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    name: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreviousSchoolCountAggregateOutputType = {
    id: number
    applicationId: number
    name: number
    location: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PreviousSchoolMinAggregateInputType = {
    id?: true
    applicationId?: true
    name?: true
    location?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreviousSchoolMaxAggregateInputType = {
    id?: true
    applicationId?: true
    name?: true
    location?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreviousSchoolCountAggregateInputType = {
    id?: true
    applicationId?: true
    name?: true
    location?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PreviousSchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreviousSchool to aggregate.
     */
    where?: PreviousSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreviousSchools to fetch.
     */
    orderBy?: PreviousSchoolOrderByWithRelationInput | PreviousSchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreviousSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreviousSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreviousSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreviousSchools
    **/
    _count?: true | PreviousSchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreviousSchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreviousSchoolMaxAggregateInputType
  }

  export type GetPreviousSchoolAggregateType<T extends PreviousSchoolAggregateArgs> = {
        [P in keyof T & keyof AggregatePreviousSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreviousSchool[P]>
      : GetScalarType<T[P], AggregatePreviousSchool[P]>
  }




  export type PreviousSchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreviousSchoolWhereInput
    orderBy?: PreviousSchoolOrderByWithAggregationInput | PreviousSchoolOrderByWithAggregationInput[]
    by: PreviousSchoolScalarFieldEnum[] | PreviousSchoolScalarFieldEnum
    having?: PreviousSchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreviousSchoolCountAggregateInputType | true
    _min?: PreviousSchoolMinAggregateInputType
    _max?: PreviousSchoolMaxAggregateInputType
  }

  export type PreviousSchoolGroupByOutputType = {
    id: string
    applicationId: string
    name: string
    location: string
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: PreviousSchoolCountAggregateOutputType | null
    _min: PreviousSchoolMinAggregateOutputType | null
    _max: PreviousSchoolMaxAggregateOutputType | null
  }

  type GetPreviousSchoolGroupByPayload<T extends PreviousSchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreviousSchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreviousSchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreviousSchoolGroupByOutputType[P]>
            : GetScalarType<T[P], PreviousSchoolGroupByOutputType[P]>
        }
      >
    >


  export type PreviousSchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    name?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["previousSchool"]>

  export type PreviousSchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    name?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["previousSchool"]>

  export type PreviousSchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    name?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["previousSchool"]>

  export type PreviousSchoolSelectScalar = {
    id?: boolean
    applicationId?: boolean
    name?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PreviousSchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "name" | "location" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["previousSchool"]>
  export type PreviousSchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type PreviousSchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type PreviousSchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $PreviousSchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreviousSchool"
    objects: {
      application: Prisma.$ApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      name: string
      location: string
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["previousSchool"]>
    composites: {}
  }

  type PreviousSchoolGetPayload<S extends boolean | null | undefined | PreviousSchoolDefaultArgs> = $Result.GetResult<Prisma.$PreviousSchoolPayload, S>

  type PreviousSchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreviousSchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreviousSchoolCountAggregateInputType | true
    }

  export interface PreviousSchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreviousSchool'], meta: { name: 'PreviousSchool' } }
    /**
     * Find zero or one PreviousSchool that matches the filter.
     * @param {PreviousSchoolFindUniqueArgs} args - Arguments to find a PreviousSchool
     * @example
     * // Get one PreviousSchool
     * const previousSchool = await prisma.previousSchool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreviousSchoolFindUniqueArgs>(args: SelectSubset<T, PreviousSchoolFindUniqueArgs<ExtArgs>>): Prisma__PreviousSchoolClient<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreviousSchool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreviousSchoolFindUniqueOrThrowArgs} args - Arguments to find a PreviousSchool
     * @example
     * // Get one PreviousSchool
     * const previousSchool = await prisma.previousSchool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreviousSchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, PreviousSchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreviousSchoolClient<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreviousSchool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousSchoolFindFirstArgs} args - Arguments to find a PreviousSchool
     * @example
     * // Get one PreviousSchool
     * const previousSchool = await prisma.previousSchool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreviousSchoolFindFirstArgs>(args?: SelectSubset<T, PreviousSchoolFindFirstArgs<ExtArgs>>): Prisma__PreviousSchoolClient<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreviousSchool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousSchoolFindFirstOrThrowArgs} args - Arguments to find a PreviousSchool
     * @example
     * // Get one PreviousSchool
     * const previousSchool = await prisma.previousSchool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreviousSchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, PreviousSchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreviousSchoolClient<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreviousSchools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousSchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreviousSchools
     * const previousSchools = await prisma.previousSchool.findMany()
     * 
     * // Get first 10 PreviousSchools
     * const previousSchools = await prisma.previousSchool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const previousSchoolWithIdOnly = await prisma.previousSchool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreviousSchoolFindManyArgs>(args?: SelectSubset<T, PreviousSchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreviousSchool.
     * @param {PreviousSchoolCreateArgs} args - Arguments to create a PreviousSchool.
     * @example
     * // Create one PreviousSchool
     * const PreviousSchool = await prisma.previousSchool.create({
     *   data: {
     *     // ... data to create a PreviousSchool
     *   }
     * })
     * 
     */
    create<T extends PreviousSchoolCreateArgs>(args: SelectSubset<T, PreviousSchoolCreateArgs<ExtArgs>>): Prisma__PreviousSchoolClient<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreviousSchools.
     * @param {PreviousSchoolCreateManyArgs} args - Arguments to create many PreviousSchools.
     * @example
     * // Create many PreviousSchools
     * const previousSchool = await prisma.previousSchool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreviousSchoolCreateManyArgs>(args?: SelectSubset<T, PreviousSchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreviousSchools and returns the data saved in the database.
     * @param {PreviousSchoolCreateManyAndReturnArgs} args - Arguments to create many PreviousSchools.
     * @example
     * // Create many PreviousSchools
     * const previousSchool = await prisma.previousSchool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreviousSchools and only return the `id`
     * const previousSchoolWithIdOnly = await prisma.previousSchool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreviousSchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, PreviousSchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreviousSchool.
     * @param {PreviousSchoolDeleteArgs} args - Arguments to delete one PreviousSchool.
     * @example
     * // Delete one PreviousSchool
     * const PreviousSchool = await prisma.previousSchool.delete({
     *   where: {
     *     // ... filter to delete one PreviousSchool
     *   }
     * })
     * 
     */
    delete<T extends PreviousSchoolDeleteArgs>(args: SelectSubset<T, PreviousSchoolDeleteArgs<ExtArgs>>): Prisma__PreviousSchoolClient<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreviousSchool.
     * @param {PreviousSchoolUpdateArgs} args - Arguments to update one PreviousSchool.
     * @example
     * // Update one PreviousSchool
     * const previousSchool = await prisma.previousSchool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreviousSchoolUpdateArgs>(args: SelectSubset<T, PreviousSchoolUpdateArgs<ExtArgs>>): Prisma__PreviousSchoolClient<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreviousSchools.
     * @param {PreviousSchoolDeleteManyArgs} args - Arguments to filter PreviousSchools to delete.
     * @example
     * // Delete a few PreviousSchools
     * const { count } = await prisma.previousSchool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreviousSchoolDeleteManyArgs>(args?: SelectSubset<T, PreviousSchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreviousSchools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousSchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreviousSchools
     * const previousSchool = await prisma.previousSchool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreviousSchoolUpdateManyArgs>(args: SelectSubset<T, PreviousSchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreviousSchools and returns the data updated in the database.
     * @param {PreviousSchoolUpdateManyAndReturnArgs} args - Arguments to update many PreviousSchools.
     * @example
     * // Update many PreviousSchools
     * const previousSchool = await prisma.previousSchool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreviousSchools and only return the `id`
     * const previousSchoolWithIdOnly = await prisma.previousSchool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PreviousSchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, PreviousSchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreviousSchool.
     * @param {PreviousSchoolUpsertArgs} args - Arguments to update or create a PreviousSchool.
     * @example
     * // Update or create a PreviousSchool
     * const previousSchool = await prisma.previousSchool.upsert({
     *   create: {
     *     // ... data to create a PreviousSchool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreviousSchool we want to update
     *   }
     * })
     */
    upsert<T extends PreviousSchoolUpsertArgs>(args: SelectSubset<T, PreviousSchoolUpsertArgs<ExtArgs>>): Prisma__PreviousSchoolClient<$Result.GetResult<Prisma.$PreviousSchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreviousSchools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousSchoolCountArgs} args - Arguments to filter PreviousSchools to count.
     * @example
     * // Count the number of PreviousSchools
     * const count = await prisma.previousSchool.count({
     *   where: {
     *     // ... the filter for the PreviousSchools we want to count
     *   }
     * })
    **/
    count<T extends PreviousSchoolCountArgs>(
      args?: Subset<T, PreviousSchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreviousSchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreviousSchool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousSchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreviousSchoolAggregateArgs>(args: Subset<T, PreviousSchoolAggregateArgs>): Prisma.PrismaPromise<GetPreviousSchoolAggregateType<T>>

    /**
     * Group by PreviousSchool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousSchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreviousSchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreviousSchoolGroupByArgs['orderBy'] }
        : { orderBy?: PreviousSchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreviousSchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreviousSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreviousSchool model
   */
  readonly fields: PreviousSchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreviousSchool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreviousSchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PreviousSchool model
   */
  interface PreviousSchoolFieldRefs {
    readonly id: FieldRef<"PreviousSchool", 'String'>
    readonly applicationId: FieldRef<"PreviousSchool", 'String'>
    readonly name: FieldRef<"PreviousSchool", 'String'>
    readonly location: FieldRef<"PreviousSchool", 'String'>
    readonly startDate: FieldRef<"PreviousSchool", 'DateTime'>
    readonly endDate: FieldRef<"PreviousSchool", 'DateTime'>
    readonly createdAt: FieldRef<"PreviousSchool", 'DateTime'>
    readonly updatedAt: FieldRef<"PreviousSchool", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PreviousSchool findUnique
   */
  export type PreviousSchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * Filter, which PreviousSchool to fetch.
     */
    where: PreviousSchoolWhereUniqueInput
  }

  /**
   * PreviousSchool findUniqueOrThrow
   */
  export type PreviousSchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * Filter, which PreviousSchool to fetch.
     */
    where: PreviousSchoolWhereUniqueInput
  }

  /**
   * PreviousSchool findFirst
   */
  export type PreviousSchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * Filter, which PreviousSchool to fetch.
     */
    where?: PreviousSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreviousSchools to fetch.
     */
    orderBy?: PreviousSchoolOrderByWithRelationInput | PreviousSchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreviousSchools.
     */
    cursor?: PreviousSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreviousSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreviousSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreviousSchools.
     */
    distinct?: PreviousSchoolScalarFieldEnum | PreviousSchoolScalarFieldEnum[]
  }

  /**
   * PreviousSchool findFirstOrThrow
   */
  export type PreviousSchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * Filter, which PreviousSchool to fetch.
     */
    where?: PreviousSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreviousSchools to fetch.
     */
    orderBy?: PreviousSchoolOrderByWithRelationInput | PreviousSchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreviousSchools.
     */
    cursor?: PreviousSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreviousSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreviousSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreviousSchools.
     */
    distinct?: PreviousSchoolScalarFieldEnum | PreviousSchoolScalarFieldEnum[]
  }

  /**
   * PreviousSchool findMany
   */
  export type PreviousSchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * Filter, which PreviousSchools to fetch.
     */
    where?: PreviousSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreviousSchools to fetch.
     */
    orderBy?: PreviousSchoolOrderByWithRelationInput | PreviousSchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreviousSchools.
     */
    cursor?: PreviousSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreviousSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreviousSchools.
     */
    skip?: number
    distinct?: PreviousSchoolScalarFieldEnum | PreviousSchoolScalarFieldEnum[]
  }

  /**
   * PreviousSchool create
   */
  export type PreviousSchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a PreviousSchool.
     */
    data: XOR<PreviousSchoolCreateInput, PreviousSchoolUncheckedCreateInput>
  }

  /**
   * PreviousSchool createMany
   */
  export type PreviousSchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreviousSchools.
     */
    data: PreviousSchoolCreateManyInput | PreviousSchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PreviousSchool createManyAndReturn
   */
  export type PreviousSchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * The data used to create many PreviousSchools.
     */
    data: PreviousSchoolCreateManyInput | PreviousSchoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreviousSchool update
   */
  export type PreviousSchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a PreviousSchool.
     */
    data: XOR<PreviousSchoolUpdateInput, PreviousSchoolUncheckedUpdateInput>
    /**
     * Choose, which PreviousSchool to update.
     */
    where: PreviousSchoolWhereUniqueInput
  }

  /**
   * PreviousSchool updateMany
   */
  export type PreviousSchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreviousSchools.
     */
    data: XOR<PreviousSchoolUpdateManyMutationInput, PreviousSchoolUncheckedUpdateManyInput>
    /**
     * Filter which PreviousSchools to update
     */
    where?: PreviousSchoolWhereInput
    /**
     * Limit how many PreviousSchools to update.
     */
    limit?: number
  }

  /**
   * PreviousSchool updateManyAndReturn
   */
  export type PreviousSchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * The data used to update PreviousSchools.
     */
    data: XOR<PreviousSchoolUpdateManyMutationInput, PreviousSchoolUncheckedUpdateManyInput>
    /**
     * Filter which PreviousSchools to update
     */
    where?: PreviousSchoolWhereInput
    /**
     * Limit how many PreviousSchools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreviousSchool upsert
   */
  export type PreviousSchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the PreviousSchool to update in case it exists.
     */
    where: PreviousSchoolWhereUniqueInput
    /**
     * In case the PreviousSchool found by the `where` argument doesn't exist, create a new PreviousSchool with this data.
     */
    create: XOR<PreviousSchoolCreateInput, PreviousSchoolUncheckedCreateInput>
    /**
     * In case the PreviousSchool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreviousSchoolUpdateInput, PreviousSchoolUncheckedUpdateInput>
  }

  /**
   * PreviousSchool delete
   */
  export type PreviousSchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
    /**
     * Filter which PreviousSchool to delete.
     */
    where: PreviousSchoolWhereUniqueInput
  }

  /**
   * PreviousSchool deleteMany
   */
  export type PreviousSchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreviousSchools to delete
     */
    where?: PreviousSchoolWhereInput
    /**
     * Limit how many PreviousSchools to delete.
     */
    limit?: number
  }

  /**
   * PreviousSchool without action
   */
  export type PreviousSchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousSchool
     */
    select?: PreviousSchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousSchool
     */
    omit?: PreviousSchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousSchoolInclude<ExtArgs> | null
  }


  /**
   * Model FamilyMember
   */

  export type AggregateFamilyMember = {
    _count: FamilyMemberCountAggregateOutputType | null
    _min: FamilyMemberMinAggregateOutputType | null
    _max: FamilyMemberMaxAggregateOutputType | null
  }

  export type FamilyMemberMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    relation: string | null
    name: string | null
    postalAddress: string | null
    residentialAddress: string | null
    phone: string | null
    email: string | null
    occupation: string | null
    workplace: string | null
    religion: string | null
    isAlive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyMemberMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    relation: string | null
    name: string | null
    postalAddress: string | null
    residentialAddress: string | null
    phone: string | null
    email: string | null
    occupation: string | null
    workplace: string | null
    religion: string | null
    isAlive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyMemberCountAggregateOutputType = {
    id: number
    applicationId: number
    relation: number
    name: number
    postalAddress: number
    residentialAddress: number
    phone: number
    email: number
    occupation: number
    workplace: number
    religion: number
    isAlive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FamilyMemberMinAggregateInputType = {
    id?: true
    applicationId?: true
    relation?: true
    name?: true
    postalAddress?: true
    residentialAddress?: true
    phone?: true
    email?: true
    occupation?: true
    workplace?: true
    religion?: true
    isAlive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyMemberMaxAggregateInputType = {
    id?: true
    applicationId?: true
    relation?: true
    name?: true
    postalAddress?: true
    residentialAddress?: true
    phone?: true
    email?: true
    occupation?: true
    workplace?: true
    religion?: true
    isAlive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyMemberCountAggregateInputType = {
    id?: true
    applicationId?: true
    relation?: true
    name?: true
    postalAddress?: true
    residentialAddress?: true
    phone?: true
    email?: true
    occupation?: true
    workplace?: true
    religion?: true
    isAlive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FamilyMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMember to aggregate.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyMembers
    **/
    _count?: true | FamilyMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyMemberMaxAggregateInputType
  }

  export type GetFamilyMemberAggregateType<T extends FamilyMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyMember[P]>
      : GetScalarType<T[P], AggregateFamilyMember[P]>
  }




  export type FamilyMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithAggregationInput | FamilyMemberOrderByWithAggregationInput[]
    by: FamilyMemberScalarFieldEnum[] | FamilyMemberScalarFieldEnum
    having?: FamilyMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyMemberCountAggregateInputType | true
    _min?: FamilyMemberMinAggregateInputType
    _max?: FamilyMemberMaxAggregateInputType
  }

  export type FamilyMemberGroupByOutputType = {
    id: string
    applicationId: string
    relation: string
    name: string
    postalAddress: string
    residentialAddress: string
    phone: string | null
    email: string | null
    occupation: string | null
    workplace: string | null
    religion: string | null
    isAlive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FamilyMemberCountAggregateOutputType | null
    _min: FamilyMemberMinAggregateOutputType | null
    _max: FamilyMemberMaxAggregateOutputType | null
  }

  type GetFamilyMemberGroupByPayload<T extends FamilyMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyMemberGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyMemberGroupByOutputType[P]>
        }
      >
    >


  export type FamilyMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    relation?: boolean
    name?: boolean
    postalAddress?: boolean
    residentialAddress?: boolean
    phone?: boolean
    email?: boolean
    occupation?: boolean
    workplace?: boolean
    religion?: boolean
    isAlive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMember"]>

  export type FamilyMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    relation?: boolean
    name?: boolean
    postalAddress?: boolean
    residentialAddress?: boolean
    phone?: boolean
    email?: boolean
    occupation?: boolean
    workplace?: boolean
    religion?: boolean
    isAlive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMember"]>

  export type FamilyMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    relation?: boolean
    name?: boolean
    postalAddress?: boolean
    residentialAddress?: boolean
    phone?: boolean
    email?: boolean
    occupation?: boolean
    workplace?: boolean
    religion?: boolean
    isAlive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMember"]>

  export type FamilyMemberSelectScalar = {
    id?: boolean
    applicationId?: boolean
    relation?: boolean
    name?: boolean
    postalAddress?: boolean
    residentialAddress?: boolean
    phone?: boolean
    email?: boolean
    occupation?: boolean
    workplace?: boolean
    religion?: boolean
    isAlive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FamilyMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "relation" | "name" | "postalAddress" | "residentialAddress" | "phone" | "email" | "occupation" | "workplace" | "religion" | "isAlive" | "createdAt" | "updatedAt", ExtArgs["result"]["familyMember"]>
  export type FamilyMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type FamilyMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type FamilyMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $FamilyMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyMember"
    objects: {
      application: Prisma.$ApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      relation: string
      name: string
      postalAddress: string
      residentialAddress: string
      phone: string | null
      email: string | null
      occupation: string | null
      workplace: string | null
      religion: string | null
      isAlive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["familyMember"]>
    composites: {}
  }

  type FamilyMemberGetPayload<S extends boolean | null | undefined | FamilyMemberDefaultArgs> = $Result.GetResult<Prisma.$FamilyMemberPayload, S>

  type FamilyMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyMemberCountAggregateInputType | true
    }

  export interface FamilyMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyMember'], meta: { name: 'FamilyMember' } }
    /**
     * Find zero or one FamilyMember that matches the filter.
     * @param {FamilyMemberFindUniqueArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyMemberFindUniqueArgs>(args: SelectSubset<T, FamilyMemberFindUniqueArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyMemberFindUniqueOrThrowArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindFirstArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyMemberFindFirstArgs>(args?: SelectSubset<T, FamilyMemberFindFirstArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindFirstOrThrowArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyMembers
     * const familyMembers = await prisma.familyMember.findMany()
     * 
     * // Get first 10 FamilyMembers
     * const familyMembers = await prisma.familyMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyMemberWithIdOnly = await prisma.familyMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyMemberFindManyArgs>(args?: SelectSubset<T, FamilyMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyMember.
     * @param {FamilyMemberCreateArgs} args - Arguments to create a FamilyMember.
     * @example
     * // Create one FamilyMember
     * const FamilyMember = await prisma.familyMember.create({
     *   data: {
     *     // ... data to create a FamilyMember
     *   }
     * })
     * 
     */
    create<T extends FamilyMemberCreateArgs>(args: SelectSubset<T, FamilyMemberCreateArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyMembers.
     * @param {FamilyMemberCreateManyArgs} args - Arguments to create many FamilyMembers.
     * @example
     * // Create many FamilyMembers
     * const familyMember = await prisma.familyMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyMemberCreateManyArgs>(args?: SelectSubset<T, FamilyMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FamilyMembers and returns the data saved in the database.
     * @param {FamilyMemberCreateManyAndReturnArgs} args - Arguments to create many FamilyMembers.
     * @example
     * // Create many FamilyMembers
     * const familyMember = await prisma.familyMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FamilyMembers and only return the `id`
     * const familyMemberWithIdOnly = await prisma.familyMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FamilyMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, FamilyMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FamilyMember.
     * @param {FamilyMemberDeleteArgs} args - Arguments to delete one FamilyMember.
     * @example
     * // Delete one FamilyMember
     * const FamilyMember = await prisma.familyMember.delete({
     *   where: {
     *     // ... filter to delete one FamilyMember
     *   }
     * })
     * 
     */
    delete<T extends FamilyMemberDeleteArgs>(args: SelectSubset<T, FamilyMemberDeleteArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyMember.
     * @param {FamilyMemberUpdateArgs} args - Arguments to update one FamilyMember.
     * @example
     * // Update one FamilyMember
     * const familyMember = await prisma.familyMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyMemberUpdateArgs>(args: SelectSubset<T, FamilyMemberUpdateArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyMembers.
     * @param {FamilyMemberDeleteManyArgs} args - Arguments to filter FamilyMembers to delete.
     * @example
     * // Delete a few FamilyMembers
     * const { count } = await prisma.familyMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyMemberDeleteManyArgs>(args?: SelectSubset<T, FamilyMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyMembers
     * const familyMember = await prisma.familyMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyMemberUpdateManyArgs>(args: SelectSubset<T, FamilyMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMembers and returns the data updated in the database.
     * @param {FamilyMemberUpdateManyAndReturnArgs} args - Arguments to update many FamilyMembers.
     * @example
     * // Update many FamilyMembers
     * const familyMember = await prisma.familyMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FamilyMembers and only return the `id`
     * const familyMemberWithIdOnly = await prisma.familyMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FamilyMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, FamilyMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FamilyMember.
     * @param {FamilyMemberUpsertArgs} args - Arguments to update or create a FamilyMember.
     * @example
     * // Update or create a FamilyMember
     * const familyMember = await prisma.familyMember.upsert({
     *   create: {
     *     // ... data to create a FamilyMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyMember we want to update
     *   }
     * })
     */
    upsert<T extends FamilyMemberUpsertArgs>(args: SelectSubset<T, FamilyMemberUpsertArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberCountArgs} args - Arguments to filter FamilyMembers to count.
     * @example
     * // Count the number of FamilyMembers
     * const count = await prisma.familyMember.count({
     *   where: {
     *     // ... the filter for the FamilyMembers we want to count
     *   }
     * })
    **/
    count<T extends FamilyMemberCountArgs>(
      args?: Subset<T, FamilyMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyMemberAggregateArgs>(args: Subset<T, FamilyMemberAggregateArgs>): Prisma.PrismaPromise<GetFamilyMemberAggregateType<T>>

    /**
     * Group by FamilyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyMemberGroupByArgs['orderBy'] }
        : { orderBy?: FamilyMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyMember model
   */
  readonly fields: FamilyMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyMember model
   */
  interface FamilyMemberFieldRefs {
    readonly id: FieldRef<"FamilyMember", 'String'>
    readonly applicationId: FieldRef<"FamilyMember", 'String'>
    readonly relation: FieldRef<"FamilyMember", 'String'>
    readonly name: FieldRef<"FamilyMember", 'String'>
    readonly postalAddress: FieldRef<"FamilyMember", 'String'>
    readonly residentialAddress: FieldRef<"FamilyMember", 'String'>
    readonly phone: FieldRef<"FamilyMember", 'String'>
    readonly email: FieldRef<"FamilyMember", 'String'>
    readonly occupation: FieldRef<"FamilyMember", 'String'>
    readonly workplace: FieldRef<"FamilyMember", 'String'>
    readonly religion: FieldRef<"FamilyMember", 'String'>
    readonly isAlive: FieldRef<"FamilyMember", 'Boolean'>
    readonly createdAt: FieldRef<"FamilyMember", 'DateTime'>
    readonly updatedAt: FieldRef<"FamilyMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyMember findUnique
   */
  export type FamilyMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember findUniqueOrThrow
   */
  export type FamilyMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember findFirst
   */
  export type FamilyMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMembers.
     */
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember findFirstOrThrow
   */
  export type FamilyMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMembers.
     */
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember findMany
   */
  export type FamilyMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMembers to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember create
   */
  export type FamilyMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyMember.
     */
    data: XOR<FamilyMemberCreateInput, FamilyMemberUncheckedCreateInput>
  }

  /**
   * FamilyMember createMany
   */
  export type FamilyMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyMembers.
     */
    data: FamilyMemberCreateManyInput | FamilyMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyMember createManyAndReturn
   */
  export type FamilyMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * The data used to create many FamilyMembers.
     */
    data: FamilyMemberCreateManyInput | FamilyMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FamilyMember update
   */
  export type FamilyMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyMember.
     */
    data: XOR<FamilyMemberUpdateInput, FamilyMemberUncheckedUpdateInput>
    /**
     * Choose, which FamilyMember to update.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember updateMany
   */
  export type FamilyMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyMembers.
     */
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMembers to update
     */
    where?: FamilyMemberWhereInput
    /**
     * Limit how many FamilyMembers to update.
     */
    limit?: number
  }

  /**
   * FamilyMember updateManyAndReturn
   */
  export type FamilyMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * The data used to update FamilyMembers.
     */
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMembers to update
     */
    where?: FamilyMemberWhereInput
    /**
     * Limit how many FamilyMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FamilyMember upsert
   */
  export type FamilyMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyMember to update in case it exists.
     */
    where: FamilyMemberWhereUniqueInput
    /**
     * In case the FamilyMember found by the `where` argument doesn't exist, create a new FamilyMember with this data.
     */
    create: XOR<FamilyMemberCreateInput, FamilyMemberUncheckedCreateInput>
    /**
     * In case the FamilyMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyMemberUpdateInput, FamilyMemberUncheckedUpdateInput>
  }

  /**
   * FamilyMember delete
   */
  export type FamilyMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter which FamilyMember to delete.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember deleteMany
   */
  export type FamilyMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMembers to delete
     */
    where?: FamilyMemberWhereInput
    /**
     * Limit how many FamilyMembers to delete.
     */
    limit?: number
  }

  /**
   * FamilyMember without action
   */
  export type FamilyMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
  }


  /**
   * Model StaffApplication
   */

  export type AggregateStaffApplication = {
    _count: StaffApplicationCountAggregateOutputType | null
    _avg: StaffApplicationAvgAggregateOutputType | null
    _sum: StaffApplicationSumAggregateOutputType | null
    _min: StaffApplicationMinAggregateOutputType | null
    _max: StaffApplicationMaxAggregateOutputType | null
  }

  export type StaffApplicationAvgAggregateOutputType = {
    salary: number | null
  }

  export type StaffApplicationSumAggregateOutputType = {
    salary: number | null
  }

  export type StaffApplicationMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    schoolId: string | null
    surname: string | null
    firstName: string | null
    otherNames: string | null
    dateOfBirth: Date | null
    nationality: string | null
    sex: string | null
    maritalStatus: string | null
    religion: string | null
    denomination: string | null
    hometown: string | null
    region: string | null
    profilePicture: string | null
    residentialAddress: string | null
    postalAddress: string | null
    mobile: string | null
    email: string | null
    emergencyContact: string | null
    nextOfKin: string | null
    position: string | null
    departmentId: string | null
    hireDate: Date | null
    salary: number | null
    qualifications: string | null
    bloodType: string | null
    medicalConditions: string | null
    specialDisability: string | null
    declarationSigned: boolean | null
    signature: string | null
    submissionDate: Date | null
    classification: string | null
    submittedBy: string | null
    receivedBy: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffApplicationMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    schoolId: string | null
    surname: string | null
    firstName: string | null
    otherNames: string | null
    dateOfBirth: Date | null
    nationality: string | null
    sex: string | null
    maritalStatus: string | null
    religion: string | null
    denomination: string | null
    hometown: string | null
    region: string | null
    profilePicture: string | null
    residentialAddress: string | null
    postalAddress: string | null
    mobile: string | null
    email: string | null
    emergencyContact: string | null
    nextOfKin: string | null
    position: string | null
    departmentId: string | null
    hireDate: Date | null
    salary: number | null
    qualifications: string | null
    bloodType: string | null
    medicalConditions: string | null
    specialDisability: string | null
    declarationSigned: boolean | null
    signature: string | null
    submissionDate: Date | null
    classification: string | null
    submittedBy: string | null
    receivedBy: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffApplicationCountAggregateOutputType = {
    id: number
    staffId: number
    schoolId: number
    surname: number
    firstName: number
    otherNames: number
    dateOfBirth: number
    nationality: number
    sex: number
    languages: number
    maritalStatus: number
    religion: number
    denomination: number
    hometown: number
    region: number
    profilePicture: number
    residentialAddress: number
    postalAddress: number
    mobile: number
    email: number
    emergencyContact: number
    nextOfKin: number
    position: number
    departmentId: number
    hireDate: number
    salary: number
    qualifications: number
    bloodType: number
    medicalConditions: number
    specialDisability: number
    declarationSigned: number
    signature: number
    submissionDate: number
    classification: number
    submittedBy: number
    receivedBy: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffApplicationAvgAggregateInputType = {
    salary?: true
  }

  export type StaffApplicationSumAggregateInputType = {
    salary?: true
  }

  export type StaffApplicationMinAggregateInputType = {
    id?: true
    staffId?: true
    schoolId?: true
    surname?: true
    firstName?: true
    otherNames?: true
    dateOfBirth?: true
    nationality?: true
    sex?: true
    maritalStatus?: true
    religion?: true
    denomination?: true
    hometown?: true
    region?: true
    profilePicture?: true
    residentialAddress?: true
    postalAddress?: true
    mobile?: true
    email?: true
    emergencyContact?: true
    nextOfKin?: true
    position?: true
    departmentId?: true
    hireDate?: true
    salary?: true
    qualifications?: true
    bloodType?: true
    medicalConditions?: true
    specialDisability?: true
    declarationSigned?: true
    signature?: true
    submissionDate?: true
    classification?: true
    submittedBy?: true
    receivedBy?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffApplicationMaxAggregateInputType = {
    id?: true
    staffId?: true
    schoolId?: true
    surname?: true
    firstName?: true
    otherNames?: true
    dateOfBirth?: true
    nationality?: true
    sex?: true
    maritalStatus?: true
    religion?: true
    denomination?: true
    hometown?: true
    region?: true
    profilePicture?: true
    residentialAddress?: true
    postalAddress?: true
    mobile?: true
    email?: true
    emergencyContact?: true
    nextOfKin?: true
    position?: true
    departmentId?: true
    hireDate?: true
    salary?: true
    qualifications?: true
    bloodType?: true
    medicalConditions?: true
    specialDisability?: true
    declarationSigned?: true
    signature?: true
    submissionDate?: true
    classification?: true
    submittedBy?: true
    receivedBy?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffApplicationCountAggregateInputType = {
    id?: true
    staffId?: true
    schoolId?: true
    surname?: true
    firstName?: true
    otherNames?: true
    dateOfBirth?: true
    nationality?: true
    sex?: true
    languages?: true
    maritalStatus?: true
    religion?: true
    denomination?: true
    hometown?: true
    region?: true
    profilePicture?: true
    residentialAddress?: true
    postalAddress?: true
    mobile?: true
    email?: true
    emergencyContact?: true
    nextOfKin?: true
    position?: true
    departmentId?: true
    hireDate?: true
    salary?: true
    qualifications?: true
    bloodType?: true
    medicalConditions?: true
    specialDisability?: true
    declarationSigned?: true
    signature?: true
    submissionDate?: true
    classification?: true
    submittedBy?: true
    receivedBy?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffApplication to aggregate.
     */
    where?: StaffApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffApplications to fetch.
     */
    orderBy?: StaffApplicationOrderByWithRelationInput | StaffApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffApplications
    **/
    _count?: true | StaffApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffApplicationMaxAggregateInputType
  }

  export type GetStaffApplicationAggregateType<T extends StaffApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffApplication[P]>
      : GetScalarType<T[P], AggregateStaffApplication[P]>
  }




  export type StaffApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffApplicationWhereInput
    orderBy?: StaffApplicationOrderByWithAggregationInput | StaffApplicationOrderByWithAggregationInput[]
    by: StaffApplicationScalarFieldEnum[] | StaffApplicationScalarFieldEnum
    having?: StaffApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffApplicationCountAggregateInputType | true
    _avg?: StaffApplicationAvgAggregateInputType
    _sum?: StaffApplicationSumAggregateInputType
    _min?: StaffApplicationMinAggregateInputType
    _max?: StaffApplicationMaxAggregateInputType
  }

  export type StaffApplicationGroupByOutputType = {
    id: string
    staffId: string | null
    schoolId: string
    surname: string
    firstName: string
    otherNames: string | null
    dateOfBirth: Date
    nationality: string
    sex: string
    languages: string[]
    maritalStatus: string | null
    religion: string
    denomination: string | null
    hometown: string
    region: string
    profilePicture: string | null
    residentialAddress: string
    postalAddress: string
    mobile: string | null
    email: string | null
    emergencyContact: string
    nextOfKin: string | null
    position: string
    departmentId: string | null
    hireDate: Date | null
    salary: number | null
    qualifications: string | null
    bloodType: string | null
    medicalConditions: string | null
    specialDisability: string | null
    declarationSigned: boolean
    signature: string | null
    submissionDate: Date
    classification: string | null
    submittedBy: string | null
    receivedBy: string | null
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: StaffApplicationCountAggregateOutputType | null
    _avg: StaffApplicationAvgAggregateOutputType | null
    _sum: StaffApplicationSumAggregateOutputType | null
    _min: StaffApplicationMinAggregateOutputType | null
    _max: StaffApplicationMaxAggregateOutputType | null
  }

  type GetStaffApplicationGroupByPayload<T extends StaffApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], StaffApplicationGroupByOutputType[P]>
        }
      >
    >


  export type StaffApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    schoolId?: boolean
    surname?: boolean
    firstName?: boolean
    otherNames?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    sex?: boolean
    languages?: boolean
    maritalStatus?: boolean
    religion?: boolean
    denomination?: boolean
    hometown?: boolean
    region?: boolean
    profilePicture?: boolean
    residentialAddress?: boolean
    postalAddress?: boolean
    mobile?: boolean
    email?: boolean
    emergencyContact?: boolean
    nextOfKin?: boolean
    position?: boolean
    departmentId?: boolean
    hireDate?: boolean
    salary?: boolean
    qualifications?: boolean
    bloodType?: boolean
    medicalConditions?: boolean
    specialDisability?: boolean
    declarationSigned?: boolean
    signature?: boolean
    submissionDate?: boolean
    classification?: boolean
    submittedBy?: boolean
    receivedBy?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffApplication$staffArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    department?: boolean | StaffApplication$departmentArgs<ExtArgs>
    subjects?: boolean | StaffApplication$subjectsArgs<ExtArgs>
    previousJobs?: boolean | StaffApplication$previousJobsArgs<ExtArgs>
    _count?: boolean | StaffApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffApplication"]>

  export type StaffApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    schoolId?: boolean
    surname?: boolean
    firstName?: boolean
    otherNames?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    sex?: boolean
    languages?: boolean
    maritalStatus?: boolean
    religion?: boolean
    denomination?: boolean
    hometown?: boolean
    region?: boolean
    profilePicture?: boolean
    residentialAddress?: boolean
    postalAddress?: boolean
    mobile?: boolean
    email?: boolean
    emergencyContact?: boolean
    nextOfKin?: boolean
    position?: boolean
    departmentId?: boolean
    hireDate?: boolean
    salary?: boolean
    qualifications?: boolean
    bloodType?: boolean
    medicalConditions?: boolean
    specialDisability?: boolean
    declarationSigned?: boolean
    signature?: boolean
    submissionDate?: boolean
    classification?: boolean
    submittedBy?: boolean
    receivedBy?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffApplication$staffArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    department?: boolean | StaffApplication$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["staffApplication"]>

  export type StaffApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    schoolId?: boolean
    surname?: boolean
    firstName?: boolean
    otherNames?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    sex?: boolean
    languages?: boolean
    maritalStatus?: boolean
    religion?: boolean
    denomination?: boolean
    hometown?: boolean
    region?: boolean
    profilePicture?: boolean
    residentialAddress?: boolean
    postalAddress?: boolean
    mobile?: boolean
    email?: boolean
    emergencyContact?: boolean
    nextOfKin?: boolean
    position?: boolean
    departmentId?: boolean
    hireDate?: boolean
    salary?: boolean
    qualifications?: boolean
    bloodType?: boolean
    medicalConditions?: boolean
    specialDisability?: boolean
    declarationSigned?: boolean
    signature?: boolean
    submissionDate?: boolean
    classification?: boolean
    submittedBy?: boolean
    receivedBy?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffApplication$staffArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    department?: boolean | StaffApplication$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["staffApplication"]>

  export type StaffApplicationSelectScalar = {
    id?: boolean
    staffId?: boolean
    schoolId?: boolean
    surname?: boolean
    firstName?: boolean
    otherNames?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    sex?: boolean
    languages?: boolean
    maritalStatus?: boolean
    religion?: boolean
    denomination?: boolean
    hometown?: boolean
    region?: boolean
    profilePicture?: boolean
    residentialAddress?: boolean
    postalAddress?: boolean
    mobile?: boolean
    email?: boolean
    emergencyContact?: boolean
    nextOfKin?: boolean
    position?: boolean
    departmentId?: boolean
    hireDate?: boolean
    salary?: boolean
    qualifications?: boolean
    bloodType?: boolean
    medicalConditions?: boolean
    specialDisability?: boolean
    declarationSigned?: boolean
    signature?: boolean
    submissionDate?: boolean
    classification?: boolean
    submittedBy?: boolean
    receivedBy?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "schoolId" | "surname" | "firstName" | "otherNames" | "dateOfBirth" | "nationality" | "sex" | "languages" | "maritalStatus" | "religion" | "denomination" | "hometown" | "region" | "profilePicture" | "residentialAddress" | "postalAddress" | "mobile" | "email" | "emergencyContact" | "nextOfKin" | "position" | "departmentId" | "hireDate" | "salary" | "qualifications" | "bloodType" | "medicalConditions" | "specialDisability" | "declarationSigned" | "signature" | "submissionDate" | "classification" | "submittedBy" | "receivedBy" | "remarks" | "createdAt" | "updatedAt", ExtArgs["result"]["staffApplication"]>
  export type StaffApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffApplication$staffArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    department?: boolean | StaffApplication$departmentArgs<ExtArgs>
    subjects?: boolean | StaffApplication$subjectsArgs<ExtArgs>
    previousJobs?: boolean | StaffApplication$previousJobsArgs<ExtArgs>
    _count?: boolean | StaffApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffApplication$staffArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    department?: boolean | StaffApplication$departmentArgs<ExtArgs>
  }
  export type StaffApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffApplication$staffArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    department?: boolean | StaffApplication$departmentArgs<ExtArgs>
  }

  export type $StaffApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffApplication"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      previousJobs: Prisma.$PreviousJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string | null
      schoolId: string
      surname: string
      firstName: string
      otherNames: string | null
      dateOfBirth: Date
      nationality: string
      sex: string
      languages: string[]
      maritalStatus: string | null
      religion: string
      denomination: string | null
      hometown: string
      region: string
      profilePicture: string | null
      residentialAddress: string
      postalAddress: string
      mobile: string | null
      email: string | null
      emergencyContact: string
      nextOfKin: string | null
      position: string
      departmentId: string | null
      hireDate: Date | null
      salary: number | null
      qualifications: string | null
      bloodType: string | null
      medicalConditions: string | null
      specialDisability: string | null
      declarationSigned: boolean
      signature: string | null
      submissionDate: Date
      classification: string | null
      submittedBy: string | null
      receivedBy: string | null
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staffApplication"]>
    composites: {}
  }

  type StaffApplicationGetPayload<S extends boolean | null | undefined | StaffApplicationDefaultArgs> = $Result.GetResult<Prisma.$StaffApplicationPayload, S>

  type StaffApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffApplicationCountAggregateInputType | true
    }

  export interface StaffApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffApplication'], meta: { name: 'StaffApplication' } }
    /**
     * Find zero or one StaffApplication that matches the filter.
     * @param {StaffApplicationFindUniqueArgs} args - Arguments to find a StaffApplication
     * @example
     * // Get one StaffApplication
     * const staffApplication = await prisma.staffApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffApplicationFindUniqueArgs>(args: SelectSubset<T, StaffApplicationFindUniqueArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffApplicationFindUniqueOrThrowArgs} args - Arguments to find a StaffApplication
     * @example
     * // Get one StaffApplication
     * const staffApplication = await prisma.staffApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffApplicationFindFirstArgs} args - Arguments to find a StaffApplication
     * @example
     * // Get one StaffApplication
     * const staffApplication = await prisma.staffApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffApplicationFindFirstArgs>(args?: SelectSubset<T, StaffApplicationFindFirstArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffApplicationFindFirstOrThrowArgs} args - Arguments to find a StaffApplication
     * @example
     * // Get one StaffApplication
     * const staffApplication = await prisma.staffApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffApplications
     * const staffApplications = await prisma.staffApplication.findMany()
     * 
     * // Get first 10 StaffApplications
     * const staffApplications = await prisma.staffApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffApplicationWithIdOnly = await prisma.staffApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffApplicationFindManyArgs>(args?: SelectSubset<T, StaffApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffApplication.
     * @param {StaffApplicationCreateArgs} args - Arguments to create a StaffApplication.
     * @example
     * // Create one StaffApplication
     * const StaffApplication = await prisma.staffApplication.create({
     *   data: {
     *     // ... data to create a StaffApplication
     *   }
     * })
     * 
     */
    create<T extends StaffApplicationCreateArgs>(args: SelectSubset<T, StaffApplicationCreateArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffApplications.
     * @param {StaffApplicationCreateManyArgs} args - Arguments to create many StaffApplications.
     * @example
     * // Create many StaffApplications
     * const staffApplication = await prisma.staffApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffApplicationCreateManyArgs>(args?: SelectSubset<T, StaffApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffApplications and returns the data saved in the database.
     * @param {StaffApplicationCreateManyAndReturnArgs} args - Arguments to create many StaffApplications.
     * @example
     * // Create many StaffApplications
     * const staffApplication = await prisma.staffApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffApplications and only return the `id`
     * const staffApplicationWithIdOnly = await prisma.staffApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffApplication.
     * @param {StaffApplicationDeleteArgs} args - Arguments to delete one StaffApplication.
     * @example
     * // Delete one StaffApplication
     * const StaffApplication = await prisma.staffApplication.delete({
     *   where: {
     *     // ... filter to delete one StaffApplication
     *   }
     * })
     * 
     */
    delete<T extends StaffApplicationDeleteArgs>(args: SelectSubset<T, StaffApplicationDeleteArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffApplication.
     * @param {StaffApplicationUpdateArgs} args - Arguments to update one StaffApplication.
     * @example
     * // Update one StaffApplication
     * const staffApplication = await prisma.staffApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffApplicationUpdateArgs>(args: SelectSubset<T, StaffApplicationUpdateArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffApplications.
     * @param {StaffApplicationDeleteManyArgs} args - Arguments to filter StaffApplications to delete.
     * @example
     * // Delete a few StaffApplications
     * const { count } = await prisma.staffApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffApplicationDeleteManyArgs>(args?: SelectSubset<T, StaffApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffApplications
     * const staffApplication = await prisma.staffApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffApplicationUpdateManyArgs>(args: SelectSubset<T, StaffApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffApplications and returns the data updated in the database.
     * @param {StaffApplicationUpdateManyAndReturnArgs} args - Arguments to update many StaffApplications.
     * @example
     * // Update many StaffApplications
     * const staffApplication = await prisma.staffApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffApplications and only return the `id`
     * const staffApplicationWithIdOnly = await prisma.staffApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffApplication.
     * @param {StaffApplicationUpsertArgs} args - Arguments to update or create a StaffApplication.
     * @example
     * // Update or create a StaffApplication
     * const staffApplication = await prisma.staffApplication.upsert({
     *   create: {
     *     // ... data to create a StaffApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffApplication we want to update
     *   }
     * })
     */
    upsert<T extends StaffApplicationUpsertArgs>(args: SelectSubset<T, StaffApplicationUpsertArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffApplicationCountArgs} args - Arguments to filter StaffApplications to count.
     * @example
     * // Count the number of StaffApplications
     * const count = await prisma.staffApplication.count({
     *   where: {
     *     // ... the filter for the StaffApplications we want to count
     *   }
     * })
    **/
    count<T extends StaffApplicationCountArgs>(
      args?: Subset<T, StaffApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffApplicationAggregateArgs>(args: Subset<T, StaffApplicationAggregateArgs>): Prisma.PrismaPromise<GetStaffApplicationAggregateType<T>>

    /**
     * Group by StaffApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffApplicationGroupByArgs['orderBy'] }
        : { orderBy?: StaffApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffApplication model
   */
  readonly fields: StaffApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends StaffApplication$staffArgs<ExtArgs> = {}>(args?: Subset<T, StaffApplication$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends StaffApplication$departmentArgs<ExtArgs> = {}>(args?: Subset<T, StaffApplication$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends StaffApplication$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, StaffApplication$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    previousJobs<T extends StaffApplication$previousJobsArgs<ExtArgs> = {}>(args?: Subset<T, StaffApplication$previousJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffApplication model
   */
  interface StaffApplicationFieldRefs {
    readonly id: FieldRef<"StaffApplication", 'String'>
    readonly staffId: FieldRef<"StaffApplication", 'String'>
    readonly schoolId: FieldRef<"StaffApplication", 'String'>
    readonly surname: FieldRef<"StaffApplication", 'String'>
    readonly firstName: FieldRef<"StaffApplication", 'String'>
    readonly otherNames: FieldRef<"StaffApplication", 'String'>
    readonly dateOfBirth: FieldRef<"StaffApplication", 'DateTime'>
    readonly nationality: FieldRef<"StaffApplication", 'String'>
    readonly sex: FieldRef<"StaffApplication", 'String'>
    readonly languages: FieldRef<"StaffApplication", 'String[]'>
    readonly maritalStatus: FieldRef<"StaffApplication", 'String'>
    readonly religion: FieldRef<"StaffApplication", 'String'>
    readonly denomination: FieldRef<"StaffApplication", 'String'>
    readonly hometown: FieldRef<"StaffApplication", 'String'>
    readonly region: FieldRef<"StaffApplication", 'String'>
    readonly profilePicture: FieldRef<"StaffApplication", 'String'>
    readonly residentialAddress: FieldRef<"StaffApplication", 'String'>
    readonly postalAddress: FieldRef<"StaffApplication", 'String'>
    readonly mobile: FieldRef<"StaffApplication", 'String'>
    readonly email: FieldRef<"StaffApplication", 'String'>
    readonly emergencyContact: FieldRef<"StaffApplication", 'String'>
    readonly nextOfKin: FieldRef<"StaffApplication", 'String'>
    readonly position: FieldRef<"StaffApplication", 'String'>
    readonly departmentId: FieldRef<"StaffApplication", 'String'>
    readonly hireDate: FieldRef<"StaffApplication", 'DateTime'>
    readonly salary: FieldRef<"StaffApplication", 'Float'>
    readonly qualifications: FieldRef<"StaffApplication", 'String'>
    readonly bloodType: FieldRef<"StaffApplication", 'String'>
    readonly medicalConditions: FieldRef<"StaffApplication", 'String'>
    readonly specialDisability: FieldRef<"StaffApplication", 'String'>
    readonly declarationSigned: FieldRef<"StaffApplication", 'Boolean'>
    readonly signature: FieldRef<"StaffApplication", 'String'>
    readonly submissionDate: FieldRef<"StaffApplication", 'DateTime'>
    readonly classification: FieldRef<"StaffApplication", 'String'>
    readonly submittedBy: FieldRef<"StaffApplication", 'String'>
    readonly receivedBy: FieldRef<"StaffApplication", 'String'>
    readonly remarks: FieldRef<"StaffApplication", 'String'>
    readonly createdAt: FieldRef<"StaffApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffApplication findUnique
   */
  export type StaffApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * Filter, which StaffApplication to fetch.
     */
    where: StaffApplicationWhereUniqueInput
  }

  /**
   * StaffApplication findUniqueOrThrow
   */
  export type StaffApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * Filter, which StaffApplication to fetch.
     */
    where: StaffApplicationWhereUniqueInput
  }

  /**
   * StaffApplication findFirst
   */
  export type StaffApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * Filter, which StaffApplication to fetch.
     */
    where?: StaffApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffApplications to fetch.
     */
    orderBy?: StaffApplicationOrderByWithRelationInput | StaffApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffApplications.
     */
    cursor?: StaffApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffApplications.
     */
    distinct?: StaffApplicationScalarFieldEnum | StaffApplicationScalarFieldEnum[]
  }

  /**
   * StaffApplication findFirstOrThrow
   */
  export type StaffApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * Filter, which StaffApplication to fetch.
     */
    where?: StaffApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffApplications to fetch.
     */
    orderBy?: StaffApplicationOrderByWithRelationInput | StaffApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffApplications.
     */
    cursor?: StaffApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffApplications.
     */
    distinct?: StaffApplicationScalarFieldEnum | StaffApplicationScalarFieldEnum[]
  }

  /**
   * StaffApplication findMany
   */
  export type StaffApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * Filter, which StaffApplications to fetch.
     */
    where?: StaffApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffApplications to fetch.
     */
    orderBy?: StaffApplicationOrderByWithRelationInput | StaffApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffApplications.
     */
    cursor?: StaffApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffApplications.
     */
    skip?: number
    distinct?: StaffApplicationScalarFieldEnum | StaffApplicationScalarFieldEnum[]
  }

  /**
   * StaffApplication create
   */
  export type StaffApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffApplication.
     */
    data: XOR<StaffApplicationCreateInput, StaffApplicationUncheckedCreateInput>
  }

  /**
   * StaffApplication createMany
   */
  export type StaffApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffApplications.
     */
    data: StaffApplicationCreateManyInput | StaffApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffApplication createManyAndReturn
   */
  export type StaffApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many StaffApplications.
     */
    data: StaffApplicationCreateManyInput | StaffApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffApplication update
   */
  export type StaffApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffApplication.
     */
    data: XOR<StaffApplicationUpdateInput, StaffApplicationUncheckedUpdateInput>
    /**
     * Choose, which StaffApplication to update.
     */
    where: StaffApplicationWhereUniqueInput
  }

  /**
   * StaffApplication updateMany
   */
  export type StaffApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffApplications.
     */
    data: XOR<StaffApplicationUpdateManyMutationInput, StaffApplicationUncheckedUpdateManyInput>
    /**
     * Filter which StaffApplications to update
     */
    where?: StaffApplicationWhereInput
    /**
     * Limit how many StaffApplications to update.
     */
    limit?: number
  }

  /**
   * StaffApplication updateManyAndReturn
   */
  export type StaffApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * The data used to update StaffApplications.
     */
    data: XOR<StaffApplicationUpdateManyMutationInput, StaffApplicationUncheckedUpdateManyInput>
    /**
     * Filter which StaffApplications to update
     */
    where?: StaffApplicationWhereInput
    /**
     * Limit how many StaffApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffApplication upsert
   */
  export type StaffApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffApplication to update in case it exists.
     */
    where: StaffApplicationWhereUniqueInput
    /**
     * In case the StaffApplication found by the `where` argument doesn't exist, create a new StaffApplication with this data.
     */
    create: XOR<StaffApplicationCreateInput, StaffApplicationUncheckedCreateInput>
    /**
     * In case the StaffApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffApplicationUpdateInput, StaffApplicationUncheckedUpdateInput>
  }

  /**
   * StaffApplication delete
   */
  export type StaffApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    /**
     * Filter which StaffApplication to delete.
     */
    where: StaffApplicationWhereUniqueInput
  }

  /**
   * StaffApplication deleteMany
   */
  export type StaffApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffApplications to delete
     */
    where?: StaffApplicationWhereInput
    /**
     * Limit how many StaffApplications to delete.
     */
    limit?: number
  }

  /**
   * StaffApplication.staff
   */
  export type StaffApplication$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * StaffApplication.department
   */
  export type StaffApplication$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * StaffApplication.subjects
   */
  export type StaffApplication$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * StaffApplication.previousJobs
   */
  export type StaffApplication$previousJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    where?: PreviousJobWhereInput
    orderBy?: PreviousJobOrderByWithRelationInput | PreviousJobOrderByWithRelationInput[]
    cursor?: PreviousJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreviousJobScalarFieldEnum | PreviousJobScalarFieldEnum[]
  }

  /**
   * StaffApplication without action
   */
  export type StaffApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
  }


  /**
   * Model PreviousJob
   */

  export type AggregatePreviousJob = {
    _count: PreviousJobCountAggregateOutputType | null
    _min: PreviousJobMinAggregateOutputType | null
    _max: PreviousJobMaxAggregateOutputType | null
  }

  export type PreviousJobMinAggregateOutputType = {
    id: string | null
    staffApplicationId: string | null
    company: string | null
    role: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreviousJobMaxAggregateOutputType = {
    id: string | null
    staffApplicationId: string | null
    company: string | null
    role: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreviousJobCountAggregateOutputType = {
    id: number
    staffApplicationId: number
    company: number
    role: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PreviousJobMinAggregateInputType = {
    id?: true
    staffApplicationId?: true
    company?: true
    role?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreviousJobMaxAggregateInputType = {
    id?: true
    staffApplicationId?: true
    company?: true
    role?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreviousJobCountAggregateInputType = {
    id?: true
    staffApplicationId?: true
    company?: true
    role?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PreviousJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreviousJob to aggregate.
     */
    where?: PreviousJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreviousJobs to fetch.
     */
    orderBy?: PreviousJobOrderByWithRelationInput | PreviousJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreviousJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreviousJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreviousJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreviousJobs
    **/
    _count?: true | PreviousJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreviousJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreviousJobMaxAggregateInputType
  }

  export type GetPreviousJobAggregateType<T extends PreviousJobAggregateArgs> = {
        [P in keyof T & keyof AggregatePreviousJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreviousJob[P]>
      : GetScalarType<T[P], AggregatePreviousJob[P]>
  }




  export type PreviousJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreviousJobWhereInput
    orderBy?: PreviousJobOrderByWithAggregationInput | PreviousJobOrderByWithAggregationInput[]
    by: PreviousJobScalarFieldEnum[] | PreviousJobScalarFieldEnum
    having?: PreviousJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreviousJobCountAggregateInputType | true
    _min?: PreviousJobMinAggregateInputType
    _max?: PreviousJobMaxAggregateInputType
  }

  export type PreviousJobGroupByOutputType = {
    id: string
    staffApplicationId: string
    company: string
    role: string
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PreviousJobCountAggregateOutputType | null
    _min: PreviousJobMinAggregateOutputType | null
    _max: PreviousJobMaxAggregateOutputType | null
  }

  type GetPreviousJobGroupByPayload<T extends PreviousJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreviousJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreviousJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreviousJobGroupByOutputType[P]>
            : GetScalarType<T[P], PreviousJobGroupByOutputType[P]>
        }
      >
    >


  export type PreviousJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffApplicationId?: boolean
    company?: boolean
    role?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staffApplication?: boolean | StaffApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["previousJob"]>

  export type PreviousJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffApplicationId?: boolean
    company?: boolean
    role?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staffApplication?: boolean | StaffApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["previousJob"]>

  export type PreviousJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffApplicationId?: boolean
    company?: boolean
    role?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staffApplication?: boolean | StaffApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["previousJob"]>

  export type PreviousJobSelectScalar = {
    id?: boolean
    staffApplicationId?: boolean
    company?: boolean
    role?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PreviousJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffApplicationId" | "company" | "role" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["previousJob"]>
  export type PreviousJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffApplication?: boolean | StaffApplicationDefaultArgs<ExtArgs>
  }
  export type PreviousJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffApplication?: boolean | StaffApplicationDefaultArgs<ExtArgs>
  }
  export type PreviousJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffApplication?: boolean | StaffApplicationDefaultArgs<ExtArgs>
  }

  export type $PreviousJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreviousJob"
    objects: {
      staffApplication: Prisma.$StaffApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffApplicationId: string
      company: string
      role: string
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["previousJob"]>
    composites: {}
  }

  type PreviousJobGetPayload<S extends boolean | null | undefined | PreviousJobDefaultArgs> = $Result.GetResult<Prisma.$PreviousJobPayload, S>

  type PreviousJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreviousJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreviousJobCountAggregateInputType | true
    }

  export interface PreviousJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreviousJob'], meta: { name: 'PreviousJob' } }
    /**
     * Find zero or one PreviousJob that matches the filter.
     * @param {PreviousJobFindUniqueArgs} args - Arguments to find a PreviousJob
     * @example
     * // Get one PreviousJob
     * const previousJob = await prisma.previousJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreviousJobFindUniqueArgs>(args: SelectSubset<T, PreviousJobFindUniqueArgs<ExtArgs>>): Prisma__PreviousJobClient<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreviousJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreviousJobFindUniqueOrThrowArgs} args - Arguments to find a PreviousJob
     * @example
     * // Get one PreviousJob
     * const previousJob = await prisma.previousJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreviousJobFindUniqueOrThrowArgs>(args: SelectSubset<T, PreviousJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreviousJobClient<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreviousJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousJobFindFirstArgs} args - Arguments to find a PreviousJob
     * @example
     * // Get one PreviousJob
     * const previousJob = await prisma.previousJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreviousJobFindFirstArgs>(args?: SelectSubset<T, PreviousJobFindFirstArgs<ExtArgs>>): Prisma__PreviousJobClient<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreviousJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousJobFindFirstOrThrowArgs} args - Arguments to find a PreviousJob
     * @example
     * // Get one PreviousJob
     * const previousJob = await prisma.previousJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreviousJobFindFirstOrThrowArgs>(args?: SelectSubset<T, PreviousJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreviousJobClient<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreviousJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreviousJobs
     * const previousJobs = await prisma.previousJob.findMany()
     * 
     * // Get first 10 PreviousJobs
     * const previousJobs = await prisma.previousJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const previousJobWithIdOnly = await prisma.previousJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreviousJobFindManyArgs>(args?: SelectSubset<T, PreviousJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreviousJob.
     * @param {PreviousJobCreateArgs} args - Arguments to create a PreviousJob.
     * @example
     * // Create one PreviousJob
     * const PreviousJob = await prisma.previousJob.create({
     *   data: {
     *     // ... data to create a PreviousJob
     *   }
     * })
     * 
     */
    create<T extends PreviousJobCreateArgs>(args: SelectSubset<T, PreviousJobCreateArgs<ExtArgs>>): Prisma__PreviousJobClient<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreviousJobs.
     * @param {PreviousJobCreateManyArgs} args - Arguments to create many PreviousJobs.
     * @example
     * // Create many PreviousJobs
     * const previousJob = await prisma.previousJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreviousJobCreateManyArgs>(args?: SelectSubset<T, PreviousJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreviousJobs and returns the data saved in the database.
     * @param {PreviousJobCreateManyAndReturnArgs} args - Arguments to create many PreviousJobs.
     * @example
     * // Create many PreviousJobs
     * const previousJob = await prisma.previousJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreviousJobs and only return the `id`
     * const previousJobWithIdOnly = await prisma.previousJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreviousJobCreateManyAndReturnArgs>(args?: SelectSubset<T, PreviousJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreviousJob.
     * @param {PreviousJobDeleteArgs} args - Arguments to delete one PreviousJob.
     * @example
     * // Delete one PreviousJob
     * const PreviousJob = await prisma.previousJob.delete({
     *   where: {
     *     // ... filter to delete one PreviousJob
     *   }
     * })
     * 
     */
    delete<T extends PreviousJobDeleteArgs>(args: SelectSubset<T, PreviousJobDeleteArgs<ExtArgs>>): Prisma__PreviousJobClient<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreviousJob.
     * @param {PreviousJobUpdateArgs} args - Arguments to update one PreviousJob.
     * @example
     * // Update one PreviousJob
     * const previousJob = await prisma.previousJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreviousJobUpdateArgs>(args: SelectSubset<T, PreviousJobUpdateArgs<ExtArgs>>): Prisma__PreviousJobClient<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreviousJobs.
     * @param {PreviousJobDeleteManyArgs} args - Arguments to filter PreviousJobs to delete.
     * @example
     * // Delete a few PreviousJobs
     * const { count } = await prisma.previousJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreviousJobDeleteManyArgs>(args?: SelectSubset<T, PreviousJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreviousJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreviousJobs
     * const previousJob = await prisma.previousJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreviousJobUpdateManyArgs>(args: SelectSubset<T, PreviousJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreviousJobs and returns the data updated in the database.
     * @param {PreviousJobUpdateManyAndReturnArgs} args - Arguments to update many PreviousJobs.
     * @example
     * // Update many PreviousJobs
     * const previousJob = await prisma.previousJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreviousJobs and only return the `id`
     * const previousJobWithIdOnly = await prisma.previousJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PreviousJobUpdateManyAndReturnArgs>(args: SelectSubset<T, PreviousJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreviousJob.
     * @param {PreviousJobUpsertArgs} args - Arguments to update or create a PreviousJob.
     * @example
     * // Update or create a PreviousJob
     * const previousJob = await prisma.previousJob.upsert({
     *   create: {
     *     // ... data to create a PreviousJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreviousJob we want to update
     *   }
     * })
     */
    upsert<T extends PreviousJobUpsertArgs>(args: SelectSubset<T, PreviousJobUpsertArgs<ExtArgs>>): Prisma__PreviousJobClient<$Result.GetResult<Prisma.$PreviousJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreviousJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousJobCountArgs} args - Arguments to filter PreviousJobs to count.
     * @example
     * // Count the number of PreviousJobs
     * const count = await prisma.previousJob.count({
     *   where: {
     *     // ... the filter for the PreviousJobs we want to count
     *   }
     * })
    **/
    count<T extends PreviousJobCountArgs>(
      args?: Subset<T, PreviousJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreviousJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreviousJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreviousJobAggregateArgs>(args: Subset<T, PreviousJobAggregateArgs>): Prisma.PrismaPromise<GetPreviousJobAggregateType<T>>

    /**
     * Group by PreviousJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreviousJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreviousJobGroupByArgs['orderBy'] }
        : { orderBy?: PreviousJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreviousJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreviousJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreviousJob model
   */
  readonly fields: PreviousJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreviousJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreviousJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staffApplication<T extends StaffApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffApplicationDefaultArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PreviousJob model
   */
  interface PreviousJobFieldRefs {
    readonly id: FieldRef<"PreviousJob", 'String'>
    readonly staffApplicationId: FieldRef<"PreviousJob", 'String'>
    readonly company: FieldRef<"PreviousJob", 'String'>
    readonly role: FieldRef<"PreviousJob", 'String'>
    readonly startDate: FieldRef<"PreviousJob", 'DateTime'>
    readonly endDate: FieldRef<"PreviousJob", 'DateTime'>
    readonly createdAt: FieldRef<"PreviousJob", 'DateTime'>
    readonly updatedAt: FieldRef<"PreviousJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PreviousJob findUnique
   */
  export type PreviousJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * Filter, which PreviousJob to fetch.
     */
    where: PreviousJobWhereUniqueInput
  }

  /**
   * PreviousJob findUniqueOrThrow
   */
  export type PreviousJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * Filter, which PreviousJob to fetch.
     */
    where: PreviousJobWhereUniqueInput
  }

  /**
   * PreviousJob findFirst
   */
  export type PreviousJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * Filter, which PreviousJob to fetch.
     */
    where?: PreviousJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreviousJobs to fetch.
     */
    orderBy?: PreviousJobOrderByWithRelationInput | PreviousJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreviousJobs.
     */
    cursor?: PreviousJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreviousJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreviousJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreviousJobs.
     */
    distinct?: PreviousJobScalarFieldEnum | PreviousJobScalarFieldEnum[]
  }

  /**
   * PreviousJob findFirstOrThrow
   */
  export type PreviousJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * Filter, which PreviousJob to fetch.
     */
    where?: PreviousJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreviousJobs to fetch.
     */
    orderBy?: PreviousJobOrderByWithRelationInput | PreviousJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreviousJobs.
     */
    cursor?: PreviousJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreviousJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreviousJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreviousJobs.
     */
    distinct?: PreviousJobScalarFieldEnum | PreviousJobScalarFieldEnum[]
  }

  /**
   * PreviousJob findMany
   */
  export type PreviousJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * Filter, which PreviousJobs to fetch.
     */
    where?: PreviousJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreviousJobs to fetch.
     */
    orderBy?: PreviousJobOrderByWithRelationInput | PreviousJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreviousJobs.
     */
    cursor?: PreviousJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreviousJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreviousJobs.
     */
    skip?: number
    distinct?: PreviousJobScalarFieldEnum | PreviousJobScalarFieldEnum[]
  }

  /**
   * PreviousJob create
   */
  export type PreviousJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * The data needed to create a PreviousJob.
     */
    data: XOR<PreviousJobCreateInput, PreviousJobUncheckedCreateInput>
  }

  /**
   * PreviousJob createMany
   */
  export type PreviousJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreviousJobs.
     */
    data: PreviousJobCreateManyInput | PreviousJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PreviousJob createManyAndReturn
   */
  export type PreviousJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * The data used to create many PreviousJobs.
     */
    data: PreviousJobCreateManyInput | PreviousJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreviousJob update
   */
  export type PreviousJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * The data needed to update a PreviousJob.
     */
    data: XOR<PreviousJobUpdateInput, PreviousJobUncheckedUpdateInput>
    /**
     * Choose, which PreviousJob to update.
     */
    where: PreviousJobWhereUniqueInput
  }

  /**
   * PreviousJob updateMany
   */
  export type PreviousJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreviousJobs.
     */
    data: XOR<PreviousJobUpdateManyMutationInput, PreviousJobUncheckedUpdateManyInput>
    /**
     * Filter which PreviousJobs to update
     */
    where?: PreviousJobWhereInput
    /**
     * Limit how many PreviousJobs to update.
     */
    limit?: number
  }

  /**
   * PreviousJob updateManyAndReturn
   */
  export type PreviousJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * The data used to update PreviousJobs.
     */
    data: XOR<PreviousJobUpdateManyMutationInput, PreviousJobUncheckedUpdateManyInput>
    /**
     * Filter which PreviousJobs to update
     */
    where?: PreviousJobWhereInput
    /**
     * Limit how many PreviousJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreviousJob upsert
   */
  export type PreviousJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * The filter to search for the PreviousJob to update in case it exists.
     */
    where: PreviousJobWhereUniqueInput
    /**
     * In case the PreviousJob found by the `where` argument doesn't exist, create a new PreviousJob with this data.
     */
    create: XOR<PreviousJobCreateInput, PreviousJobUncheckedCreateInput>
    /**
     * In case the PreviousJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreviousJobUpdateInput, PreviousJobUncheckedUpdateInput>
  }

  /**
   * PreviousJob delete
   */
  export type PreviousJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
    /**
     * Filter which PreviousJob to delete.
     */
    where: PreviousJobWhereUniqueInput
  }

  /**
   * PreviousJob deleteMany
   */
  export type PreviousJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreviousJobs to delete
     */
    where?: PreviousJobWhereInput
    /**
     * Limit how many PreviousJobs to delete.
     */
    limit?: number
  }

  /**
   * PreviousJob without action
   */
  export type PreviousJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreviousJob
     */
    select?: PreviousJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreviousJob
     */
    omit?: PreviousJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreviousJobInclude<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffAvgAggregateOutputType = {
    salary: number | null
  }

  export type StaffSumAggregateOutputType = {
    salary: number | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    userId: string | null
    classId: string | null
    position: string | null
    salary: number | null
    hireDate: Date | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    classId: string | null
    position: string | null
    salary: number | null
    hireDate: Date | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    userId: number
    classId: number
    position: number
    salary: number
    hireDate: number
    departmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffAvgAggregateInputType = {
    salary?: true
  }

  export type StaffSumAggregateInputType = {
    salary?: true
  }

  export type StaffMinAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    position?: true
    salary?: true
    hireDate?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    position?: true
    salary?: true
    hireDate?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    position?: true
    salary?: true
    hireDate?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _avg?: StaffAvgAggregateInputType
    _sum?: StaffSumAggregateInputType
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    userId: string
    classId: string | null
    position: string | null
    salary: number | null
    hireDate: Date | null
    departmentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    position?: boolean
    salary?: boolean
    hireDate?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Staff$classArgs<ExtArgs>
    grades?: boolean | Staff$gradesArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    subjects?: boolean | Staff$subjectsArgs<ExtArgs>
    attendances?: boolean | Staff$attendancesArgs<ExtArgs>
    StaffApplication?: boolean | Staff$StaffApplicationArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    position?: boolean
    salary?: boolean
    hireDate?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Staff$classArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    position?: boolean
    salary?: boolean
    hireDate?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Staff$classArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    userId?: boolean
    classId?: boolean
    position?: boolean
    salary?: boolean
    hireDate?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "classId" | "position" | "salary" | "hireDate" | "departmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["staff"]>
  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Staff$classArgs<ExtArgs>
    grades?: boolean | Staff$gradesArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    subjects?: boolean | Staff$subjectsArgs<ExtArgs>
    attendances?: boolean | Staff$attendancesArgs<ExtArgs>
    StaffApplication?: boolean | Staff$StaffApplicationArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Staff$classArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
  }
  export type StaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Staff$classArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
  }

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs> | null
      grades: Prisma.$GradePayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      attendances: Prisma.$StaffAttendancePayload<ExtArgs>[]
      StaffApplication: Prisma.$StaffApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      classId: string | null
      position: string | null
      salary: number | null
      hireDate: Date | null
      departmentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends Staff$classArgs<ExtArgs> = {}>(args?: Subset<T, Staff$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    grades<T extends Staff$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Staff$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends Staff$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Staff$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends Staff$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Staff$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Staff$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StaffApplication<T extends Staff$StaffApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Staff$StaffApplicationArgs<ExtArgs>>): Prisma__StaffApplicationClient<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'String'>
    readonly userId: FieldRef<"Staff", 'String'>
    readonly classId: FieldRef<"Staff", 'String'>
    readonly position: FieldRef<"Staff", 'String'>
    readonly salary: FieldRef<"Staff", 'Float'>
    readonly hireDate: FieldRef<"Staff", 'DateTime'>
    readonly departmentId: FieldRef<"Staff", 'String'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to delete.
     */
    limit?: number
  }

  /**
   * Staff.class
   */
  export type Staff$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Staff.grades
   */
  export type Staff$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Staff.department
   */
  export type Staff$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Staff.subjects
   */
  export type Staff$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Staff.attendances
   */
  export type Staff$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    where?: StaffAttendanceWhereInput
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    cursor?: StaffAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffAttendanceScalarFieldEnum | StaffAttendanceScalarFieldEnum[]
  }

  /**
   * Staff.StaffApplication
   */
  export type Staff$StaffApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    where?: StaffApplicationWhereInput
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    staff?: boolean | Department$staffArgs<ExtArgs>
    LibraryStaff?: boolean | Department$LibraryStaffArgs<ExtArgs>
    StaffApplication?: boolean | Department$StaffApplicationArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | Department$staffArgs<ExtArgs>
    LibraryStaff?: boolean | Department$LibraryStaffArgs<ExtArgs>
    StaffApplication?: boolean | Department$StaffApplicationArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs>[]
      LibraryStaff: Prisma.$LibraryStaffPayload<ExtArgs>[]
      StaffApplication: Prisma.$StaffApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends Department$staffArgs<ExtArgs> = {}>(args?: Subset<T, Department$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LibraryStaff<T extends Department$LibraryStaffArgs<ExtArgs> = {}>(args?: Subset<T, Department$LibraryStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StaffApplication<T extends Department$StaffApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Department$StaffApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.staff
   */
  export type Department$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Department.LibraryStaff
   */
  export type Department$LibraryStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    where?: LibraryStaffWhereInput
    orderBy?: LibraryStaffOrderByWithRelationInput | LibraryStaffOrderByWithRelationInput[]
    cursor?: LibraryStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryStaffScalarFieldEnum | LibraryStaffScalarFieldEnum[]
  }

  /**
   * Department.StaffApplication
   */
  export type Department$StaffApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffApplication
     */
    select?: StaffApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffApplication
     */
    omit?: StaffApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffApplicationInclude<ExtArgs> | null
    where?: StaffApplicationWhereInput
    orderBy?: StaffApplicationOrderByWithRelationInput | StaffApplicationOrderByWithRelationInput[]
    cursor?: StaffApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffApplicationScalarFieldEnum | StaffApplicationScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model StudentAttendance
   */

  export type AggregateStudentAttendance = {
    _count: StudentAttendanceCountAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  export type StudentAttendanceMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    timeIn: Date | null
    timeOut: Date | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAttendanceMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    timeIn: Date | null
    timeOut: Date | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAttendanceCountAggregateOutputType = {
    id: number
    studentId: number
    classId: number
    date: number
    status: number
    timeIn: number
    timeOut: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAttendanceMinAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    date?: true
    status?: true
    timeIn?: true
    timeOut?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAttendanceMaxAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    date?: true
    status?: true
    timeIn?: true
    timeOut?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAttendanceCountAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    date?: true
    status?: true
    timeIn?: true
    timeOut?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendance to aggregate.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAttendances
    **/
    _count?: true | StudentAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type GetStudentAttendanceAggregateType<T extends StudentAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAttendance[P]>
      : GetScalarType<T[P], AggregateStudentAttendance[P]>
  }




  export type StudentAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithAggregationInput | StudentAttendanceOrderByWithAggregationInput[]
    by: StudentAttendanceScalarFieldEnum[] | StudentAttendanceScalarFieldEnum
    having?: StudentAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAttendanceCountAggregateInputType | true
    _min?: StudentAttendanceMinAggregateInputType
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type StudentAttendanceGroupByOutputType = {
    id: string
    studentId: string
    classId: string
    date: Date
    status: $Enums.AttendanceStatus
    timeIn: Date | null
    timeOut: Date | null
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentAttendanceCountAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  type GetStudentAttendanceGroupByPayload<T extends StudentAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type StudentAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    date?: boolean
    status?: boolean
    timeIn?: boolean
    timeOut?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    date?: boolean
    status?: boolean
    timeIn?: boolean
    timeOut?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    date?: boolean
    status?: boolean
    timeIn?: boolean
    timeOut?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectScalar = {
    id?: boolean
    studentId?: boolean
    classId?: boolean
    date?: boolean
    status?: boolean
    timeIn?: boolean
    timeOut?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "classId" | "date" | "status" | "timeIn" | "timeOut" | "remarks" | "createdAt" | "updatedAt", ExtArgs["result"]["studentAttendance"]>
  export type StudentAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAttendance"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classId: string
      date: Date
      status: $Enums.AttendanceStatus
      timeIn: Date | null
      timeOut: Date | null
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentAttendance"]>
    composites: {}
  }

  type StudentAttendanceGetPayload<S extends boolean | null | undefined | StudentAttendanceDefaultArgs> = $Result.GetResult<Prisma.$StudentAttendancePayload, S>

  type StudentAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentAttendanceCountAggregateInputType | true
    }

  export interface StudentAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAttendance'], meta: { name: 'StudentAttendance' } }
    /**
     * Find zero or one StudentAttendance that matches the filter.
     * @param {StudentAttendanceFindUniqueArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAttendanceFindUniqueArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentAttendanceFindUniqueOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAttendanceFindFirstArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany()
     * 
     * // Get first 10 StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAttendanceFindManyArgs>(args?: SelectSubset<T, StudentAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentAttendance.
     * @param {StudentAttendanceCreateArgs} args - Arguments to create a StudentAttendance.
     * @example
     * // Create one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.create({
     *   data: {
     *     // ... data to create a StudentAttendance
     *   }
     * })
     * 
     */
    create<T extends StudentAttendanceCreateArgs>(args: SelectSubset<T, StudentAttendanceCreateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentAttendances.
     * @param {StudentAttendanceCreateManyArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAttendanceCreateManyArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentAttendances and returns the data saved in the database.
     * @param {StudentAttendanceCreateManyAndReturnArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentAttendances and only return the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentAttendance.
     * @param {StudentAttendanceDeleteArgs} args - Arguments to delete one StudentAttendance.
     * @example
     * // Delete one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.delete({
     *   where: {
     *     // ... filter to delete one StudentAttendance
     *   }
     * })
     * 
     */
    delete<T extends StudentAttendanceDeleteArgs>(args: SelectSubset<T, StudentAttendanceDeleteArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentAttendance.
     * @param {StudentAttendanceUpdateArgs} args - Arguments to update one StudentAttendance.
     * @example
     * // Update one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAttendanceUpdateArgs>(args: SelectSubset<T, StudentAttendanceUpdateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentAttendances.
     * @param {StudentAttendanceDeleteManyArgs} args - Arguments to filter StudentAttendances to delete.
     * @example
     * // Delete a few StudentAttendances
     * const { count } = await prisma.studentAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAttendanceDeleteManyArgs>(args?: SelectSubset<T, StudentAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAttendanceUpdateManyArgs>(args: SelectSubset<T, StudentAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAttendances and returns the data updated in the database.
     * @param {StudentAttendanceUpdateManyAndReturnArgs} args - Arguments to update many StudentAttendances.
     * @example
     * // Update many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentAttendances and only return the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentAttendance.
     * @param {StudentAttendanceUpsertArgs} args - Arguments to update or create a StudentAttendance.
     * @example
     * // Update or create a StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.upsert({
     *   create: {
     *     // ... data to create a StudentAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAttendance we want to update
     *   }
     * })
     */
    upsert<T extends StudentAttendanceUpsertArgs>(args: SelectSubset<T, StudentAttendanceUpsertArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceCountArgs} args - Arguments to filter StudentAttendances to count.
     * @example
     * // Count the number of StudentAttendances
     * const count = await prisma.studentAttendance.count({
     *   where: {
     *     // ... the filter for the StudentAttendances we want to count
     *   }
     * })
    **/
    count<T extends StudentAttendanceCountArgs>(
      args?: Subset<T, StudentAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAttendanceAggregateArgs>(args: Subset<T, StudentAttendanceAggregateArgs>): Prisma.PrismaPromise<GetStudentAttendanceAggregateType<T>>

    /**
     * Group by StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: StudentAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAttendance model
   */
  readonly fields: StudentAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAttendance model
   */
  interface StudentAttendanceFieldRefs {
    readonly id: FieldRef<"StudentAttendance", 'String'>
    readonly studentId: FieldRef<"StudentAttendance", 'String'>
    readonly classId: FieldRef<"StudentAttendance", 'String'>
    readonly date: FieldRef<"StudentAttendance", 'DateTime'>
    readonly status: FieldRef<"StudentAttendance", 'AttendanceStatus'>
    readonly timeIn: FieldRef<"StudentAttendance", 'DateTime'>
    readonly timeOut: FieldRef<"StudentAttendance", 'DateTime'>
    readonly remarks: FieldRef<"StudentAttendance", 'String'>
    readonly createdAt: FieldRef<"StudentAttendance", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentAttendance findUnique
   */
  export type StudentAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findUniqueOrThrow
   */
  export type StudentAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findFirst
   */
  export type StudentAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findFirstOrThrow
   */
  export type StudentAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findMany
   */
  export type StudentAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendances to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance create
   */
  export type StudentAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAttendance.
     */
    data: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
  }

  /**
   * StudentAttendance createMany
   */
  export type StudentAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAttendance createManyAndReturn
   */
  export type StudentAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAttendance update
   */
  export type StudentAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAttendance.
     */
    data: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
    /**
     * Choose, which StudentAttendance to update.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance updateMany
   */
  export type StudentAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAttendances.
     */
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StudentAttendances to update
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to update.
     */
    limit?: number
  }

  /**
   * StudentAttendance updateManyAndReturn
   */
  export type StudentAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update StudentAttendances.
     */
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StudentAttendances to update
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAttendance upsert
   */
  export type StudentAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAttendance to update in case it exists.
     */
    where: StudentAttendanceWhereUniqueInput
    /**
     * In case the StudentAttendance found by the `where` argument doesn't exist, create a new StudentAttendance with this data.
     */
    create: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
    /**
     * In case the StudentAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
  }

  /**
   * StudentAttendance delete
   */
  export type StudentAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter which StudentAttendance to delete.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance deleteMany
   */
  export type StudentAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendances to delete
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to delete.
     */
    limit?: number
  }

  /**
   * StudentAttendance without action
   */
  export type StudentAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model StaffAttendance
   */

  export type AggregateStaffAttendance = {
    _count: StaffAttendanceCountAggregateOutputType | null
    _min: StaffAttendanceMinAggregateOutputType | null
    _max: StaffAttendanceMaxAggregateOutputType | null
  }

  export type StaffAttendanceMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    timeIn: Date | null
    timeOut: Date | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffAttendanceMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    timeIn: Date | null
    timeOut: Date | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffAttendanceCountAggregateOutputType = {
    id: number
    staffId: number
    date: number
    status: number
    timeIn: number
    timeOut: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffAttendanceMinAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    status?: true
    timeIn?: true
    timeOut?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffAttendanceMaxAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    status?: true
    timeIn?: true
    timeOut?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffAttendanceCountAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    status?: true
    timeIn?: true
    timeOut?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffAttendance to aggregate.
     */
    where?: StaffAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffAttendances to fetch.
     */
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffAttendances
    **/
    _count?: true | StaffAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffAttendanceMaxAggregateInputType
  }

  export type GetStaffAttendanceAggregateType<T extends StaffAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffAttendance[P]>
      : GetScalarType<T[P], AggregateStaffAttendance[P]>
  }




  export type StaffAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffAttendanceWhereInput
    orderBy?: StaffAttendanceOrderByWithAggregationInput | StaffAttendanceOrderByWithAggregationInput[]
    by: StaffAttendanceScalarFieldEnum[] | StaffAttendanceScalarFieldEnum
    having?: StaffAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffAttendanceCountAggregateInputType | true
    _min?: StaffAttendanceMinAggregateInputType
    _max?: StaffAttendanceMaxAggregateInputType
  }

  export type StaffAttendanceGroupByOutputType = {
    id: string
    staffId: string
    date: Date
    status: $Enums.AttendanceStatus
    timeIn: Date | null
    timeOut: Date | null
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: StaffAttendanceCountAggregateOutputType | null
    _min: StaffAttendanceMinAggregateOutputType | null
    _max: StaffAttendanceMaxAggregateOutputType | null
  }

  type GetStaffAttendanceGroupByPayload<T extends StaffAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], StaffAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type StaffAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    date?: boolean
    status?: boolean
    timeIn?: boolean
    timeOut?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffAttendance"]>

  export type StaffAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    date?: boolean
    status?: boolean
    timeIn?: boolean
    timeOut?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffAttendance"]>

  export type StaffAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    date?: boolean
    status?: boolean
    timeIn?: boolean
    timeOut?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffAttendance"]>

  export type StaffAttendanceSelectScalar = {
    id?: boolean
    staffId?: boolean
    date?: boolean
    status?: boolean
    timeIn?: boolean
    timeOut?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "date" | "status" | "timeIn" | "timeOut" | "remarks" | "createdAt" | "updatedAt", ExtArgs["result"]["staffAttendance"]>
  export type StaffAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type StaffAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type StaffAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }

  export type $StaffAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffAttendance"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string
      date: Date
      status: $Enums.AttendanceStatus
      timeIn: Date | null
      timeOut: Date | null
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staffAttendance"]>
    composites: {}
  }

  type StaffAttendanceGetPayload<S extends boolean | null | undefined | StaffAttendanceDefaultArgs> = $Result.GetResult<Prisma.$StaffAttendancePayload, S>

  type StaffAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffAttendanceCountAggregateInputType | true
    }

  export interface StaffAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffAttendance'], meta: { name: 'StaffAttendance' } }
    /**
     * Find zero or one StaffAttendance that matches the filter.
     * @param {StaffAttendanceFindUniqueArgs} args - Arguments to find a StaffAttendance
     * @example
     * // Get one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffAttendanceFindUniqueArgs>(args: SelectSubset<T, StaffAttendanceFindUniqueArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffAttendanceFindUniqueOrThrowArgs} args - Arguments to find a StaffAttendance
     * @example
     * // Get one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceFindFirstArgs} args - Arguments to find a StaffAttendance
     * @example
     * // Get one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffAttendanceFindFirstArgs>(args?: SelectSubset<T, StaffAttendanceFindFirstArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceFindFirstOrThrowArgs} args - Arguments to find a StaffAttendance
     * @example
     * // Get one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffAttendances
     * const staffAttendances = await prisma.staffAttendance.findMany()
     * 
     * // Get first 10 StaffAttendances
     * const staffAttendances = await prisma.staffAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffAttendanceWithIdOnly = await prisma.staffAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffAttendanceFindManyArgs>(args?: SelectSubset<T, StaffAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffAttendance.
     * @param {StaffAttendanceCreateArgs} args - Arguments to create a StaffAttendance.
     * @example
     * // Create one StaffAttendance
     * const StaffAttendance = await prisma.staffAttendance.create({
     *   data: {
     *     // ... data to create a StaffAttendance
     *   }
     * })
     * 
     */
    create<T extends StaffAttendanceCreateArgs>(args: SelectSubset<T, StaffAttendanceCreateArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffAttendances.
     * @param {StaffAttendanceCreateManyArgs} args - Arguments to create many StaffAttendances.
     * @example
     * // Create many StaffAttendances
     * const staffAttendance = await prisma.staffAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffAttendanceCreateManyArgs>(args?: SelectSubset<T, StaffAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffAttendances and returns the data saved in the database.
     * @param {StaffAttendanceCreateManyAndReturnArgs} args - Arguments to create many StaffAttendances.
     * @example
     * // Create many StaffAttendances
     * const staffAttendance = await prisma.staffAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffAttendances and only return the `id`
     * const staffAttendanceWithIdOnly = await prisma.staffAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffAttendance.
     * @param {StaffAttendanceDeleteArgs} args - Arguments to delete one StaffAttendance.
     * @example
     * // Delete one StaffAttendance
     * const StaffAttendance = await prisma.staffAttendance.delete({
     *   where: {
     *     // ... filter to delete one StaffAttendance
     *   }
     * })
     * 
     */
    delete<T extends StaffAttendanceDeleteArgs>(args: SelectSubset<T, StaffAttendanceDeleteArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffAttendance.
     * @param {StaffAttendanceUpdateArgs} args - Arguments to update one StaffAttendance.
     * @example
     * // Update one StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffAttendanceUpdateArgs>(args: SelectSubset<T, StaffAttendanceUpdateArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffAttendances.
     * @param {StaffAttendanceDeleteManyArgs} args - Arguments to filter StaffAttendances to delete.
     * @example
     * // Delete a few StaffAttendances
     * const { count } = await prisma.staffAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffAttendanceDeleteManyArgs>(args?: SelectSubset<T, StaffAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffAttendances
     * const staffAttendance = await prisma.staffAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffAttendanceUpdateManyArgs>(args: SelectSubset<T, StaffAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffAttendances and returns the data updated in the database.
     * @param {StaffAttendanceUpdateManyAndReturnArgs} args - Arguments to update many StaffAttendances.
     * @example
     * // Update many StaffAttendances
     * const staffAttendance = await prisma.staffAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffAttendances and only return the `id`
     * const staffAttendanceWithIdOnly = await prisma.staffAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffAttendance.
     * @param {StaffAttendanceUpsertArgs} args - Arguments to update or create a StaffAttendance.
     * @example
     * // Update or create a StaffAttendance
     * const staffAttendance = await prisma.staffAttendance.upsert({
     *   create: {
     *     // ... data to create a StaffAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffAttendance we want to update
     *   }
     * })
     */
    upsert<T extends StaffAttendanceUpsertArgs>(args: SelectSubset<T, StaffAttendanceUpsertArgs<ExtArgs>>): Prisma__StaffAttendanceClient<$Result.GetResult<Prisma.$StaffAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceCountArgs} args - Arguments to filter StaffAttendances to count.
     * @example
     * // Count the number of StaffAttendances
     * const count = await prisma.staffAttendance.count({
     *   where: {
     *     // ... the filter for the StaffAttendances we want to count
     *   }
     * })
    **/
    count<T extends StaffAttendanceCountArgs>(
      args?: Subset<T, StaffAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAttendanceAggregateArgs>(args: Subset<T, StaffAttendanceAggregateArgs>): Prisma.PrismaPromise<GetStaffAttendanceAggregateType<T>>

    /**
     * Group by StaffAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: StaffAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffAttendance model
   */
  readonly fields: StaffAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffAttendance model
   */
  interface StaffAttendanceFieldRefs {
    readonly id: FieldRef<"StaffAttendance", 'String'>
    readonly staffId: FieldRef<"StaffAttendance", 'String'>
    readonly date: FieldRef<"StaffAttendance", 'DateTime'>
    readonly status: FieldRef<"StaffAttendance", 'AttendanceStatus'>
    readonly timeIn: FieldRef<"StaffAttendance", 'DateTime'>
    readonly timeOut: FieldRef<"StaffAttendance", 'DateTime'>
    readonly remarks: FieldRef<"StaffAttendance", 'String'>
    readonly createdAt: FieldRef<"StaffAttendance", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffAttendance findUnique
   */
  export type StaffAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendance to fetch.
     */
    where: StaffAttendanceWhereUniqueInput
  }

  /**
   * StaffAttendance findUniqueOrThrow
   */
  export type StaffAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendance to fetch.
     */
    where: StaffAttendanceWhereUniqueInput
  }

  /**
   * StaffAttendance findFirst
   */
  export type StaffAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendance to fetch.
     */
    where?: StaffAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffAttendances to fetch.
     */
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffAttendances.
     */
    cursor?: StaffAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffAttendances.
     */
    distinct?: StaffAttendanceScalarFieldEnum | StaffAttendanceScalarFieldEnum[]
  }

  /**
   * StaffAttendance findFirstOrThrow
   */
  export type StaffAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendance to fetch.
     */
    where?: StaffAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffAttendances to fetch.
     */
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffAttendances.
     */
    cursor?: StaffAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffAttendances.
     */
    distinct?: StaffAttendanceScalarFieldEnum | StaffAttendanceScalarFieldEnum[]
  }

  /**
   * StaffAttendance findMany
   */
  export type StaffAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StaffAttendances to fetch.
     */
    where?: StaffAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffAttendances to fetch.
     */
    orderBy?: StaffAttendanceOrderByWithRelationInput | StaffAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffAttendances.
     */
    cursor?: StaffAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffAttendances.
     */
    skip?: number
    distinct?: StaffAttendanceScalarFieldEnum | StaffAttendanceScalarFieldEnum[]
  }

  /**
   * StaffAttendance create
   */
  export type StaffAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffAttendance.
     */
    data: XOR<StaffAttendanceCreateInput, StaffAttendanceUncheckedCreateInput>
  }

  /**
   * StaffAttendance createMany
   */
  export type StaffAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffAttendances.
     */
    data: StaffAttendanceCreateManyInput | StaffAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffAttendance createManyAndReturn
   */
  export type StaffAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many StaffAttendances.
     */
    data: StaffAttendanceCreateManyInput | StaffAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffAttendance update
   */
  export type StaffAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffAttendance.
     */
    data: XOR<StaffAttendanceUpdateInput, StaffAttendanceUncheckedUpdateInput>
    /**
     * Choose, which StaffAttendance to update.
     */
    where: StaffAttendanceWhereUniqueInput
  }

  /**
   * StaffAttendance updateMany
   */
  export type StaffAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffAttendances.
     */
    data: XOR<StaffAttendanceUpdateManyMutationInput, StaffAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StaffAttendances to update
     */
    where?: StaffAttendanceWhereInput
    /**
     * Limit how many StaffAttendances to update.
     */
    limit?: number
  }

  /**
   * StaffAttendance updateManyAndReturn
   */
  export type StaffAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update StaffAttendances.
     */
    data: XOR<StaffAttendanceUpdateManyMutationInput, StaffAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StaffAttendances to update
     */
    where?: StaffAttendanceWhereInput
    /**
     * Limit how many StaffAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffAttendance upsert
   */
  export type StaffAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffAttendance to update in case it exists.
     */
    where: StaffAttendanceWhereUniqueInput
    /**
     * In case the StaffAttendance found by the `where` argument doesn't exist, create a new StaffAttendance with this data.
     */
    create: XOR<StaffAttendanceCreateInput, StaffAttendanceUncheckedCreateInput>
    /**
     * In case the StaffAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffAttendanceUpdateInput, StaffAttendanceUncheckedUpdateInput>
  }

  /**
   * StaffAttendance delete
   */
  export type StaffAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
    /**
     * Filter which StaffAttendance to delete.
     */
    where: StaffAttendanceWhereUniqueInput
  }

  /**
   * StaffAttendance deleteMany
   */
  export type StaffAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffAttendances to delete
     */
    where?: StaffAttendanceWhereInput
    /**
     * Limit how many StaffAttendances to delete.
     */
    limit?: number
  }

  /**
   * StaffAttendance without action
   */
  export type StaffAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffAttendance
     */
    select?: StaffAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffAttendance
     */
    omit?: StaffAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    name: string | null
    email: string | null
    phone: string | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    name: string | null
    email: string | null
    phone: string | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    studentId: number
    name: number
    email: number
    phone: number
    profilePicture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    email?: true
    phone?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    email?: true
    phone?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    email?: true
    phone?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    studentId: string
    name: string
    email: string
    phone: string | null
    profilePicture: string | null
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectScalar = {
    id?: boolean
    studentId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "name" | "email" | "phone" | "profilePicture" | "createdAt" | "updatedAt", ExtArgs["result"]["parent"]>
  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type ParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type ParentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      name: string
      email: string
      phone: string | null
      profilePicture: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents and returns the data updated in the database.
     * @param {ParentUpdateManyAndReturnArgs} args - Arguments to update many Parents.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParentUpdateManyAndReturnArgs>(args: SelectSubset<T, ParentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly studentId: FieldRef<"Parent", 'String'>
    readonly name: FieldRef<"Parent", 'String'>
    readonly email: FieldRef<"Parent", 'String'>
    readonly phone: FieldRef<"Parent", 'String'>
    readonly profilePicture: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent createManyAndReturn
   */
  export type ParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parent updateManyAndReturn
   */
  export type ParentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model Author
   */

  export type AggregateAuthor = {
    _count: AuthorCountAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorMinAggregateOutputType = {
    id: string | null
    name: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number
    name: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthorMinAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Author to aggregate.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    _count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }




  export type AuthorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorWhereInput
    orderBy?: AuthorOrderByWithAggregationInput | AuthorOrderByWithAggregationInput[]
    by: AuthorScalarFieldEnum[] | AuthorScalarFieldEnum
    having?: AuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCountAggregateInputType | true
    _min?: AuthorMinAggregateInputType
    _max?: AuthorMaxAggregateInputType
  }

  export type AuthorGroupByOutputType = {
    id: string
    name: string
    bio: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuthorCountAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  type GetAuthorGroupByPayload<T extends AuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorGroupByOutputType[P]>
        }
      >
    >


  export type AuthorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    books?: boolean | Author$booksArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectScalar = {
    id?: boolean
    name?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "bio" | "createdAt" | "updatedAt", ExtArgs["result"]["author"]>
  export type AuthorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Author$booksArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AuthorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AuthorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Author"
    objects: {
      books: Prisma.$BookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      bio: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["author"]>
    composites: {}
  }

  type AuthorGetPayload<S extends boolean | null | undefined | AuthorDefaultArgs> = $Result.GetResult<Prisma.$AuthorPayload, S>

  type AuthorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorCountAggregateInputType | true
    }

  export interface AuthorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Author'], meta: { name: 'Author' } }
    /**
     * Find zero or one Author that matches the filter.
     * @param {AuthorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorFindUniqueArgs>(args: SelectSubset<T, AuthorFindUniqueArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthorFindUniqueOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorFindFirstArgs>(args?: SelectSubset<T, AuthorFindFirstArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorFindManyArgs>(args?: SelectSubset<T, AuthorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Author.
     * @param {AuthorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
     */
    create<T extends AuthorCreateArgs>(args: SelectSubset<T, AuthorCreateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authors.
     * @param {AuthorCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorCreateManyArgs>(args?: SelectSubset<T, AuthorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {AuthorCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthorCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Author.
     * @param {AuthorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
     */
    delete<T extends AuthorDeleteArgs>(args: SelectSubset<T, AuthorDeleteArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Author.
     * @param {AuthorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorUpdateArgs>(args: SelectSubset<T, AuthorUpdateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authors.
     * @param {AuthorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorDeleteManyArgs>(args?: SelectSubset<T, AuthorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorUpdateManyArgs>(args: SelectSubset<T, AuthorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {AuthorUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthorUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Author.
     * @param {AuthorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
     */
    upsert<T extends AuthorUpsertArgs>(args: SelectSubset<T, AuthorUpsertArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorCountArgs>(
      args?: Subset<T, AuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): Prisma.PrismaPromise<GetAuthorAggregateType<T>>

    /**
     * Group by Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorGroupByArgs['orderBy'] }
        : { orderBy?: AuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Author model
   */
  readonly fields: AuthorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends Author$booksArgs<ExtArgs> = {}>(args?: Subset<T, Author$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Author model
   */
  interface AuthorFieldRefs {
    readonly id: FieldRef<"Author", 'String'>
    readonly name: FieldRef<"Author", 'String'>
    readonly bio: FieldRef<"Author", 'String'>
    readonly createdAt: FieldRef<"Author", 'DateTime'>
    readonly updatedAt: FieldRef<"Author", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Author findUnique
   */
  export type AuthorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findUniqueOrThrow
   */
  export type AuthorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findFirst
   */
  export type AuthorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findFirstOrThrow
   */
  export type AuthorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findMany
   */
  export type AuthorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author create
   */
  export type AuthorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to create a Author.
     */
    data: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
  }

  /**
   * Author createMany
   */
  export type AuthorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Author createManyAndReturn
   */
  export type AuthorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Author update
   */
  export type AuthorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to update a Author.
     */
    data: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
    /**
     * Choose, which Author to update.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author updateMany
   */
  export type AuthorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Author updateManyAndReturn
   */
  export type AuthorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Author upsert
   */
  export type AuthorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The filter to search for the Author to update in case it exists.
     */
    where: AuthorWhereUniqueInput
    /**
     * In case the Author found by the `where` argument doesn't exist, create a new Author with this data.
     */
    create: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
    /**
     * In case the Author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
  }

  /**
   * Author delete
   */
  export type AuthorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter which Author to delete.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author deleteMany
   */
  export type AuthorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to delete
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to delete.
     */
    limit?: number
  }

  /**
   * Author.books
   */
  export type Author$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Author without action
   */
  export type AuthorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    books?: boolean | Category$booksArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Category$booksArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      books: Prisma.$BookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends Category$booksArgs<ExtArgs> = {}>(args?: Subset<T, Category$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.books
   */
  export type Category$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Book
   */

  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookAvgAggregateOutputType = {
    totalCopies: number | null
    available: number | null
  }

  export type BookSumAggregateOutputType = {
    totalCopies: number | null
    available: number | null
  }

  export type BookMinAggregateOutputType = {
    id: string | null
    title: string | null
    isbn: string | null
    authorId: string | null
    categoryId: string | null
    totalCopies: number | null
    available: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookMaxAggregateOutputType = {
    id: string | null
    title: string | null
    isbn: string | null
    authorId: string | null
    categoryId: string | null
    totalCopies: number | null
    available: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    title: number
    isbn: number
    authorId: number
    categoryId: number
    totalCopies: number
    available: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookAvgAggregateInputType = {
    totalCopies?: true
    available?: true
  }

  export type BookSumAggregateInputType = {
    totalCopies?: true
    available?: true
  }

  export type BookMinAggregateInputType = {
    id?: true
    title?: true
    isbn?: true
    authorId?: true
    categoryId?: true
    totalCopies?: true
    available?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    title?: true
    isbn?: true
    authorId?: true
    categoryId?: true
    totalCopies?: true
    available?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    title?: true
    isbn?: true
    authorId?: true
    categoryId?: true
    totalCopies?: true
    available?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book to aggregate.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type BookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
    orderBy?: BookOrderByWithAggregationInput | BookOrderByWithAggregationInput[]
    by: BookScalarFieldEnum[] | BookScalarFieldEnum
    having?: BookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _avg?: BookAvgAggregateInputType
    _sum?: BookSumAggregateInputType
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }

  export type BookGroupByOutputType = {
    id: string
    title: string
    isbn: string
    authorId: string
    categoryId: string | null
    totalCopies: number
    available: number
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends BookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type BookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isbn?: boolean
    authorId?: boolean
    categoryId?: boolean
    totalCopies?: boolean
    available?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | Book$categoryArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    borrows?: boolean | Book$borrowsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isbn?: boolean
    authorId?: boolean
    categoryId?: boolean
    totalCopies?: boolean
    available?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | Book$categoryArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isbn?: boolean
    authorId?: boolean
    categoryId?: boolean
    totalCopies?: boolean
    available?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | Book$categoryArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectScalar = {
    id?: boolean
    title?: boolean
    isbn?: boolean
    authorId?: boolean
    categoryId?: boolean
    totalCopies?: boolean
    available?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "isbn" | "authorId" | "categoryId" | "totalCopies" | "available" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["book"]>
  export type BookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | Book$categoryArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    borrows?: boolean | Book$borrowsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | Book$categoryArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type BookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | Book$categoryArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $BookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book"
    objects: {
      author: Prisma.$AuthorPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      borrows: Prisma.$BorrowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      isbn: string
      authorId: string
      categoryId: string | null
      totalCopies: number
      available: number
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["book"]>
    composites: {}
  }

  type BookGetPayload<S extends boolean | null | undefined | BookDefaultArgs> = $Result.GetResult<Prisma.$BookPayload, S>

  type BookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface BookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book'], meta: { name: 'Book' } }
    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookFindUniqueArgs>(args: SelectSubset<T, BookFindUniqueArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookFindUniqueOrThrowArgs>(args: SelectSubset<T, BookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookFindFirstArgs>(args?: SelectSubset<T, BookFindFirstArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookFindFirstOrThrowArgs>(args?: SelectSubset<T, BookFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookFindManyArgs>(args?: SelectSubset<T, BookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
     */
    create<T extends BookCreateArgs>(args: SelectSubset<T, BookCreateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Books.
     * @param {BookCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookCreateManyArgs>(args?: SelectSubset<T, BookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Books and returns the data saved in the database.
     * @param {BookCreateManyAndReturnArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookCreateManyAndReturnArgs>(args?: SelectSubset<T, BookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
     */
    delete<T extends BookDeleteArgs>(args: SelectSubset<T, BookDeleteArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookUpdateArgs>(args: SelectSubset<T, BookUpdateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookDeleteManyArgs>(args?: SelectSubset<T, BookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookUpdateManyArgs>(args: SelectSubset<T, BookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books and returns the data updated in the database.
     * @param {BookUpdateManyAndReturnArgs} args - Arguments to update many Books.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookUpdateManyAndReturnArgs>(args: SelectSubset<T, BookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
     */
    upsert<T extends BookUpsertArgs>(args: SelectSubset<T, BookUpsertArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookGroupByArgs['orderBy'] }
        : { orderBy?: BookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book model
   */
  readonly fields: BookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends AuthorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthorDefaultArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Book$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Book$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    borrows<T extends Book$borrowsArgs<ExtArgs> = {}>(args?: Subset<T, Book$borrowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book model
   */
  interface BookFieldRefs {
    readonly id: FieldRef<"Book", 'String'>
    readonly title: FieldRef<"Book", 'String'>
    readonly isbn: FieldRef<"Book", 'String'>
    readonly authorId: FieldRef<"Book", 'String'>
    readonly categoryId: FieldRef<"Book", 'String'>
    readonly totalCopies: FieldRef<"Book", 'Int'>
    readonly available: FieldRef<"Book", 'Int'>
    readonly schoolId: FieldRef<"Book", 'String'>
    readonly createdAt: FieldRef<"Book", 'DateTime'>
    readonly updatedAt: FieldRef<"Book", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Book findUnique
   */
  export type BookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findUniqueOrThrow
   */
  export type BookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findFirst
   */
  export type BookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findFirstOrThrow
   */
  export type BookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findMany
   */
  export type BookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book create
   */
  export type BookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to create a Book.
     */
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }

  /**
   * Book createMany
   */
  export type BookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book createManyAndReturn
   */
  export type BookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book update
   */
  export type BookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to update a Book.
     */
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
  }

  /**
   * Book updateManyAndReturn
   */
  export type BookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book upsert
   */
  export type BookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The filter to search for the Book to update in case it exists.
     */
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
     */
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }

  /**
   * Book delete
   */
  export type BookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter which Book to delete.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Books to delete
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to delete.
     */
    limit?: number
  }

  /**
   * Book.category
   */
  export type Book$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Book.borrows
   */
  export type Book$borrowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    cursor?: BorrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Book without action
   */
  export type BookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
  }


  /**
   * Model Borrow
   */

  export type AggregateBorrow = {
    _count: BorrowCountAggregateOutputType | null
    _avg: BorrowAvgAggregateOutputType | null
    _sum: BorrowSumAggregateOutputType | null
    _min: BorrowMinAggregateOutputType | null
    _max: BorrowMaxAggregateOutputType | null
  }

  export type BorrowAvgAggregateOutputType = {
    fine: number | null
  }

  export type BorrowSumAggregateOutputType = {
    fine: number | null
  }

  export type BorrowMinAggregateOutputType = {
    id: string | null
    bookId: string | null
    studentId: string | null
    borrowedAt: Date | null
    dueAt: Date | null
    returnedAt: Date | null
    fine: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BorrowMaxAggregateOutputType = {
    id: string | null
    bookId: string | null
    studentId: string | null
    borrowedAt: Date | null
    dueAt: Date | null
    returnedAt: Date | null
    fine: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BorrowCountAggregateOutputType = {
    id: number
    bookId: number
    studentId: number
    borrowedAt: number
    dueAt: number
    returnedAt: number
    fine: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BorrowAvgAggregateInputType = {
    fine?: true
  }

  export type BorrowSumAggregateInputType = {
    fine?: true
  }

  export type BorrowMinAggregateInputType = {
    id?: true
    bookId?: true
    studentId?: true
    borrowedAt?: true
    dueAt?: true
    returnedAt?: true
    fine?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BorrowMaxAggregateInputType = {
    id?: true
    bookId?: true
    studentId?: true
    borrowedAt?: true
    dueAt?: true
    returnedAt?: true
    fine?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BorrowCountAggregateInputType = {
    id?: true
    bookId?: true
    studentId?: true
    borrowedAt?: true
    dueAt?: true
    returnedAt?: true
    fine?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BorrowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Borrow to aggregate.
     */
    where?: BorrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrows to fetch.
     */
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BorrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Borrows
    **/
    _count?: true | BorrowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BorrowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BorrowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorrowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorrowMaxAggregateInputType
  }

  export type GetBorrowAggregateType<T extends BorrowAggregateArgs> = {
        [P in keyof T & keyof AggregateBorrow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBorrow[P]>
      : GetScalarType<T[P], AggregateBorrow[P]>
  }




  export type BorrowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithAggregationInput | BorrowOrderByWithAggregationInput[]
    by: BorrowScalarFieldEnum[] | BorrowScalarFieldEnum
    having?: BorrowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorrowCountAggregateInputType | true
    _avg?: BorrowAvgAggregateInputType
    _sum?: BorrowSumAggregateInputType
    _min?: BorrowMinAggregateInputType
    _max?: BorrowMaxAggregateInputType
  }

  export type BorrowGroupByOutputType = {
    id: string
    bookId: string
    studentId: string
    borrowedAt: Date
    dueAt: Date
    returnedAt: Date | null
    fine: number
    createdAt: Date
    updatedAt: Date
    _count: BorrowCountAggregateOutputType | null
    _avg: BorrowAvgAggregateOutputType | null
    _sum: BorrowSumAggregateOutputType | null
    _min: BorrowMinAggregateOutputType | null
    _max: BorrowMaxAggregateOutputType | null
  }

  type GetBorrowGroupByPayload<T extends BorrowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BorrowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorrowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorrowGroupByOutputType[P]>
            : GetScalarType<T[P], BorrowGroupByOutputType[P]>
        }
      >
    >


  export type BorrowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    studentId?: boolean
    borrowedAt?: boolean
    dueAt?: boolean
    returnedAt?: boolean
    fine?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["borrow"]>

  export type BorrowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    studentId?: boolean
    borrowedAt?: boolean
    dueAt?: boolean
    returnedAt?: boolean
    fine?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["borrow"]>

  export type BorrowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    studentId?: boolean
    borrowedAt?: boolean
    dueAt?: boolean
    returnedAt?: boolean
    fine?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["borrow"]>

  export type BorrowSelectScalar = {
    id?: boolean
    bookId?: boolean
    studentId?: boolean
    borrowedAt?: boolean
    dueAt?: boolean
    returnedAt?: boolean
    fine?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BorrowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookId" | "studentId" | "borrowedAt" | "dueAt" | "returnedAt" | "fine" | "createdAt" | "updatedAt", ExtArgs["result"]["borrow"]>
  export type BorrowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type BorrowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type BorrowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $BorrowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Borrow"
    objects: {
      book: Prisma.$BookPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookId: string
      studentId: string
      borrowedAt: Date
      dueAt: Date
      returnedAt: Date | null
      fine: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["borrow"]>
    composites: {}
  }

  type BorrowGetPayload<S extends boolean | null | undefined | BorrowDefaultArgs> = $Result.GetResult<Prisma.$BorrowPayload, S>

  type BorrowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BorrowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BorrowCountAggregateInputType | true
    }

  export interface BorrowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Borrow'], meta: { name: 'Borrow' } }
    /**
     * Find zero or one Borrow that matches the filter.
     * @param {BorrowFindUniqueArgs} args - Arguments to find a Borrow
     * @example
     * // Get one Borrow
     * const borrow = await prisma.borrow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BorrowFindUniqueArgs>(args: SelectSubset<T, BorrowFindUniqueArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Borrow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BorrowFindUniqueOrThrowArgs} args - Arguments to find a Borrow
     * @example
     * // Get one Borrow
     * const borrow = await prisma.borrow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BorrowFindUniqueOrThrowArgs>(args: SelectSubset<T, BorrowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Borrow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowFindFirstArgs} args - Arguments to find a Borrow
     * @example
     * // Get one Borrow
     * const borrow = await prisma.borrow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BorrowFindFirstArgs>(args?: SelectSubset<T, BorrowFindFirstArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Borrow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowFindFirstOrThrowArgs} args - Arguments to find a Borrow
     * @example
     * // Get one Borrow
     * const borrow = await prisma.borrow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BorrowFindFirstOrThrowArgs>(args?: SelectSubset<T, BorrowFindFirstOrThrowArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Borrows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Borrows
     * const borrows = await prisma.borrow.findMany()
     * 
     * // Get first 10 Borrows
     * const borrows = await prisma.borrow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borrowWithIdOnly = await prisma.borrow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BorrowFindManyArgs>(args?: SelectSubset<T, BorrowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Borrow.
     * @param {BorrowCreateArgs} args - Arguments to create a Borrow.
     * @example
     * // Create one Borrow
     * const Borrow = await prisma.borrow.create({
     *   data: {
     *     // ... data to create a Borrow
     *   }
     * })
     * 
     */
    create<T extends BorrowCreateArgs>(args: SelectSubset<T, BorrowCreateArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Borrows.
     * @param {BorrowCreateManyArgs} args - Arguments to create many Borrows.
     * @example
     * // Create many Borrows
     * const borrow = await prisma.borrow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BorrowCreateManyArgs>(args?: SelectSubset<T, BorrowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Borrows and returns the data saved in the database.
     * @param {BorrowCreateManyAndReturnArgs} args - Arguments to create many Borrows.
     * @example
     * // Create many Borrows
     * const borrow = await prisma.borrow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Borrows and only return the `id`
     * const borrowWithIdOnly = await prisma.borrow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BorrowCreateManyAndReturnArgs>(args?: SelectSubset<T, BorrowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Borrow.
     * @param {BorrowDeleteArgs} args - Arguments to delete one Borrow.
     * @example
     * // Delete one Borrow
     * const Borrow = await prisma.borrow.delete({
     *   where: {
     *     // ... filter to delete one Borrow
     *   }
     * })
     * 
     */
    delete<T extends BorrowDeleteArgs>(args: SelectSubset<T, BorrowDeleteArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Borrow.
     * @param {BorrowUpdateArgs} args - Arguments to update one Borrow.
     * @example
     * // Update one Borrow
     * const borrow = await prisma.borrow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BorrowUpdateArgs>(args: SelectSubset<T, BorrowUpdateArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Borrows.
     * @param {BorrowDeleteManyArgs} args - Arguments to filter Borrows to delete.
     * @example
     * // Delete a few Borrows
     * const { count } = await prisma.borrow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BorrowDeleteManyArgs>(args?: SelectSubset<T, BorrowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Borrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Borrows
     * const borrow = await prisma.borrow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BorrowUpdateManyArgs>(args: SelectSubset<T, BorrowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Borrows and returns the data updated in the database.
     * @param {BorrowUpdateManyAndReturnArgs} args - Arguments to update many Borrows.
     * @example
     * // Update many Borrows
     * const borrow = await prisma.borrow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Borrows and only return the `id`
     * const borrowWithIdOnly = await prisma.borrow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BorrowUpdateManyAndReturnArgs>(args: SelectSubset<T, BorrowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Borrow.
     * @param {BorrowUpsertArgs} args - Arguments to update or create a Borrow.
     * @example
     * // Update or create a Borrow
     * const borrow = await prisma.borrow.upsert({
     *   create: {
     *     // ... data to create a Borrow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Borrow we want to update
     *   }
     * })
     */
    upsert<T extends BorrowUpsertArgs>(args: SelectSubset<T, BorrowUpsertArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Borrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowCountArgs} args - Arguments to filter Borrows to count.
     * @example
     * // Count the number of Borrows
     * const count = await prisma.borrow.count({
     *   where: {
     *     // ... the filter for the Borrows we want to count
     *   }
     * })
    **/
    count<T extends BorrowCountArgs>(
      args?: Subset<T, BorrowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorrowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Borrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorrowAggregateArgs>(args: Subset<T, BorrowAggregateArgs>): Prisma.PrismaPromise<GetBorrowAggregateType<T>>

    /**
     * Group by Borrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BorrowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorrowGroupByArgs['orderBy'] }
        : { orderBy?: BorrowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BorrowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorrowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Borrow model
   */
  readonly fields: BorrowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Borrow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BorrowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookDefaultArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Borrow model
   */
  interface BorrowFieldRefs {
    readonly id: FieldRef<"Borrow", 'String'>
    readonly bookId: FieldRef<"Borrow", 'String'>
    readonly studentId: FieldRef<"Borrow", 'String'>
    readonly borrowedAt: FieldRef<"Borrow", 'DateTime'>
    readonly dueAt: FieldRef<"Borrow", 'DateTime'>
    readonly returnedAt: FieldRef<"Borrow", 'DateTime'>
    readonly fine: FieldRef<"Borrow", 'Float'>
    readonly createdAt: FieldRef<"Borrow", 'DateTime'>
    readonly updatedAt: FieldRef<"Borrow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Borrow findUnique
   */
  export type BorrowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrow to fetch.
     */
    where: BorrowWhereUniqueInput
  }

  /**
   * Borrow findUniqueOrThrow
   */
  export type BorrowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrow to fetch.
     */
    where: BorrowWhereUniqueInput
  }

  /**
   * Borrow findFirst
   */
  export type BorrowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrow to fetch.
     */
    where?: BorrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrows to fetch.
     */
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Borrows.
     */
    cursor?: BorrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Borrows.
     */
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Borrow findFirstOrThrow
   */
  export type BorrowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrow to fetch.
     */
    where?: BorrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrows to fetch.
     */
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Borrows.
     */
    cursor?: BorrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Borrows.
     */
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Borrow findMany
   */
  export type BorrowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrows to fetch.
     */
    where?: BorrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrows to fetch.
     */
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Borrows.
     */
    cursor?: BorrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrows.
     */
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Borrow create
   */
  export type BorrowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * The data needed to create a Borrow.
     */
    data: XOR<BorrowCreateInput, BorrowUncheckedCreateInput>
  }

  /**
   * Borrow createMany
   */
  export type BorrowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Borrows.
     */
    data: BorrowCreateManyInput | BorrowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Borrow createManyAndReturn
   */
  export type BorrowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * The data used to create many Borrows.
     */
    data: BorrowCreateManyInput | BorrowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Borrow update
   */
  export type BorrowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * The data needed to update a Borrow.
     */
    data: XOR<BorrowUpdateInput, BorrowUncheckedUpdateInput>
    /**
     * Choose, which Borrow to update.
     */
    where: BorrowWhereUniqueInput
  }

  /**
   * Borrow updateMany
   */
  export type BorrowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Borrows.
     */
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyInput>
    /**
     * Filter which Borrows to update
     */
    where?: BorrowWhereInput
    /**
     * Limit how many Borrows to update.
     */
    limit?: number
  }

  /**
   * Borrow updateManyAndReturn
   */
  export type BorrowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * The data used to update Borrows.
     */
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyInput>
    /**
     * Filter which Borrows to update
     */
    where?: BorrowWhereInput
    /**
     * Limit how many Borrows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Borrow upsert
   */
  export type BorrowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * The filter to search for the Borrow to update in case it exists.
     */
    where: BorrowWhereUniqueInput
    /**
     * In case the Borrow found by the `where` argument doesn't exist, create a new Borrow with this data.
     */
    create: XOR<BorrowCreateInput, BorrowUncheckedCreateInput>
    /**
     * In case the Borrow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BorrowUpdateInput, BorrowUncheckedUpdateInput>
  }

  /**
   * Borrow delete
   */
  export type BorrowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter which Borrow to delete.
     */
    where: BorrowWhereUniqueInput
  }

  /**
   * Borrow deleteMany
   */
  export type BorrowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Borrows to delete
     */
    where?: BorrowWhereInput
    /**
     * Limit how many Borrows to delete.
     */
    limit?: number
  }

  /**
   * Borrow without action
   */
  export type BorrowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
  }


  /**
   * Model LibraryStaff
   */

  export type AggregateLibraryStaff = {
    _count: LibraryStaffCountAggregateOutputType | null
    _min: LibraryStaffMinAggregateOutputType | null
    _max: LibraryStaffMaxAggregateOutputType | null
  }

  export type LibraryStaffMinAggregateOutputType = {
    id: string | null
    userId: string | null
    departmentId: string | null
    position: string | null
    hireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryStaffMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    departmentId: string | null
    position: string | null
    hireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryStaffCountAggregateOutputType = {
    id: number
    userId: number
    departmentId: number
    position: number
    hireDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryStaffMinAggregateInputType = {
    id?: true
    userId?: true
    departmentId?: true
    position?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryStaffMaxAggregateInputType = {
    id?: true
    userId?: true
    departmentId?: true
    position?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryStaffCountAggregateInputType = {
    id?: true
    userId?: true
    departmentId?: true
    position?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryStaff to aggregate.
     */
    where?: LibraryStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStaffs to fetch.
     */
    orderBy?: LibraryStaffOrderByWithRelationInput | LibraryStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryStaffs
    **/
    _count?: true | LibraryStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryStaffMaxAggregateInputType
  }

  export type GetLibraryStaffAggregateType<T extends LibraryStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryStaff[P]>
      : GetScalarType<T[P], AggregateLibraryStaff[P]>
  }




  export type LibraryStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryStaffWhereInput
    orderBy?: LibraryStaffOrderByWithAggregationInput | LibraryStaffOrderByWithAggregationInput[]
    by: LibraryStaffScalarFieldEnum[] | LibraryStaffScalarFieldEnum
    having?: LibraryStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryStaffCountAggregateInputType | true
    _min?: LibraryStaffMinAggregateInputType
    _max?: LibraryStaffMaxAggregateInputType
  }

  export type LibraryStaffGroupByOutputType = {
    id: string
    userId: string
    departmentId: string
    position: string | null
    hireDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LibraryStaffCountAggregateOutputType | null
    _min: LibraryStaffMinAggregateOutputType | null
    _max: LibraryStaffMaxAggregateOutputType | null
  }

  type GetLibraryStaffGroupByPayload<T extends LibraryStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryStaffGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryStaffGroupByOutputType[P]>
        }
      >
    >


  export type LibraryStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    departmentId?: boolean
    position?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryStaff"]>

  export type LibraryStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    departmentId?: boolean
    position?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryStaff"]>

  export type LibraryStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    departmentId?: boolean
    position?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryStaff"]>

  export type LibraryStaffSelectScalar = {
    id?: boolean
    userId?: boolean
    departmentId?: boolean
    position?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LibraryStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "departmentId" | "position" | "hireDate" | "createdAt" | "updatedAt", ExtArgs["result"]["libraryStaff"]>
  export type LibraryStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type LibraryStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type LibraryStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $LibraryStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LibraryStaff"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      departmentId: string
      position: string | null
      hireDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["libraryStaff"]>
    composites: {}
  }

  type LibraryStaffGetPayload<S extends boolean | null | undefined | LibraryStaffDefaultArgs> = $Result.GetResult<Prisma.$LibraryStaffPayload, S>

  type LibraryStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LibraryStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LibraryStaffCountAggregateInputType | true
    }

  export interface LibraryStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LibraryStaff'], meta: { name: 'LibraryStaff' } }
    /**
     * Find zero or one LibraryStaff that matches the filter.
     * @param {LibraryStaffFindUniqueArgs} args - Arguments to find a LibraryStaff
     * @example
     * // Get one LibraryStaff
     * const libraryStaff = await prisma.libraryStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryStaffFindUniqueArgs>(args: SelectSubset<T, LibraryStaffFindUniqueArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LibraryStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LibraryStaffFindUniqueOrThrowArgs} args - Arguments to find a LibraryStaff
     * @example
     * // Get one LibraryStaff
     * const libraryStaff = await prisma.libraryStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, LibraryStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStaffFindFirstArgs} args - Arguments to find a LibraryStaff
     * @example
     * // Get one LibraryStaff
     * const libraryStaff = await prisma.libraryStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryStaffFindFirstArgs>(args?: SelectSubset<T, LibraryStaffFindFirstArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStaffFindFirstOrThrowArgs} args - Arguments to find a LibraryStaff
     * @example
     * // Get one LibraryStaff
     * const libraryStaff = await prisma.libraryStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, LibraryStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LibraryStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryStaffs
     * const libraryStaffs = await prisma.libraryStaff.findMany()
     * 
     * // Get first 10 LibraryStaffs
     * const libraryStaffs = await prisma.libraryStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryStaffWithIdOnly = await prisma.libraryStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LibraryStaffFindManyArgs>(args?: SelectSubset<T, LibraryStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LibraryStaff.
     * @param {LibraryStaffCreateArgs} args - Arguments to create a LibraryStaff.
     * @example
     * // Create one LibraryStaff
     * const LibraryStaff = await prisma.libraryStaff.create({
     *   data: {
     *     // ... data to create a LibraryStaff
     *   }
     * })
     * 
     */
    create<T extends LibraryStaffCreateArgs>(args: SelectSubset<T, LibraryStaffCreateArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LibraryStaffs.
     * @param {LibraryStaffCreateManyArgs} args - Arguments to create many LibraryStaffs.
     * @example
     * // Create many LibraryStaffs
     * const libraryStaff = await prisma.libraryStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LibraryStaffCreateManyArgs>(args?: SelectSubset<T, LibraryStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LibraryStaffs and returns the data saved in the database.
     * @param {LibraryStaffCreateManyAndReturnArgs} args - Arguments to create many LibraryStaffs.
     * @example
     * // Create many LibraryStaffs
     * const libraryStaff = await prisma.libraryStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LibraryStaffs and only return the `id`
     * const libraryStaffWithIdOnly = await prisma.libraryStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LibraryStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, LibraryStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LibraryStaff.
     * @param {LibraryStaffDeleteArgs} args - Arguments to delete one LibraryStaff.
     * @example
     * // Delete one LibraryStaff
     * const LibraryStaff = await prisma.libraryStaff.delete({
     *   where: {
     *     // ... filter to delete one LibraryStaff
     *   }
     * })
     * 
     */
    delete<T extends LibraryStaffDeleteArgs>(args: SelectSubset<T, LibraryStaffDeleteArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LibraryStaff.
     * @param {LibraryStaffUpdateArgs} args - Arguments to update one LibraryStaff.
     * @example
     * // Update one LibraryStaff
     * const libraryStaff = await prisma.libraryStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LibraryStaffUpdateArgs>(args: SelectSubset<T, LibraryStaffUpdateArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LibraryStaffs.
     * @param {LibraryStaffDeleteManyArgs} args - Arguments to filter LibraryStaffs to delete.
     * @example
     * // Delete a few LibraryStaffs
     * const { count } = await prisma.libraryStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LibraryStaffDeleteManyArgs>(args?: SelectSubset<T, LibraryStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryStaffs
     * const libraryStaff = await prisma.libraryStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LibraryStaffUpdateManyArgs>(args: SelectSubset<T, LibraryStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryStaffs and returns the data updated in the database.
     * @param {LibraryStaffUpdateManyAndReturnArgs} args - Arguments to update many LibraryStaffs.
     * @example
     * // Update many LibraryStaffs
     * const libraryStaff = await prisma.libraryStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LibraryStaffs and only return the `id`
     * const libraryStaffWithIdOnly = await prisma.libraryStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LibraryStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, LibraryStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LibraryStaff.
     * @param {LibraryStaffUpsertArgs} args - Arguments to update or create a LibraryStaff.
     * @example
     * // Update or create a LibraryStaff
     * const libraryStaff = await prisma.libraryStaff.upsert({
     *   create: {
     *     // ... data to create a LibraryStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryStaff we want to update
     *   }
     * })
     */
    upsert<T extends LibraryStaffUpsertArgs>(args: SelectSubset<T, LibraryStaffUpsertArgs<ExtArgs>>): Prisma__LibraryStaffClient<$Result.GetResult<Prisma.$LibraryStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LibraryStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStaffCountArgs} args - Arguments to filter LibraryStaffs to count.
     * @example
     * // Count the number of LibraryStaffs
     * const count = await prisma.libraryStaff.count({
     *   where: {
     *     // ... the filter for the LibraryStaffs we want to count
     *   }
     * })
    **/
    count<T extends LibraryStaffCountArgs>(
      args?: Subset<T, LibraryStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryStaffAggregateArgs>(args: Subset<T, LibraryStaffAggregateArgs>): Prisma.PrismaPromise<GetLibraryStaffAggregateType<T>>

    /**
     * Group by LibraryStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryStaffGroupByArgs['orderBy'] }
        : { orderBy?: LibraryStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LibraryStaff model
   */
  readonly fields: LibraryStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LibraryStaff model
   */
  interface LibraryStaffFieldRefs {
    readonly id: FieldRef<"LibraryStaff", 'String'>
    readonly userId: FieldRef<"LibraryStaff", 'String'>
    readonly departmentId: FieldRef<"LibraryStaff", 'String'>
    readonly position: FieldRef<"LibraryStaff", 'String'>
    readonly hireDate: FieldRef<"LibraryStaff", 'DateTime'>
    readonly createdAt: FieldRef<"LibraryStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"LibraryStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LibraryStaff findUnique
   */
  export type LibraryStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * Filter, which LibraryStaff to fetch.
     */
    where: LibraryStaffWhereUniqueInput
  }

  /**
   * LibraryStaff findUniqueOrThrow
   */
  export type LibraryStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * Filter, which LibraryStaff to fetch.
     */
    where: LibraryStaffWhereUniqueInput
  }

  /**
   * LibraryStaff findFirst
   */
  export type LibraryStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * Filter, which LibraryStaff to fetch.
     */
    where?: LibraryStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStaffs to fetch.
     */
    orderBy?: LibraryStaffOrderByWithRelationInput | LibraryStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryStaffs.
     */
    cursor?: LibraryStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryStaffs.
     */
    distinct?: LibraryStaffScalarFieldEnum | LibraryStaffScalarFieldEnum[]
  }

  /**
   * LibraryStaff findFirstOrThrow
   */
  export type LibraryStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * Filter, which LibraryStaff to fetch.
     */
    where?: LibraryStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStaffs to fetch.
     */
    orderBy?: LibraryStaffOrderByWithRelationInput | LibraryStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryStaffs.
     */
    cursor?: LibraryStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryStaffs.
     */
    distinct?: LibraryStaffScalarFieldEnum | LibraryStaffScalarFieldEnum[]
  }

  /**
   * LibraryStaff findMany
   */
  export type LibraryStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * Filter, which LibraryStaffs to fetch.
     */
    where?: LibraryStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStaffs to fetch.
     */
    orderBy?: LibraryStaffOrderByWithRelationInput | LibraryStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryStaffs.
     */
    cursor?: LibraryStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStaffs.
     */
    skip?: number
    distinct?: LibraryStaffScalarFieldEnum | LibraryStaffScalarFieldEnum[]
  }

  /**
   * LibraryStaff create
   */
  export type LibraryStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a LibraryStaff.
     */
    data: XOR<LibraryStaffCreateInput, LibraryStaffUncheckedCreateInput>
  }

  /**
   * LibraryStaff createMany
   */
  export type LibraryStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LibraryStaffs.
     */
    data: LibraryStaffCreateManyInput | LibraryStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LibraryStaff createManyAndReturn
   */
  export type LibraryStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * The data used to create many LibraryStaffs.
     */
    data: LibraryStaffCreateManyInput | LibraryStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LibraryStaff update
   */
  export type LibraryStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a LibraryStaff.
     */
    data: XOR<LibraryStaffUpdateInput, LibraryStaffUncheckedUpdateInput>
    /**
     * Choose, which LibraryStaff to update.
     */
    where: LibraryStaffWhereUniqueInput
  }

  /**
   * LibraryStaff updateMany
   */
  export type LibraryStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LibraryStaffs.
     */
    data: XOR<LibraryStaffUpdateManyMutationInput, LibraryStaffUncheckedUpdateManyInput>
    /**
     * Filter which LibraryStaffs to update
     */
    where?: LibraryStaffWhereInput
    /**
     * Limit how many LibraryStaffs to update.
     */
    limit?: number
  }

  /**
   * LibraryStaff updateManyAndReturn
   */
  export type LibraryStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * The data used to update LibraryStaffs.
     */
    data: XOR<LibraryStaffUpdateManyMutationInput, LibraryStaffUncheckedUpdateManyInput>
    /**
     * Filter which LibraryStaffs to update
     */
    where?: LibraryStaffWhereInput
    /**
     * Limit how many LibraryStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LibraryStaff upsert
   */
  export type LibraryStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the LibraryStaff to update in case it exists.
     */
    where: LibraryStaffWhereUniqueInput
    /**
     * In case the LibraryStaff found by the `where` argument doesn't exist, create a new LibraryStaff with this data.
     */
    create: XOR<LibraryStaffCreateInput, LibraryStaffUncheckedCreateInput>
    /**
     * In case the LibraryStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryStaffUpdateInput, LibraryStaffUncheckedUpdateInput>
  }

  /**
   * LibraryStaff delete
   */
  export type LibraryStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
    /**
     * Filter which LibraryStaff to delete.
     */
    where: LibraryStaffWhereUniqueInput
  }

  /**
   * LibraryStaff deleteMany
   */
  export type LibraryStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryStaffs to delete
     */
    where?: LibraryStaffWhereInput
    /**
     * Limit how many LibraryStaffs to delete.
     */
    limit?: number
  }

  /**
   * LibraryStaff without action
   */
  export type LibraryStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryStaff
     */
    select?: LibraryStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryStaff
     */
    omit?: LibraryStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryStaffInclude<ExtArgs> | null
  }


  /**
   * Model AdmissionPayment
   */

  export type AggregateAdmissionPayment = {
    _count: AdmissionPaymentCountAggregateOutputType | null
    _avg: AdmissionPaymentAvgAggregateOutputType | null
    _sum: AdmissionPaymentSumAggregateOutputType | null
    _min: AdmissionPaymentMinAggregateOutputType | null
    _max: AdmissionPaymentMaxAggregateOutputType | null
  }

  export type AdmissionPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type AdmissionPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type AdmissionPaymentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    schoolId: string | null
    amount: number | null
    pinCode: string | null
    used: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionPaymentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    schoolId: string | null
    amount: number | null
    pinCode: string | null
    used: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionPaymentCountAggregateOutputType = {
    id: number
    studentId: number
    schoolId: number
    amount: number
    pinCode: number
    used: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type AdmissionPaymentSumAggregateInputType = {
    amount?: true
  }

  export type AdmissionPaymentMinAggregateInputType = {
    id?: true
    studentId?: true
    schoolId?: true
    amount?: true
    pinCode?: true
    used?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionPaymentMaxAggregateInputType = {
    id?: true
    studentId?: true
    schoolId?: true
    amount?: true
    pinCode?: true
    used?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionPaymentCountAggregateInputType = {
    id?: true
    studentId?: true
    schoolId?: true
    amount?: true
    pinCode?: true
    used?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionPayment to aggregate.
     */
    where?: AdmissionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionPayments to fetch.
     */
    orderBy?: AdmissionPaymentOrderByWithRelationInput | AdmissionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmissionPayments
    **/
    _count?: true | AdmissionPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmissionPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmissionPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionPaymentMaxAggregateInputType
  }

  export type GetAdmissionPaymentAggregateType<T extends AdmissionPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmissionPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmissionPayment[P]>
      : GetScalarType<T[P], AggregateAdmissionPayment[P]>
  }




  export type AdmissionPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionPaymentWhereInput
    orderBy?: AdmissionPaymentOrderByWithAggregationInput | AdmissionPaymentOrderByWithAggregationInput[]
    by: AdmissionPaymentScalarFieldEnum[] | AdmissionPaymentScalarFieldEnum
    having?: AdmissionPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionPaymentCountAggregateInputType | true
    _avg?: AdmissionPaymentAvgAggregateInputType
    _sum?: AdmissionPaymentSumAggregateInputType
    _min?: AdmissionPaymentMinAggregateInputType
    _max?: AdmissionPaymentMaxAggregateInputType
  }

  export type AdmissionPaymentGroupByOutputType = {
    id: string
    studentId: string
    schoolId: string
    amount: number
    pinCode: string
    used: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdmissionPaymentCountAggregateOutputType | null
    _avg: AdmissionPaymentAvgAggregateOutputType | null
    _sum: AdmissionPaymentSumAggregateOutputType | null
    _min: AdmissionPaymentMinAggregateOutputType | null
    _max: AdmissionPaymentMaxAggregateOutputType | null
  }

  type GetAdmissionPaymentGroupByPayload<T extends AdmissionPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionPaymentGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    schoolId?: boolean
    amount?: boolean
    pinCode?: boolean
    used?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Application?: boolean | AdmissionPayment$ApplicationArgs<ExtArgs>
    _count?: boolean | AdmissionPaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionPayment"]>

  export type AdmissionPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    schoolId?: boolean
    amount?: boolean
    pinCode?: boolean
    used?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admissionPayment"]>

  export type AdmissionPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    schoolId?: boolean
    amount?: boolean
    pinCode?: boolean
    used?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admissionPayment"]>

  export type AdmissionPaymentSelectScalar = {
    id?: boolean
    studentId?: boolean
    schoolId?: boolean
    amount?: boolean
    pinCode?: boolean
    used?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmissionPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "schoolId" | "amount" | "pinCode" | "used" | "createdAt" | "updatedAt", ExtArgs["result"]["admissionPayment"]>
  export type AdmissionPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | AdmissionPayment$ApplicationArgs<ExtArgs>
    _count?: boolean | AdmissionPaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdmissionPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdmissionPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdmissionPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmissionPayment"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      schoolId: string
      amount: number
      pinCode: string
      used: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admissionPayment"]>
    composites: {}
  }

  type AdmissionPaymentGetPayload<S extends boolean | null | undefined | AdmissionPaymentDefaultArgs> = $Result.GetResult<Prisma.$AdmissionPaymentPayload, S>

  type AdmissionPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdmissionPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmissionPaymentCountAggregateInputType | true
    }

  export interface AdmissionPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmissionPayment'], meta: { name: 'AdmissionPayment' } }
    /**
     * Find zero or one AdmissionPayment that matches the filter.
     * @param {AdmissionPaymentFindUniqueArgs} args - Arguments to find a AdmissionPayment
     * @example
     * // Get one AdmissionPayment
     * const admissionPayment = await prisma.admissionPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionPaymentFindUniqueArgs>(args: SelectSubset<T, AdmissionPaymentFindUniqueArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdmissionPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdmissionPaymentFindUniqueOrThrowArgs} args - Arguments to find a AdmissionPayment
     * @example
     * // Get one AdmissionPayment
     * const admissionPayment = await prisma.admissionPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmissionPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionPaymentFindFirstArgs} args - Arguments to find a AdmissionPayment
     * @example
     * // Get one AdmissionPayment
     * const admissionPayment = await prisma.admissionPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionPaymentFindFirstArgs>(args?: SelectSubset<T, AdmissionPaymentFindFirstArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmissionPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionPaymentFindFirstOrThrowArgs} args - Arguments to find a AdmissionPayment
     * @example
     * // Get one AdmissionPayment
     * const admissionPayment = await prisma.admissionPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdmissionPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmissionPayments
     * const admissionPayments = await prisma.admissionPayment.findMany()
     * 
     * // Get first 10 AdmissionPayments
     * const admissionPayments = await prisma.admissionPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionPaymentWithIdOnly = await prisma.admissionPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionPaymentFindManyArgs>(args?: SelectSubset<T, AdmissionPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdmissionPayment.
     * @param {AdmissionPaymentCreateArgs} args - Arguments to create a AdmissionPayment.
     * @example
     * // Create one AdmissionPayment
     * const AdmissionPayment = await prisma.admissionPayment.create({
     *   data: {
     *     // ... data to create a AdmissionPayment
     *   }
     * })
     * 
     */
    create<T extends AdmissionPaymentCreateArgs>(args: SelectSubset<T, AdmissionPaymentCreateArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdmissionPayments.
     * @param {AdmissionPaymentCreateManyArgs} args - Arguments to create many AdmissionPayments.
     * @example
     * // Create many AdmissionPayments
     * const admissionPayment = await prisma.admissionPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionPaymentCreateManyArgs>(args?: SelectSubset<T, AdmissionPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdmissionPayments and returns the data saved in the database.
     * @param {AdmissionPaymentCreateManyAndReturnArgs} args - Arguments to create many AdmissionPayments.
     * @example
     * // Create many AdmissionPayments
     * const admissionPayment = await prisma.admissionPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdmissionPayments and only return the `id`
     * const admissionPaymentWithIdOnly = await prisma.admissionPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdmissionPayment.
     * @param {AdmissionPaymentDeleteArgs} args - Arguments to delete one AdmissionPayment.
     * @example
     * // Delete one AdmissionPayment
     * const AdmissionPayment = await prisma.admissionPayment.delete({
     *   where: {
     *     // ... filter to delete one AdmissionPayment
     *   }
     * })
     * 
     */
    delete<T extends AdmissionPaymentDeleteArgs>(args: SelectSubset<T, AdmissionPaymentDeleteArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdmissionPayment.
     * @param {AdmissionPaymentUpdateArgs} args - Arguments to update one AdmissionPayment.
     * @example
     * // Update one AdmissionPayment
     * const admissionPayment = await prisma.admissionPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionPaymentUpdateArgs>(args: SelectSubset<T, AdmissionPaymentUpdateArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdmissionPayments.
     * @param {AdmissionPaymentDeleteManyArgs} args - Arguments to filter AdmissionPayments to delete.
     * @example
     * // Delete a few AdmissionPayments
     * const { count } = await prisma.admissionPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionPaymentDeleteManyArgs>(args?: SelectSubset<T, AdmissionPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmissionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmissionPayments
     * const admissionPayment = await prisma.admissionPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionPaymentUpdateManyArgs>(args: SelectSubset<T, AdmissionPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmissionPayments and returns the data updated in the database.
     * @param {AdmissionPaymentUpdateManyAndReturnArgs} args - Arguments to update many AdmissionPayments.
     * @example
     * // Update many AdmissionPayments
     * const admissionPayment = await prisma.admissionPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdmissionPayments and only return the `id`
     * const admissionPaymentWithIdOnly = await prisma.admissionPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdmissionPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, AdmissionPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdmissionPayment.
     * @param {AdmissionPaymentUpsertArgs} args - Arguments to update or create a AdmissionPayment.
     * @example
     * // Update or create a AdmissionPayment
     * const admissionPayment = await prisma.admissionPayment.upsert({
     *   create: {
     *     // ... data to create a AdmissionPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmissionPayment we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionPaymentUpsertArgs>(args: SelectSubset<T, AdmissionPaymentUpsertArgs<ExtArgs>>): Prisma__AdmissionPaymentClient<$Result.GetResult<Prisma.$AdmissionPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdmissionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionPaymentCountArgs} args - Arguments to filter AdmissionPayments to count.
     * @example
     * // Count the number of AdmissionPayments
     * const count = await prisma.admissionPayment.count({
     *   where: {
     *     // ... the filter for the AdmissionPayments we want to count
     *   }
     * })
    **/
    count<T extends AdmissionPaymentCountArgs>(
      args?: Subset<T, AdmissionPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmissionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionPaymentAggregateArgs>(args: Subset<T, AdmissionPaymentAggregateArgs>): Prisma.PrismaPromise<GetAdmissionPaymentAggregateType<T>>

    /**
     * Group by AdmissionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionPaymentGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmissionPayment model
   */
  readonly fields: AdmissionPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmissionPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends AdmissionPayment$ApplicationArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionPayment$ApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmissionPayment model
   */
  interface AdmissionPaymentFieldRefs {
    readonly id: FieldRef<"AdmissionPayment", 'String'>
    readonly studentId: FieldRef<"AdmissionPayment", 'String'>
    readonly schoolId: FieldRef<"AdmissionPayment", 'String'>
    readonly amount: FieldRef<"AdmissionPayment", 'Float'>
    readonly pinCode: FieldRef<"AdmissionPayment", 'String'>
    readonly used: FieldRef<"AdmissionPayment", 'Boolean'>
    readonly createdAt: FieldRef<"AdmissionPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"AdmissionPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdmissionPayment findUnique
   */
  export type AdmissionPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionPayment to fetch.
     */
    where: AdmissionPaymentWhereUniqueInput
  }

  /**
   * AdmissionPayment findUniqueOrThrow
   */
  export type AdmissionPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionPayment to fetch.
     */
    where: AdmissionPaymentWhereUniqueInput
  }

  /**
   * AdmissionPayment findFirst
   */
  export type AdmissionPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionPayment to fetch.
     */
    where?: AdmissionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionPayments to fetch.
     */
    orderBy?: AdmissionPaymentOrderByWithRelationInput | AdmissionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionPayments.
     */
    cursor?: AdmissionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionPayments.
     */
    distinct?: AdmissionPaymentScalarFieldEnum | AdmissionPaymentScalarFieldEnum[]
  }

  /**
   * AdmissionPayment findFirstOrThrow
   */
  export type AdmissionPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionPayment to fetch.
     */
    where?: AdmissionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionPayments to fetch.
     */
    orderBy?: AdmissionPaymentOrderByWithRelationInput | AdmissionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionPayments.
     */
    cursor?: AdmissionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionPayments.
     */
    distinct?: AdmissionPaymentScalarFieldEnum | AdmissionPaymentScalarFieldEnum[]
  }

  /**
   * AdmissionPayment findMany
   */
  export type AdmissionPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionPayments to fetch.
     */
    where?: AdmissionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionPayments to fetch.
     */
    orderBy?: AdmissionPaymentOrderByWithRelationInput | AdmissionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmissionPayments.
     */
    cursor?: AdmissionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionPayments.
     */
    skip?: number
    distinct?: AdmissionPaymentScalarFieldEnum | AdmissionPaymentScalarFieldEnum[]
  }

  /**
   * AdmissionPayment create
   */
  export type AdmissionPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmissionPayment.
     */
    data: XOR<AdmissionPaymentCreateInput, AdmissionPaymentUncheckedCreateInput>
  }

  /**
   * AdmissionPayment createMany
   */
  export type AdmissionPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmissionPayments.
     */
    data: AdmissionPaymentCreateManyInput | AdmissionPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmissionPayment createManyAndReturn
   */
  export type AdmissionPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many AdmissionPayments.
     */
    data: AdmissionPaymentCreateManyInput | AdmissionPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmissionPayment update
   */
  export type AdmissionPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmissionPayment.
     */
    data: XOR<AdmissionPaymentUpdateInput, AdmissionPaymentUncheckedUpdateInput>
    /**
     * Choose, which AdmissionPayment to update.
     */
    where: AdmissionPaymentWhereUniqueInput
  }

  /**
   * AdmissionPayment updateMany
   */
  export type AdmissionPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmissionPayments.
     */
    data: XOR<AdmissionPaymentUpdateManyMutationInput, AdmissionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which AdmissionPayments to update
     */
    where?: AdmissionPaymentWhereInput
    /**
     * Limit how many AdmissionPayments to update.
     */
    limit?: number
  }

  /**
   * AdmissionPayment updateManyAndReturn
   */
  export type AdmissionPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * The data used to update AdmissionPayments.
     */
    data: XOR<AdmissionPaymentUpdateManyMutationInput, AdmissionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which AdmissionPayments to update
     */
    where?: AdmissionPaymentWhereInput
    /**
     * Limit how many AdmissionPayments to update.
     */
    limit?: number
  }

  /**
   * AdmissionPayment upsert
   */
  export type AdmissionPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmissionPayment to update in case it exists.
     */
    where: AdmissionPaymentWhereUniqueInput
    /**
     * In case the AdmissionPayment found by the `where` argument doesn't exist, create a new AdmissionPayment with this data.
     */
    create: XOR<AdmissionPaymentCreateInput, AdmissionPaymentUncheckedCreateInput>
    /**
     * In case the AdmissionPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionPaymentUpdateInput, AdmissionPaymentUncheckedUpdateInput>
  }

  /**
   * AdmissionPayment delete
   */
  export type AdmissionPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
    /**
     * Filter which AdmissionPayment to delete.
     */
    where: AdmissionPaymentWhereUniqueInput
  }

  /**
   * AdmissionPayment deleteMany
   */
  export type AdmissionPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionPayments to delete
     */
    where?: AdmissionPaymentWhereInput
    /**
     * Limit how many AdmissionPayments to delete.
     */
    limit?: number
  }

  /**
   * AdmissionPayment.Application
   */
  export type AdmissionPayment$ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * AdmissionPayment without action
   */
  export type AdmissionPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionPayment
     */
    select?: AdmissionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmissionPayment
     */
    omit?: AdmissionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    type: $Enums.FinanceType | null
    feeType: $Enums.FeeType | null
    amount: number | null
    date: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    type: $Enums.FinanceType | null
    feeType: $Enums.FeeType | null
    amount: number | null
    date: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    studentId: number
    type: number
    feeType: number
    amount: number
    date: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    feeType?: true
    amount?: true
    date?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    feeType?: true
    amount?: true
    date?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    feeType?: true
    amount?: true
    date?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    studentId: string
    type: $Enums.FinanceType
    feeType: $Enums.FeeType | null
    amount: number
    date: Date
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    feeType?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    feeType?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    feeType?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    studentId?: boolean
    type?: boolean
    feeType?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "type" | "feeType" | "amount" | "date" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      type: $Enums.FinanceType
      feeType: $Enums.FeeType | null
      amount: number
      date: Date
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly studentId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'FinanceType'>
    readonly feeType: FieldRef<"Transaction", 'FeeType'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Finance
   */

  export type AggregateFinance = {
    _count: FinanceCountAggregateOutputType | null
    _avg: FinanceAvgAggregateOutputType | null
    _sum: FinanceSumAggregateOutputType | null
    _min: FinanceMinAggregateOutputType | null
    _max: FinanceMaxAggregateOutputType | null
  }

  export type FinanceAvgAggregateOutputType = {
    amount: number | null
  }

  export type FinanceSumAggregateOutputType = {
    amount: number | null
  }

  export type FinanceMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    type: $Enums.FinanceType | null
    amount: number | null
    description: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinanceMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    type: $Enums.FinanceType | null
    amount: number | null
    description: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinanceCountAggregateOutputType = {
    id: number
    schoolId: number
    type: number
    amount: number
    description: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinanceAvgAggregateInputType = {
    amount?: true
  }

  export type FinanceSumAggregateInputType = {
    amount?: true
  }

  export type FinanceMinAggregateInputType = {
    id?: true
    schoolId?: true
    type?: true
    amount?: true
    description?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinanceMaxAggregateInputType = {
    id?: true
    schoolId?: true
    type?: true
    amount?: true
    description?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinanceCountAggregateInputType = {
    id?: true
    schoolId?: true
    type?: true
    amount?: true
    description?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Finance to aggregate.
     */
    where?: FinanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Finances to fetch.
     */
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Finances
    **/
    _count?: true | FinanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinanceMaxAggregateInputType
  }

  export type GetFinanceAggregateType<T extends FinanceAggregateArgs> = {
        [P in keyof T & keyof AggregateFinance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinance[P]>
      : GetScalarType<T[P], AggregateFinance[P]>
  }




  export type FinanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinanceWhereInput
    orderBy?: FinanceOrderByWithAggregationInput | FinanceOrderByWithAggregationInput[]
    by: FinanceScalarFieldEnum[] | FinanceScalarFieldEnum
    having?: FinanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinanceCountAggregateInputType | true
    _avg?: FinanceAvgAggregateInputType
    _sum?: FinanceSumAggregateInputType
    _min?: FinanceMinAggregateInputType
    _max?: FinanceMaxAggregateInputType
  }

  export type FinanceGroupByOutputType = {
    id: string
    schoolId: string
    type: $Enums.FinanceType
    amount: number
    description: string | null
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: FinanceCountAggregateOutputType | null
    _avg: FinanceAvgAggregateOutputType | null
    _sum: FinanceSumAggregateOutputType | null
    _min: FinanceMinAggregateOutputType | null
    _max: FinanceMaxAggregateOutputType | null
  }

  type GetFinanceGroupByPayload<T extends FinanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinanceGroupByOutputType[P]>
            : GetScalarType<T[P], FinanceGroupByOutputType[P]>
        }
      >
    >


  export type FinanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finance"]>

  export type FinanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finance"]>

  export type FinanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finance"]>

  export type FinanceSelectScalar = {
    id?: boolean
    schoolId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FinanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "type" | "amount" | "description" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["finance"]>
  export type FinanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type FinanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type FinanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $FinancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Finance"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      type: $Enums.FinanceType
      amount: number
      description: string | null
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["finance"]>
    composites: {}
  }

  type FinanceGetPayload<S extends boolean | null | undefined | FinanceDefaultArgs> = $Result.GetResult<Prisma.$FinancePayload, S>

  type FinanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinanceCountAggregateInputType | true
    }

  export interface FinanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Finance'], meta: { name: 'Finance' } }
    /**
     * Find zero or one Finance that matches the filter.
     * @param {FinanceFindUniqueArgs} args - Arguments to find a Finance
     * @example
     * // Get one Finance
     * const finance = await prisma.finance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinanceFindUniqueArgs>(args: SelectSubset<T, FinanceFindUniqueArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Finance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinanceFindUniqueOrThrowArgs} args - Arguments to find a Finance
     * @example
     * // Get one Finance
     * const finance = await prisma.finance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinanceFindUniqueOrThrowArgs>(args: SelectSubset<T, FinanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Finance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceFindFirstArgs} args - Arguments to find a Finance
     * @example
     * // Get one Finance
     * const finance = await prisma.finance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinanceFindFirstArgs>(args?: SelectSubset<T, FinanceFindFirstArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Finance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceFindFirstOrThrowArgs} args - Arguments to find a Finance
     * @example
     * // Get one Finance
     * const finance = await prisma.finance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinanceFindFirstOrThrowArgs>(args?: SelectSubset<T, FinanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Finances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Finances
     * const finances = await prisma.finance.findMany()
     * 
     * // Get first 10 Finances
     * const finances = await prisma.finance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financeWithIdOnly = await prisma.finance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinanceFindManyArgs>(args?: SelectSubset<T, FinanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Finance.
     * @param {FinanceCreateArgs} args - Arguments to create a Finance.
     * @example
     * // Create one Finance
     * const Finance = await prisma.finance.create({
     *   data: {
     *     // ... data to create a Finance
     *   }
     * })
     * 
     */
    create<T extends FinanceCreateArgs>(args: SelectSubset<T, FinanceCreateArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Finances.
     * @param {FinanceCreateManyArgs} args - Arguments to create many Finances.
     * @example
     * // Create many Finances
     * const finance = await prisma.finance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinanceCreateManyArgs>(args?: SelectSubset<T, FinanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Finances and returns the data saved in the database.
     * @param {FinanceCreateManyAndReturnArgs} args - Arguments to create many Finances.
     * @example
     * // Create many Finances
     * const finance = await prisma.finance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Finances and only return the `id`
     * const financeWithIdOnly = await prisma.finance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinanceCreateManyAndReturnArgs>(args?: SelectSubset<T, FinanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Finance.
     * @param {FinanceDeleteArgs} args - Arguments to delete one Finance.
     * @example
     * // Delete one Finance
     * const Finance = await prisma.finance.delete({
     *   where: {
     *     // ... filter to delete one Finance
     *   }
     * })
     * 
     */
    delete<T extends FinanceDeleteArgs>(args: SelectSubset<T, FinanceDeleteArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Finance.
     * @param {FinanceUpdateArgs} args - Arguments to update one Finance.
     * @example
     * // Update one Finance
     * const finance = await prisma.finance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinanceUpdateArgs>(args: SelectSubset<T, FinanceUpdateArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Finances.
     * @param {FinanceDeleteManyArgs} args - Arguments to filter Finances to delete.
     * @example
     * // Delete a few Finances
     * const { count } = await prisma.finance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinanceDeleteManyArgs>(args?: SelectSubset<T, FinanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Finances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Finances
     * const finance = await prisma.finance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinanceUpdateManyArgs>(args: SelectSubset<T, FinanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Finances and returns the data updated in the database.
     * @param {FinanceUpdateManyAndReturnArgs} args - Arguments to update many Finances.
     * @example
     * // Update many Finances
     * const finance = await prisma.finance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Finances and only return the `id`
     * const financeWithIdOnly = await prisma.finance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinanceUpdateManyAndReturnArgs>(args: SelectSubset<T, FinanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Finance.
     * @param {FinanceUpsertArgs} args - Arguments to update or create a Finance.
     * @example
     * // Update or create a Finance
     * const finance = await prisma.finance.upsert({
     *   create: {
     *     // ... data to create a Finance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Finance we want to update
     *   }
     * })
     */
    upsert<T extends FinanceUpsertArgs>(args: SelectSubset<T, FinanceUpsertArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Finances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceCountArgs} args - Arguments to filter Finances to count.
     * @example
     * // Count the number of Finances
     * const count = await prisma.finance.count({
     *   where: {
     *     // ... the filter for the Finances we want to count
     *   }
     * })
    **/
    count<T extends FinanceCountArgs>(
      args?: Subset<T, FinanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Finance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinanceAggregateArgs>(args: Subset<T, FinanceAggregateArgs>): Prisma.PrismaPromise<GetFinanceAggregateType<T>>

    /**
     * Group by Finance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinanceGroupByArgs['orderBy'] }
        : { orderBy?: FinanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Finance model
   */
  readonly fields: FinanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Finance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Finance model
   */
  interface FinanceFieldRefs {
    readonly id: FieldRef<"Finance", 'String'>
    readonly schoolId: FieldRef<"Finance", 'String'>
    readonly type: FieldRef<"Finance", 'FinanceType'>
    readonly amount: FieldRef<"Finance", 'Float'>
    readonly description: FieldRef<"Finance", 'String'>
    readonly date: FieldRef<"Finance", 'DateTime'>
    readonly createdAt: FieldRef<"Finance", 'DateTime'>
    readonly updatedAt: FieldRef<"Finance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Finance findUnique
   */
  export type FinanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finance to fetch.
     */
    where: FinanceWhereUniqueInput
  }

  /**
   * Finance findUniqueOrThrow
   */
  export type FinanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finance to fetch.
     */
    where: FinanceWhereUniqueInput
  }

  /**
   * Finance findFirst
   */
  export type FinanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finance to fetch.
     */
    where?: FinanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Finances to fetch.
     */
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Finances.
     */
    cursor?: FinanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Finances.
     */
    distinct?: FinanceScalarFieldEnum | FinanceScalarFieldEnum[]
  }

  /**
   * Finance findFirstOrThrow
   */
  export type FinanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finance to fetch.
     */
    where?: FinanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Finances to fetch.
     */
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Finances.
     */
    cursor?: FinanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Finances.
     */
    distinct?: FinanceScalarFieldEnum | FinanceScalarFieldEnum[]
  }

  /**
   * Finance findMany
   */
  export type FinanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finances to fetch.
     */
    where?: FinanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Finances to fetch.
     */
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Finances.
     */
    cursor?: FinanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Finances.
     */
    skip?: number
    distinct?: FinanceScalarFieldEnum | FinanceScalarFieldEnum[]
  }

  /**
   * Finance create
   */
  export type FinanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Finance.
     */
    data: XOR<FinanceCreateInput, FinanceUncheckedCreateInput>
  }

  /**
   * Finance createMany
   */
  export type FinanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Finances.
     */
    data: FinanceCreateManyInput | FinanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Finance createManyAndReturn
   */
  export type FinanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * The data used to create many Finances.
     */
    data: FinanceCreateManyInput | FinanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Finance update
   */
  export type FinanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Finance.
     */
    data: XOR<FinanceUpdateInput, FinanceUncheckedUpdateInput>
    /**
     * Choose, which Finance to update.
     */
    where: FinanceWhereUniqueInput
  }

  /**
   * Finance updateMany
   */
  export type FinanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Finances.
     */
    data: XOR<FinanceUpdateManyMutationInput, FinanceUncheckedUpdateManyInput>
    /**
     * Filter which Finances to update
     */
    where?: FinanceWhereInput
    /**
     * Limit how many Finances to update.
     */
    limit?: number
  }

  /**
   * Finance updateManyAndReturn
   */
  export type FinanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * The data used to update Finances.
     */
    data: XOR<FinanceUpdateManyMutationInput, FinanceUncheckedUpdateManyInput>
    /**
     * Filter which Finances to update
     */
    where?: FinanceWhereInput
    /**
     * Limit how many Finances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Finance upsert
   */
  export type FinanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Finance to update in case it exists.
     */
    where: FinanceWhereUniqueInput
    /**
     * In case the Finance found by the `where` argument doesn't exist, create a new Finance with this data.
     */
    create: XOR<FinanceCreateInput, FinanceUncheckedCreateInput>
    /**
     * In case the Finance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinanceUpdateInput, FinanceUncheckedUpdateInput>
  }

  /**
   * Finance delete
   */
  export type FinanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter which Finance to delete.
     */
    where: FinanceWhereUniqueInput
  }

  /**
   * Finance deleteMany
   */
  export type FinanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Finances to delete
     */
    where?: FinanceWhereInput
    /**
     * Limit how many Finances to delete.
     */
    limit?: number
  }

  /**
   * Finance without action
   */
  export type FinanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    unitPrice: number | null
    quantity: number | null
  }

  export type ResourceSumAggregateOutputType = {
    unitPrice: number | null
    quantity: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    unitPrice: number | null
    quantity: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    unitPrice: number | null
    quantity: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    name: number
    category: number
    unitPrice: number
    quantity: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    unitPrice?: true
    quantity?: true
  }

  export type ResourceSumAggregateInputType = {
    unitPrice?: true
    quantity?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unitPrice?: true
    quantity?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unitPrice?: true
    quantity?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unitPrice?: true
    quantity?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    name: string
    category: string | null
    unitPrice: number
    quantity: number
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unitPrice?: boolean
    quantity?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    purchases?: boolean | Resource$purchasesArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unitPrice?: boolean
    quantity?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unitPrice?: boolean
    quantity?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    unitPrice?: boolean
    quantity?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "unitPrice" | "quantity" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    purchases?: boolean | Resource$purchasesArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      unitPrice: number
      quantity: number
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchases<T extends Resource$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Resource$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly name: FieldRef<"Resource", 'String'>
    readonly category: FieldRef<"Resource", 'String'>
    readonly unitPrice: FieldRef<"Resource", 'Float'>
    readonly quantity: FieldRef<"Resource", 'Int'>
    readonly schoolId: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource.purchases
   */
  export type Resource$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    quantity: number | null
    totalCost: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    quantity: number | null
    totalCost: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    resourceId: string | null
    quantity: number | null
    totalCost: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    resourceId: string | null
    quantity: number | null
    totalCost: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    studentId: number
    resourceId: number
    quantity: number
    totalCost: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    quantity?: true
    totalCost?: true
  }

  export type PurchaseSumAggregateInputType = {
    quantity?: true
    totalCost?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    studentId?: true
    resourceId?: true
    quantity?: true
    totalCost?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    studentId?: true
    resourceId?: true
    quantity?: true
    totalCost?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    studentId?: true
    resourceId?: true
    quantity?: true
    totalCost?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    studentId: string
    resourceId: string
    quantity: number
    totalCost: number
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    resourceId?: boolean
    quantity?: boolean
    totalCost?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    resourceId?: boolean
    quantity?: boolean
    totalCost?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    resourceId?: boolean
    quantity?: boolean
    totalCost?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    studentId?: boolean
    resourceId?: boolean
    quantity?: boolean
    totalCost?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "resourceId" | "quantity" | "totalCost" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      resourceId: string
      quantity: number
      totalCost: number
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchaseUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly studentId: FieldRef<"Purchase", 'String'>
    readonly resourceId: FieldRef<"Purchase", 'String'>
    readonly quantity: FieldRef<"Purchase", 'Int'>
    readonly totalCost: FieldRef<"Purchase", 'Float'>
    readonly date: FieldRef<"Purchase", 'DateTime'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase updateManyAndReturn
   */
  export type PurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    title: number
    description: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    title: string
    description: string | null
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly schoolId: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Bus
   */

  export type AggregateBus = {
    _count: BusCountAggregateOutputType | null
    _avg: BusAvgAggregateOutputType | null
    _sum: BusSumAggregateOutputType | null
    _min: BusMinAggregateOutputType | null
    _max: BusMaxAggregateOutputType | null
  }

  export type BusAvgAggregateOutputType = {
    capacity: number | null
  }

  export type BusSumAggregateOutputType = {
    capacity: number | null
  }

  export type BusMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    plateNumber: string | null
    driverName: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    plateNumber: string | null
    driverName: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusCountAggregateOutputType = {
    id: number
    schoolId: number
    plateNumber: number
    driverName: number
    capacity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusAvgAggregateInputType = {
    capacity?: true
  }

  export type BusSumAggregateInputType = {
    capacity?: true
  }

  export type BusMinAggregateInputType = {
    id?: true
    schoolId?: true
    plateNumber?: true
    driverName?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusMaxAggregateInputType = {
    id?: true
    schoolId?: true
    plateNumber?: true
    driverName?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusCountAggregateInputType = {
    id?: true
    schoolId?: true
    plateNumber?: true
    driverName?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bus to aggregate.
     */
    where?: BusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buses to fetch.
     */
    orderBy?: BusOrderByWithRelationInput | BusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buses
    **/
    _count?: true | BusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusMaxAggregateInputType
  }

  export type GetBusAggregateType<T extends BusAggregateArgs> = {
        [P in keyof T & keyof AggregateBus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBus[P]>
      : GetScalarType<T[P], AggregateBus[P]>
  }




  export type BusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusWhereInput
    orderBy?: BusOrderByWithAggregationInput | BusOrderByWithAggregationInput[]
    by: BusScalarFieldEnum[] | BusScalarFieldEnum
    having?: BusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusCountAggregateInputType | true
    _avg?: BusAvgAggregateInputType
    _sum?: BusSumAggregateInputType
    _min?: BusMinAggregateInputType
    _max?: BusMaxAggregateInputType
  }

  export type BusGroupByOutputType = {
    id: string
    schoolId: string
    plateNumber: string
    driverName: string
    capacity: number
    createdAt: Date
    updatedAt: Date
    _count: BusCountAggregateOutputType | null
    _avg: BusAvgAggregateOutputType | null
    _sum: BusSumAggregateOutputType | null
    _min: BusMinAggregateOutputType | null
    _max: BusMaxAggregateOutputType | null
  }

  type GetBusGroupByPayload<T extends BusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusGroupByOutputType[P]>
            : GetScalarType<T[P], BusGroupByOutputType[P]>
        }
      >
    >


  export type BusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    plateNumber?: boolean
    driverName?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bus"]>

  export type BusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    plateNumber?: boolean
    driverName?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bus"]>

  export type BusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    plateNumber?: boolean
    driverName?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bus"]>

  export type BusSelectScalar = {
    id?: boolean
    schoolId?: boolean
    plateNumber?: boolean
    driverName?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "plateNumber" | "driverName" | "capacity" | "createdAt" | "updatedAt", ExtArgs["result"]["bus"]>
  export type BusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type BusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type BusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $BusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bus"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      plateNumber: string
      driverName: string
      capacity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bus"]>
    composites: {}
  }

  type BusGetPayload<S extends boolean | null | undefined | BusDefaultArgs> = $Result.GetResult<Prisma.$BusPayload, S>

  type BusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusCountAggregateInputType | true
    }

  export interface BusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bus'], meta: { name: 'Bus' } }
    /**
     * Find zero or one Bus that matches the filter.
     * @param {BusFindUniqueArgs} args - Arguments to find a Bus
     * @example
     * // Get one Bus
     * const bus = await prisma.bus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusFindUniqueArgs>(args: SelectSubset<T, BusFindUniqueArgs<ExtArgs>>): Prisma__BusClient<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusFindUniqueOrThrowArgs} args - Arguments to find a Bus
     * @example
     * // Get one Bus
     * const bus = await prisma.bus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusFindUniqueOrThrowArgs>(args: SelectSubset<T, BusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusClient<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusFindFirstArgs} args - Arguments to find a Bus
     * @example
     * // Get one Bus
     * const bus = await prisma.bus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusFindFirstArgs>(args?: SelectSubset<T, BusFindFirstArgs<ExtArgs>>): Prisma__BusClient<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusFindFirstOrThrowArgs} args - Arguments to find a Bus
     * @example
     * // Get one Bus
     * const bus = await prisma.bus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusFindFirstOrThrowArgs>(args?: SelectSubset<T, BusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusClient<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buses
     * const buses = await prisma.bus.findMany()
     * 
     * // Get first 10 Buses
     * const buses = await prisma.bus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const busWithIdOnly = await prisma.bus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusFindManyArgs>(args?: SelectSubset<T, BusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bus.
     * @param {BusCreateArgs} args - Arguments to create a Bus.
     * @example
     * // Create one Bus
     * const Bus = await prisma.bus.create({
     *   data: {
     *     // ... data to create a Bus
     *   }
     * })
     * 
     */
    create<T extends BusCreateArgs>(args: SelectSubset<T, BusCreateArgs<ExtArgs>>): Prisma__BusClient<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Buses.
     * @param {BusCreateManyArgs} args - Arguments to create many Buses.
     * @example
     * // Create many Buses
     * const bus = await prisma.bus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusCreateManyArgs>(args?: SelectSubset<T, BusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Buses and returns the data saved in the database.
     * @param {BusCreateManyAndReturnArgs} args - Arguments to create many Buses.
     * @example
     * // Create many Buses
     * const bus = await prisma.bus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Buses and only return the `id`
     * const busWithIdOnly = await prisma.bus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusCreateManyAndReturnArgs>(args?: SelectSubset<T, BusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bus.
     * @param {BusDeleteArgs} args - Arguments to delete one Bus.
     * @example
     * // Delete one Bus
     * const Bus = await prisma.bus.delete({
     *   where: {
     *     // ... filter to delete one Bus
     *   }
     * })
     * 
     */
    delete<T extends BusDeleteArgs>(args: SelectSubset<T, BusDeleteArgs<ExtArgs>>): Prisma__BusClient<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bus.
     * @param {BusUpdateArgs} args - Arguments to update one Bus.
     * @example
     * // Update one Bus
     * const bus = await prisma.bus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusUpdateArgs>(args: SelectSubset<T, BusUpdateArgs<ExtArgs>>): Prisma__BusClient<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Buses.
     * @param {BusDeleteManyArgs} args - Arguments to filter Buses to delete.
     * @example
     * // Delete a few Buses
     * const { count } = await prisma.bus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusDeleteManyArgs>(args?: SelectSubset<T, BusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buses
     * const bus = await prisma.bus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusUpdateManyArgs>(args: SelectSubset<T, BusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buses and returns the data updated in the database.
     * @param {BusUpdateManyAndReturnArgs} args - Arguments to update many Buses.
     * @example
     * // Update many Buses
     * const bus = await prisma.bus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Buses and only return the `id`
     * const busWithIdOnly = await prisma.bus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusUpdateManyAndReturnArgs>(args: SelectSubset<T, BusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bus.
     * @param {BusUpsertArgs} args - Arguments to update or create a Bus.
     * @example
     * // Update or create a Bus
     * const bus = await prisma.bus.upsert({
     *   create: {
     *     // ... data to create a Bus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bus we want to update
     *   }
     * })
     */
    upsert<T extends BusUpsertArgs>(args: SelectSubset<T, BusUpsertArgs<ExtArgs>>): Prisma__BusClient<$Result.GetResult<Prisma.$BusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Buses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusCountArgs} args - Arguments to filter Buses to count.
     * @example
     * // Count the number of Buses
     * const count = await prisma.bus.count({
     *   where: {
     *     // ... the filter for the Buses we want to count
     *   }
     * })
    **/
    count<T extends BusCountArgs>(
      args?: Subset<T, BusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusAggregateArgs>(args: Subset<T, BusAggregateArgs>): Prisma.PrismaPromise<GetBusAggregateType<T>>

    /**
     * Group by Bus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusGroupByArgs['orderBy'] }
        : { orderBy?: BusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bus model
   */
  readonly fields: BusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bus model
   */
  interface BusFieldRefs {
    readonly id: FieldRef<"Bus", 'String'>
    readonly schoolId: FieldRef<"Bus", 'String'>
    readonly plateNumber: FieldRef<"Bus", 'String'>
    readonly driverName: FieldRef<"Bus", 'String'>
    readonly capacity: FieldRef<"Bus", 'Int'>
    readonly createdAt: FieldRef<"Bus", 'DateTime'>
    readonly updatedAt: FieldRef<"Bus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bus findUnique
   */
  export type BusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * Filter, which Bus to fetch.
     */
    where: BusWhereUniqueInput
  }

  /**
   * Bus findUniqueOrThrow
   */
  export type BusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * Filter, which Bus to fetch.
     */
    where: BusWhereUniqueInput
  }

  /**
   * Bus findFirst
   */
  export type BusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * Filter, which Bus to fetch.
     */
    where?: BusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buses to fetch.
     */
    orderBy?: BusOrderByWithRelationInput | BusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buses.
     */
    cursor?: BusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buses.
     */
    distinct?: BusScalarFieldEnum | BusScalarFieldEnum[]
  }

  /**
   * Bus findFirstOrThrow
   */
  export type BusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * Filter, which Bus to fetch.
     */
    where?: BusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buses to fetch.
     */
    orderBy?: BusOrderByWithRelationInput | BusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buses.
     */
    cursor?: BusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buses.
     */
    distinct?: BusScalarFieldEnum | BusScalarFieldEnum[]
  }

  /**
   * Bus findMany
   */
  export type BusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * Filter, which Buses to fetch.
     */
    where?: BusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buses to fetch.
     */
    orderBy?: BusOrderByWithRelationInput | BusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buses.
     */
    cursor?: BusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buses.
     */
    skip?: number
    distinct?: BusScalarFieldEnum | BusScalarFieldEnum[]
  }

  /**
   * Bus create
   */
  export type BusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * The data needed to create a Bus.
     */
    data: XOR<BusCreateInput, BusUncheckedCreateInput>
  }

  /**
   * Bus createMany
   */
  export type BusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buses.
     */
    data: BusCreateManyInput | BusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bus createManyAndReturn
   */
  export type BusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * The data used to create many Buses.
     */
    data: BusCreateManyInput | BusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bus update
   */
  export type BusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * The data needed to update a Bus.
     */
    data: XOR<BusUpdateInput, BusUncheckedUpdateInput>
    /**
     * Choose, which Bus to update.
     */
    where: BusWhereUniqueInput
  }

  /**
   * Bus updateMany
   */
  export type BusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buses.
     */
    data: XOR<BusUpdateManyMutationInput, BusUncheckedUpdateManyInput>
    /**
     * Filter which Buses to update
     */
    where?: BusWhereInput
    /**
     * Limit how many Buses to update.
     */
    limit?: number
  }

  /**
   * Bus updateManyAndReturn
   */
  export type BusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * The data used to update Buses.
     */
    data: XOR<BusUpdateManyMutationInput, BusUncheckedUpdateManyInput>
    /**
     * Filter which Buses to update
     */
    where?: BusWhereInput
    /**
     * Limit how many Buses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bus upsert
   */
  export type BusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * The filter to search for the Bus to update in case it exists.
     */
    where: BusWhereUniqueInput
    /**
     * In case the Bus found by the `where` argument doesn't exist, create a new Bus with this data.
     */
    create: XOR<BusCreateInput, BusUncheckedCreateInput>
    /**
     * In case the Bus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusUpdateInput, BusUncheckedUpdateInput>
  }

  /**
   * Bus delete
   */
  export type BusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
    /**
     * Filter which Bus to delete.
     */
    where: BusWhereUniqueInput
  }

  /**
   * Bus deleteMany
   */
  export type BusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buses to delete
     */
    where?: BusWhereInput
    /**
     * Limit how many Buses to delete.
     */
    limit?: number
  }

  /**
   * Bus without action
   */
  export type BusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bus
     */
    select?: BusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bus
     */
    omit?: BusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusInclude<ExtArgs> | null
  }


  /**
   * Model SkuunAiSession
   */

  export type AggregateSkuunAiSession = {
    _count: SkuunAiSessionCountAggregateOutputType | null
    _min: SkuunAiSessionMinAggregateOutputType | null
    _max: SkuunAiSessionMaxAggregateOutputType | null
  }

  export type SkuunAiSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkuunAiSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkuunAiSessionCountAggregateOutputType = {
    id: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkuunAiSessionMinAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkuunAiSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkuunAiSessionCountAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkuunAiSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuunAiSession to aggregate.
     */
    where?: SkuunAiSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiSessions to fetch.
     */
    orderBy?: SkuunAiSessionOrderByWithRelationInput | SkuunAiSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkuunAiSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkuunAiSessions
    **/
    _count?: true | SkuunAiSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkuunAiSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkuunAiSessionMaxAggregateInputType
  }

  export type GetSkuunAiSessionAggregateType<T extends SkuunAiSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSkuunAiSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkuunAiSession[P]>
      : GetScalarType<T[P], AggregateSkuunAiSession[P]>
  }




  export type SkuunAiSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuunAiSessionWhereInput
    orderBy?: SkuunAiSessionOrderByWithAggregationInput | SkuunAiSessionOrderByWithAggregationInput[]
    by: SkuunAiSessionScalarFieldEnum[] | SkuunAiSessionScalarFieldEnum
    having?: SkuunAiSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkuunAiSessionCountAggregateInputType | true
    _min?: SkuunAiSessionMinAggregateInputType
    _max?: SkuunAiSessionMaxAggregateInputType
  }

  export type SkuunAiSessionGroupByOutputType = {
    id: string
    userId: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: SkuunAiSessionCountAggregateOutputType | null
    _min: SkuunAiSessionMinAggregateOutputType | null
    _max: SkuunAiSessionMaxAggregateOutputType | null
  }

  type GetSkuunAiSessionGroupByPayload<T extends SkuunAiSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkuunAiSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkuunAiSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkuunAiSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SkuunAiSessionGroupByOutputType[P]>
        }
      >
    >


  export type SkuunAiSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SkuunAiSession$messagesArgs<ExtArgs>
    actions?: boolean | SkuunAiSession$actionsArgs<ExtArgs>
    SkuunAiRecommendation?: boolean | SkuunAiSession$SkuunAiRecommendationArgs<ExtArgs>
    _count?: boolean | SkuunAiSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiSession"]>

  export type SkuunAiSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiSession"]>

  export type SkuunAiSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiSession"]>

  export type SkuunAiSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkuunAiSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["skuunAiSession"]>
  export type SkuunAiSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SkuunAiSession$messagesArgs<ExtArgs>
    actions?: boolean | SkuunAiSession$actionsArgs<ExtArgs>
    SkuunAiRecommendation?: boolean | SkuunAiSession$SkuunAiRecommendationArgs<ExtArgs>
    _count?: boolean | SkuunAiSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkuunAiSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SkuunAiSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SkuunAiSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkuunAiSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$SkuunAiMessagePayload<ExtArgs>[]
      actions: Prisma.$SkuunAiActionPayload<ExtArgs>[]
      SkuunAiRecommendation: Prisma.$SkuunAiRecommendationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skuunAiSession"]>
    composites: {}
  }

  type SkuunAiSessionGetPayload<S extends boolean | null | undefined | SkuunAiSessionDefaultArgs> = $Result.GetResult<Prisma.$SkuunAiSessionPayload, S>

  type SkuunAiSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkuunAiSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkuunAiSessionCountAggregateInputType | true
    }

  export interface SkuunAiSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkuunAiSession'], meta: { name: 'SkuunAiSession' } }
    /**
     * Find zero or one SkuunAiSession that matches the filter.
     * @param {SkuunAiSessionFindUniqueArgs} args - Arguments to find a SkuunAiSession
     * @example
     * // Get one SkuunAiSession
     * const skuunAiSession = await prisma.skuunAiSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkuunAiSessionFindUniqueArgs>(args: SelectSubset<T, SkuunAiSessionFindUniqueArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkuunAiSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkuunAiSessionFindUniqueOrThrowArgs} args - Arguments to find a SkuunAiSession
     * @example
     * // Get one SkuunAiSession
     * const skuunAiSession = await prisma.skuunAiSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkuunAiSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SkuunAiSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkuunAiSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiSessionFindFirstArgs} args - Arguments to find a SkuunAiSession
     * @example
     * // Get one SkuunAiSession
     * const skuunAiSession = await prisma.skuunAiSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkuunAiSessionFindFirstArgs>(args?: SelectSubset<T, SkuunAiSessionFindFirstArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkuunAiSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiSessionFindFirstOrThrowArgs} args - Arguments to find a SkuunAiSession
     * @example
     * // Get one SkuunAiSession
     * const skuunAiSession = await prisma.skuunAiSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkuunAiSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SkuunAiSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkuunAiSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkuunAiSessions
     * const skuunAiSessions = await prisma.skuunAiSession.findMany()
     * 
     * // Get first 10 SkuunAiSessions
     * const skuunAiSessions = await prisma.skuunAiSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skuunAiSessionWithIdOnly = await prisma.skuunAiSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkuunAiSessionFindManyArgs>(args?: SelectSubset<T, SkuunAiSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkuunAiSession.
     * @param {SkuunAiSessionCreateArgs} args - Arguments to create a SkuunAiSession.
     * @example
     * // Create one SkuunAiSession
     * const SkuunAiSession = await prisma.skuunAiSession.create({
     *   data: {
     *     // ... data to create a SkuunAiSession
     *   }
     * })
     * 
     */
    create<T extends SkuunAiSessionCreateArgs>(args: SelectSubset<T, SkuunAiSessionCreateArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkuunAiSessions.
     * @param {SkuunAiSessionCreateManyArgs} args - Arguments to create many SkuunAiSessions.
     * @example
     * // Create many SkuunAiSessions
     * const skuunAiSession = await prisma.skuunAiSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkuunAiSessionCreateManyArgs>(args?: SelectSubset<T, SkuunAiSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkuunAiSessions and returns the data saved in the database.
     * @param {SkuunAiSessionCreateManyAndReturnArgs} args - Arguments to create many SkuunAiSessions.
     * @example
     * // Create many SkuunAiSessions
     * const skuunAiSession = await prisma.skuunAiSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkuunAiSessions and only return the `id`
     * const skuunAiSessionWithIdOnly = await prisma.skuunAiSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkuunAiSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SkuunAiSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SkuunAiSession.
     * @param {SkuunAiSessionDeleteArgs} args - Arguments to delete one SkuunAiSession.
     * @example
     * // Delete one SkuunAiSession
     * const SkuunAiSession = await prisma.skuunAiSession.delete({
     *   where: {
     *     // ... filter to delete one SkuunAiSession
     *   }
     * })
     * 
     */
    delete<T extends SkuunAiSessionDeleteArgs>(args: SelectSubset<T, SkuunAiSessionDeleteArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkuunAiSession.
     * @param {SkuunAiSessionUpdateArgs} args - Arguments to update one SkuunAiSession.
     * @example
     * // Update one SkuunAiSession
     * const skuunAiSession = await prisma.skuunAiSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkuunAiSessionUpdateArgs>(args: SelectSubset<T, SkuunAiSessionUpdateArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkuunAiSessions.
     * @param {SkuunAiSessionDeleteManyArgs} args - Arguments to filter SkuunAiSessions to delete.
     * @example
     * // Delete a few SkuunAiSessions
     * const { count } = await prisma.skuunAiSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkuunAiSessionDeleteManyArgs>(args?: SelectSubset<T, SkuunAiSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuunAiSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkuunAiSessions
     * const skuunAiSession = await prisma.skuunAiSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkuunAiSessionUpdateManyArgs>(args: SelectSubset<T, SkuunAiSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuunAiSessions and returns the data updated in the database.
     * @param {SkuunAiSessionUpdateManyAndReturnArgs} args - Arguments to update many SkuunAiSessions.
     * @example
     * // Update many SkuunAiSessions
     * const skuunAiSession = await prisma.skuunAiSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkuunAiSessions and only return the `id`
     * const skuunAiSessionWithIdOnly = await prisma.skuunAiSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkuunAiSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SkuunAiSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SkuunAiSession.
     * @param {SkuunAiSessionUpsertArgs} args - Arguments to update or create a SkuunAiSession.
     * @example
     * // Update or create a SkuunAiSession
     * const skuunAiSession = await prisma.skuunAiSession.upsert({
     *   create: {
     *     // ... data to create a SkuunAiSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkuunAiSession we want to update
     *   }
     * })
     */
    upsert<T extends SkuunAiSessionUpsertArgs>(args: SelectSubset<T, SkuunAiSessionUpsertArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SkuunAiSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiSessionCountArgs} args - Arguments to filter SkuunAiSessions to count.
     * @example
     * // Count the number of SkuunAiSessions
     * const count = await prisma.skuunAiSession.count({
     *   where: {
     *     // ... the filter for the SkuunAiSessions we want to count
     *   }
     * })
    **/
    count<T extends SkuunAiSessionCountArgs>(
      args?: Subset<T, SkuunAiSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkuunAiSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkuunAiSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkuunAiSessionAggregateArgs>(args: Subset<T, SkuunAiSessionAggregateArgs>): Prisma.PrismaPromise<GetSkuunAiSessionAggregateType<T>>

    /**
     * Group by SkuunAiSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkuunAiSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkuunAiSessionGroupByArgs['orderBy'] }
        : { orderBy?: SkuunAiSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkuunAiSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkuunAiSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkuunAiSession model
   */
  readonly fields: SkuunAiSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkuunAiSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkuunAiSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends SkuunAiSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, SkuunAiSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actions<T extends SkuunAiSession$actionsArgs<ExtArgs> = {}>(args?: Subset<T, SkuunAiSession$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SkuunAiRecommendation<T extends SkuunAiSession$SkuunAiRecommendationArgs<ExtArgs> = {}>(args?: Subset<T, SkuunAiSession$SkuunAiRecommendationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkuunAiSession model
   */
  interface SkuunAiSessionFieldRefs {
    readonly id: FieldRef<"SkuunAiSession", 'String'>
    readonly userId: FieldRef<"SkuunAiSession", 'String'>
    readonly role: FieldRef<"SkuunAiSession", 'Role'>
    readonly createdAt: FieldRef<"SkuunAiSession", 'DateTime'>
    readonly updatedAt: FieldRef<"SkuunAiSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkuunAiSession findUnique
   */
  export type SkuunAiSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiSession to fetch.
     */
    where: SkuunAiSessionWhereUniqueInput
  }

  /**
   * SkuunAiSession findUniqueOrThrow
   */
  export type SkuunAiSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiSession to fetch.
     */
    where: SkuunAiSessionWhereUniqueInput
  }

  /**
   * SkuunAiSession findFirst
   */
  export type SkuunAiSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiSession to fetch.
     */
    where?: SkuunAiSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiSessions to fetch.
     */
    orderBy?: SkuunAiSessionOrderByWithRelationInput | SkuunAiSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuunAiSessions.
     */
    cursor?: SkuunAiSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuunAiSessions.
     */
    distinct?: SkuunAiSessionScalarFieldEnum | SkuunAiSessionScalarFieldEnum[]
  }

  /**
   * SkuunAiSession findFirstOrThrow
   */
  export type SkuunAiSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiSession to fetch.
     */
    where?: SkuunAiSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiSessions to fetch.
     */
    orderBy?: SkuunAiSessionOrderByWithRelationInput | SkuunAiSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuunAiSessions.
     */
    cursor?: SkuunAiSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuunAiSessions.
     */
    distinct?: SkuunAiSessionScalarFieldEnum | SkuunAiSessionScalarFieldEnum[]
  }

  /**
   * SkuunAiSession findMany
   */
  export type SkuunAiSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiSessions to fetch.
     */
    where?: SkuunAiSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiSessions to fetch.
     */
    orderBy?: SkuunAiSessionOrderByWithRelationInput | SkuunAiSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkuunAiSessions.
     */
    cursor?: SkuunAiSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiSessions.
     */
    skip?: number
    distinct?: SkuunAiSessionScalarFieldEnum | SkuunAiSessionScalarFieldEnum[]
  }

  /**
   * SkuunAiSession create
   */
  export type SkuunAiSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SkuunAiSession.
     */
    data: XOR<SkuunAiSessionCreateInput, SkuunAiSessionUncheckedCreateInput>
  }

  /**
   * SkuunAiSession createMany
   */
  export type SkuunAiSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkuunAiSessions.
     */
    data: SkuunAiSessionCreateManyInput | SkuunAiSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkuunAiSession createManyAndReturn
   */
  export type SkuunAiSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SkuunAiSessions.
     */
    data: SkuunAiSessionCreateManyInput | SkuunAiSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuunAiSession update
   */
  export type SkuunAiSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SkuunAiSession.
     */
    data: XOR<SkuunAiSessionUpdateInput, SkuunAiSessionUncheckedUpdateInput>
    /**
     * Choose, which SkuunAiSession to update.
     */
    where: SkuunAiSessionWhereUniqueInput
  }

  /**
   * SkuunAiSession updateMany
   */
  export type SkuunAiSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkuunAiSessions.
     */
    data: XOR<SkuunAiSessionUpdateManyMutationInput, SkuunAiSessionUncheckedUpdateManyInput>
    /**
     * Filter which SkuunAiSessions to update
     */
    where?: SkuunAiSessionWhereInput
    /**
     * Limit how many SkuunAiSessions to update.
     */
    limit?: number
  }

  /**
   * SkuunAiSession updateManyAndReturn
   */
  export type SkuunAiSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * The data used to update SkuunAiSessions.
     */
    data: XOR<SkuunAiSessionUpdateManyMutationInput, SkuunAiSessionUncheckedUpdateManyInput>
    /**
     * Filter which SkuunAiSessions to update
     */
    where?: SkuunAiSessionWhereInput
    /**
     * Limit how many SkuunAiSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuunAiSession upsert
   */
  export type SkuunAiSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SkuunAiSession to update in case it exists.
     */
    where: SkuunAiSessionWhereUniqueInput
    /**
     * In case the SkuunAiSession found by the `where` argument doesn't exist, create a new SkuunAiSession with this data.
     */
    create: XOR<SkuunAiSessionCreateInput, SkuunAiSessionUncheckedCreateInput>
    /**
     * In case the SkuunAiSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkuunAiSessionUpdateInput, SkuunAiSessionUncheckedUpdateInput>
  }

  /**
   * SkuunAiSession delete
   */
  export type SkuunAiSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
    /**
     * Filter which SkuunAiSession to delete.
     */
    where: SkuunAiSessionWhereUniqueInput
  }

  /**
   * SkuunAiSession deleteMany
   */
  export type SkuunAiSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuunAiSessions to delete
     */
    where?: SkuunAiSessionWhereInput
    /**
     * Limit how many SkuunAiSessions to delete.
     */
    limit?: number
  }

  /**
   * SkuunAiSession.messages
   */
  export type SkuunAiSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    where?: SkuunAiMessageWhereInput
    orderBy?: SkuunAiMessageOrderByWithRelationInput | SkuunAiMessageOrderByWithRelationInput[]
    cursor?: SkuunAiMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuunAiMessageScalarFieldEnum | SkuunAiMessageScalarFieldEnum[]
  }

  /**
   * SkuunAiSession.actions
   */
  export type SkuunAiSession$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    where?: SkuunAiActionWhereInput
    orderBy?: SkuunAiActionOrderByWithRelationInput | SkuunAiActionOrderByWithRelationInput[]
    cursor?: SkuunAiActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuunAiActionScalarFieldEnum | SkuunAiActionScalarFieldEnum[]
  }

  /**
   * SkuunAiSession.SkuunAiRecommendation
   */
  export type SkuunAiSession$SkuunAiRecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    where?: SkuunAiRecommendationWhereInput
    orderBy?: SkuunAiRecommendationOrderByWithRelationInput | SkuunAiRecommendationOrderByWithRelationInput[]
    cursor?: SkuunAiRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuunAiRecommendationScalarFieldEnum | SkuunAiRecommendationScalarFieldEnum[]
  }

  /**
   * SkuunAiSession without action
   */
  export type SkuunAiSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiSession
     */
    select?: SkuunAiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiSession
     */
    omit?: SkuunAiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiSessionInclude<ExtArgs> | null
  }


  /**
   * Model SkuunAiMessage
   */

  export type AggregateSkuunAiMessage = {
    _count: SkuunAiMessageCountAggregateOutputType | null
    _min: SkuunAiMessageMinAggregateOutputType | null
    _max: SkuunAiMessageMaxAggregateOutputType | null
  }

  export type SkuunAiMessageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    sender: $Enums.SenderType | null
    type: $Enums.MessageType | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkuunAiMessageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    sender: $Enums.SenderType | null
    type: $Enums.MessageType | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkuunAiMessageCountAggregateOutputType = {
    id: number
    sessionId: number
    sender: number
    type: number
    content: number
    payload: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkuunAiMessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    sender?: true
    type?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkuunAiMessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    sender?: true
    type?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkuunAiMessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    sender?: true
    type?: true
    content?: true
    payload?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkuunAiMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuunAiMessage to aggregate.
     */
    where?: SkuunAiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiMessages to fetch.
     */
    orderBy?: SkuunAiMessageOrderByWithRelationInput | SkuunAiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkuunAiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkuunAiMessages
    **/
    _count?: true | SkuunAiMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkuunAiMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkuunAiMessageMaxAggregateInputType
  }

  export type GetSkuunAiMessageAggregateType<T extends SkuunAiMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateSkuunAiMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkuunAiMessage[P]>
      : GetScalarType<T[P], AggregateSkuunAiMessage[P]>
  }




  export type SkuunAiMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuunAiMessageWhereInput
    orderBy?: SkuunAiMessageOrderByWithAggregationInput | SkuunAiMessageOrderByWithAggregationInput[]
    by: SkuunAiMessageScalarFieldEnum[] | SkuunAiMessageScalarFieldEnum
    having?: SkuunAiMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkuunAiMessageCountAggregateInputType | true
    _min?: SkuunAiMessageMinAggregateInputType
    _max?: SkuunAiMessageMaxAggregateInputType
  }

  export type SkuunAiMessageGroupByOutputType = {
    id: string
    sessionId: string
    sender: $Enums.SenderType
    type: $Enums.MessageType
    content: string
    payload: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SkuunAiMessageCountAggregateOutputType | null
    _min: SkuunAiMessageMinAggregateOutputType | null
    _max: SkuunAiMessageMaxAggregateOutputType | null
  }

  type GetSkuunAiMessageGroupByPayload<T extends SkuunAiMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkuunAiMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkuunAiMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkuunAiMessageGroupByOutputType[P]>
            : GetScalarType<T[P], SkuunAiMessageGroupByOutputType[P]>
        }
      >
    >


  export type SkuunAiMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sender?: boolean
    type?: boolean
    content?: boolean
    payload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiMessage"]>

  export type SkuunAiMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sender?: boolean
    type?: boolean
    content?: boolean
    payload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiMessage"]>

  export type SkuunAiMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sender?: boolean
    type?: boolean
    content?: boolean
    payload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiMessage"]>

  export type SkuunAiMessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    sender?: boolean
    type?: boolean
    content?: boolean
    payload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkuunAiMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "sender" | "type" | "content" | "payload" | "createdAt" | "updatedAt", ExtArgs["result"]["skuunAiMessage"]>
  export type SkuunAiMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }
  export type SkuunAiMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }
  export type SkuunAiMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }

  export type $SkuunAiMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkuunAiMessage"
    objects: {
      session: Prisma.$SkuunAiSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      sender: $Enums.SenderType
      type: $Enums.MessageType
      content: string
      payload: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skuunAiMessage"]>
    composites: {}
  }

  type SkuunAiMessageGetPayload<S extends boolean | null | undefined | SkuunAiMessageDefaultArgs> = $Result.GetResult<Prisma.$SkuunAiMessagePayload, S>

  type SkuunAiMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkuunAiMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkuunAiMessageCountAggregateInputType | true
    }

  export interface SkuunAiMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkuunAiMessage'], meta: { name: 'SkuunAiMessage' } }
    /**
     * Find zero or one SkuunAiMessage that matches the filter.
     * @param {SkuunAiMessageFindUniqueArgs} args - Arguments to find a SkuunAiMessage
     * @example
     * // Get one SkuunAiMessage
     * const skuunAiMessage = await prisma.skuunAiMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkuunAiMessageFindUniqueArgs>(args: SelectSubset<T, SkuunAiMessageFindUniqueArgs<ExtArgs>>): Prisma__SkuunAiMessageClient<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkuunAiMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkuunAiMessageFindUniqueOrThrowArgs} args - Arguments to find a SkuunAiMessage
     * @example
     * // Get one SkuunAiMessage
     * const skuunAiMessage = await prisma.skuunAiMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkuunAiMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, SkuunAiMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkuunAiMessageClient<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkuunAiMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiMessageFindFirstArgs} args - Arguments to find a SkuunAiMessage
     * @example
     * // Get one SkuunAiMessage
     * const skuunAiMessage = await prisma.skuunAiMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkuunAiMessageFindFirstArgs>(args?: SelectSubset<T, SkuunAiMessageFindFirstArgs<ExtArgs>>): Prisma__SkuunAiMessageClient<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkuunAiMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiMessageFindFirstOrThrowArgs} args - Arguments to find a SkuunAiMessage
     * @example
     * // Get one SkuunAiMessage
     * const skuunAiMessage = await prisma.skuunAiMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkuunAiMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, SkuunAiMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkuunAiMessageClient<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkuunAiMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkuunAiMessages
     * const skuunAiMessages = await prisma.skuunAiMessage.findMany()
     * 
     * // Get first 10 SkuunAiMessages
     * const skuunAiMessages = await prisma.skuunAiMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skuunAiMessageWithIdOnly = await prisma.skuunAiMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkuunAiMessageFindManyArgs>(args?: SelectSubset<T, SkuunAiMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkuunAiMessage.
     * @param {SkuunAiMessageCreateArgs} args - Arguments to create a SkuunAiMessage.
     * @example
     * // Create one SkuunAiMessage
     * const SkuunAiMessage = await prisma.skuunAiMessage.create({
     *   data: {
     *     // ... data to create a SkuunAiMessage
     *   }
     * })
     * 
     */
    create<T extends SkuunAiMessageCreateArgs>(args: SelectSubset<T, SkuunAiMessageCreateArgs<ExtArgs>>): Prisma__SkuunAiMessageClient<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkuunAiMessages.
     * @param {SkuunAiMessageCreateManyArgs} args - Arguments to create many SkuunAiMessages.
     * @example
     * // Create many SkuunAiMessages
     * const skuunAiMessage = await prisma.skuunAiMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkuunAiMessageCreateManyArgs>(args?: SelectSubset<T, SkuunAiMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkuunAiMessages and returns the data saved in the database.
     * @param {SkuunAiMessageCreateManyAndReturnArgs} args - Arguments to create many SkuunAiMessages.
     * @example
     * // Create many SkuunAiMessages
     * const skuunAiMessage = await prisma.skuunAiMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkuunAiMessages and only return the `id`
     * const skuunAiMessageWithIdOnly = await prisma.skuunAiMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkuunAiMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, SkuunAiMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SkuunAiMessage.
     * @param {SkuunAiMessageDeleteArgs} args - Arguments to delete one SkuunAiMessage.
     * @example
     * // Delete one SkuunAiMessage
     * const SkuunAiMessage = await prisma.skuunAiMessage.delete({
     *   where: {
     *     // ... filter to delete one SkuunAiMessage
     *   }
     * })
     * 
     */
    delete<T extends SkuunAiMessageDeleteArgs>(args: SelectSubset<T, SkuunAiMessageDeleteArgs<ExtArgs>>): Prisma__SkuunAiMessageClient<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkuunAiMessage.
     * @param {SkuunAiMessageUpdateArgs} args - Arguments to update one SkuunAiMessage.
     * @example
     * // Update one SkuunAiMessage
     * const skuunAiMessage = await prisma.skuunAiMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkuunAiMessageUpdateArgs>(args: SelectSubset<T, SkuunAiMessageUpdateArgs<ExtArgs>>): Prisma__SkuunAiMessageClient<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkuunAiMessages.
     * @param {SkuunAiMessageDeleteManyArgs} args - Arguments to filter SkuunAiMessages to delete.
     * @example
     * // Delete a few SkuunAiMessages
     * const { count } = await prisma.skuunAiMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkuunAiMessageDeleteManyArgs>(args?: SelectSubset<T, SkuunAiMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuunAiMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkuunAiMessages
     * const skuunAiMessage = await prisma.skuunAiMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkuunAiMessageUpdateManyArgs>(args: SelectSubset<T, SkuunAiMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuunAiMessages and returns the data updated in the database.
     * @param {SkuunAiMessageUpdateManyAndReturnArgs} args - Arguments to update many SkuunAiMessages.
     * @example
     * // Update many SkuunAiMessages
     * const skuunAiMessage = await prisma.skuunAiMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkuunAiMessages and only return the `id`
     * const skuunAiMessageWithIdOnly = await prisma.skuunAiMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkuunAiMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, SkuunAiMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SkuunAiMessage.
     * @param {SkuunAiMessageUpsertArgs} args - Arguments to update or create a SkuunAiMessage.
     * @example
     * // Update or create a SkuunAiMessage
     * const skuunAiMessage = await prisma.skuunAiMessage.upsert({
     *   create: {
     *     // ... data to create a SkuunAiMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkuunAiMessage we want to update
     *   }
     * })
     */
    upsert<T extends SkuunAiMessageUpsertArgs>(args: SelectSubset<T, SkuunAiMessageUpsertArgs<ExtArgs>>): Prisma__SkuunAiMessageClient<$Result.GetResult<Prisma.$SkuunAiMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SkuunAiMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiMessageCountArgs} args - Arguments to filter SkuunAiMessages to count.
     * @example
     * // Count the number of SkuunAiMessages
     * const count = await prisma.skuunAiMessage.count({
     *   where: {
     *     // ... the filter for the SkuunAiMessages we want to count
     *   }
     * })
    **/
    count<T extends SkuunAiMessageCountArgs>(
      args?: Subset<T, SkuunAiMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkuunAiMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkuunAiMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkuunAiMessageAggregateArgs>(args: Subset<T, SkuunAiMessageAggregateArgs>): Prisma.PrismaPromise<GetSkuunAiMessageAggregateType<T>>

    /**
     * Group by SkuunAiMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkuunAiMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkuunAiMessageGroupByArgs['orderBy'] }
        : { orderBy?: SkuunAiMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkuunAiMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkuunAiMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkuunAiMessage model
   */
  readonly fields: SkuunAiMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkuunAiMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkuunAiMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SkuunAiSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkuunAiSessionDefaultArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkuunAiMessage model
   */
  interface SkuunAiMessageFieldRefs {
    readonly id: FieldRef<"SkuunAiMessage", 'String'>
    readonly sessionId: FieldRef<"SkuunAiMessage", 'String'>
    readonly sender: FieldRef<"SkuunAiMessage", 'SenderType'>
    readonly type: FieldRef<"SkuunAiMessage", 'MessageType'>
    readonly content: FieldRef<"SkuunAiMessage", 'String'>
    readonly payload: FieldRef<"SkuunAiMessage", 'Json'>
    readonly createdAt: FieldRef<"SkuunAiMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"SkuunAiMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkuunAiMessage findUnique
   */
  export type SkuunAiMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiMessage to fetch.
     */
    where: SkuunAiMessageWhereUniqueInput
  }

  /**
   * SkuunAiMessage findUniqueOrThrow
   */
  export type SkuunAiMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiMessage to fetch.
     */
    where: SkuunAiMessageWhereUniqueInput
  }

  /**
   * SkuunAiMessage findFirst
   */
  export type SkuunAiMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiMessage to fetch.
     */
    where?: SkuunAiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiMessages to fetch.
     */
    orderBy?: SkuunAiMessageOrderByWithRelationInput | SkuunAiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuunAiMessages.
     */
    cursor?: SkuunAiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuunAiMessages.
     */
    distinct?: SkuunAiMessageScalarFieldEnum | SkuunAiMessageScalarFieldEnum[]
  }

  /**
   * SkuunAiMessage findFirstOrThrow
   */
  export type SkuunAiMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiMessage to fetch.
     */
    where?: SkuunAiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiMessages to fetch.
     */
    orderBy?: SkuunAiMessageOrderByWithRelationInput | SkuunAiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuunAiMessages.
     */
    cursor?: SkuunAiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuunAiMessages.
     */
    distinct?: SkuunAiMessageScalarFieldEnum | SkuunAiMessageScalarFieldEnum[]
  }

  /**
   * SkuunAiMessage findMany
   */
  export type SkuunAiMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiMessages to fetch.
     */
    where?: SkuunAiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiMessages to fetch.
     */
    orderBy?: SkuunAiMessageOrderByWithRelationInput | SkuunAiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkuunAiMessages.
     */
    cursor?: SkuunAiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiMessages.
     */
    skip?: number
    distinct?: SkuunAiMessageScalarFieldEnum | SkuunAiMessageScalarFieldEnum[]
  }

  /**
   * SkuunAiMessage create
   */
  export type SkuunAiMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a SkuunAiMessage.
     */
    data: XOR<SkuunAiMessageCreateInput, SkuunAiMessageUncheckedCreateInput>
  }

  /**
   * SkuunAiMessage createMany
   */
  export type SkuunAiMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkuunAiMessages.
     */
    data: SkuunAiMessageCreateManyInput | SkuunAiMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkuunAiMessage createManyAndReturn
   */
  export type SkuunAiMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * The data used to create many SkuunAiMessages.
     */
    data: SkuunAiMessageCreateManyInput | SkuunAiMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuunAiMessage update
   */
  export type SkuunAiMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a SkuunAiMessage.
     */
    data: XOR<SkuunAiMessageUpdateInput, SkuunAiMessageUncheckedUpdateInput>
    /**
     * Choose, which SkuunAiMessage to update.
     */
    where: SkuunAiMessageWhereUniqueInput
  }

  /**
   * SkuunAiMessage updateMany
   */
  export type SkuunAiMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkuunAiMessages.
     */
    data: XOR<SkuunAiMessageUpdateManyMutationInput, SkuunAiMessageUncheckedUpdateManyInput>
    /**
     * Filter which SkuunAiMessages to update
     */
    where?: SkuunAiMessageWhereInput
    /**
     * Limit how many SkuunAiMessages to update.
     */
    limit?: number
  }

  /**
   * SkuunAiMessage updateManyAndReturn
   */
  export type SkuunAiMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * The data used to update SkuunAiMessages.
     */
    data: XOR<SkuunAiMessageUpdateManyMutationInput, SkuunAiMessageUncheckedUpdateManyInput>
    /**
     * Filter which SkuunAiMessages to update
     */
    where?: SkuunAiMessageWhereInput
    /**
     * Limit how many SkuunAiMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuunAiMessage upsert
   */
  export type SkuunAiMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the SkuunAiMessage to update in case it exists.
     */
    where: SkuunAiMessageWhereUniqueInput
    /**
     * In case the SkuunAiMessage found by the `where` argument doesn't exist, create a new SkuunAiMessage with this data.
     */
    create: XOR<SkuunAiMessageCreateInput, SkuunAiMessageUncheckedCreateInput>
    /**
     * In case the SkuunAiMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkuunAiMessageUpdateInput, SkuunAiMessageUncheckedUpdateInput>
  }

  /**
   * SkuunAiMessage delete
   */
  export type SkuunAiMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
    /**
     * Filter which SkuunAiMessage to delete.
     */
    where: SkuunAiMessageWhereUniqueInput
  }

  /**
   * SkuunAiMessage deleteMany
   */
  export type SkuunAiMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuunAiMessages to delete
     */
    where?: SkuunAiMessageWhereInput
    /**
     * Limit how many SkuunAiMessages to delete.
     */
    limit?: number
  }

  /**
   * SkuunAiMessage without action
   */
  export type SkuunAiMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiMessage
     */
    select?: SkuunAiMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiMessage
     */
    omit?: SkuunAiMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiMessageInclude<ExtArgs> | null
  }


  /**
   * Model SkuunAiAction
   */

  export type AggregateSkuunAiAction = {
    _count: SkuunAiActionCountAggregateOutputType | null
    _min: SkuunAiActionMinAggregateOutputType | null
    _max: SkuunAiActionMaxAggregateOutputType | null
  }

  export type SkuunAiActionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    type: $Enums.AIActionType | null
    status: $Enums.ActionStatus | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkuunAiActionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    type: $Enums.AIActionType | null
    status: $Enums.ActionStatus | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkuunAiActionCountAggregateOutputType = {
    id: number
    sessionId: number
    type: number
    payload: number
    status: number
    executedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkuunAiActionMinAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkuunAiActionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkuunAiActionCountAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    payload?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkuunAiActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuunAiAction to aggregate.
     */
    where?: SkuunAiActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiActions to fetch.
     */
    orderBy?: SkuunAiActionOrderByWithRelationInput | SkuunAiActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkuunAiActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkuunAiActions
    **/
    _count?: true | SkuunAiActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkuunAiActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkuunAiActionMaxAggregateInputType
  }

  export type GetSkuunAiActionAggregateType<T extends SkuunAiActionAggregateArgs> = {
        [P in keyof T & keyof AggregateSkuunAiAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkuunAiAction[P]>
      : GetScalarType<T[P], AggregateSkuunAiAction[P]>
  }




  export type SkuunAiActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuunAiActionWhereInput
    orderBy?: SkuunAiActionOrderByWithAggregationInput | SkuunAiActionOrderByWithAggregationInput[]
    by: SkuunAiActionScalarFieldEnum[] | SkuunAiActionScalarFieldEnum
    having?: SkuunAiActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkuunAiActionCountAggregateInputType | true
    _min?: SkuunAiActionMinAggregateInputType
    _max?: SkuunAiActionMaxAggregateInputType
  }

  export type SkuunAiActionGroupByOutputType = {
    id: string
    sessionId: string
    type: $Enums.AIActionType
    payload: JsonValue
    status: $Enums.ActionStatus
    executedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SkuunAiActionCountAggregateOutputType | null
    _min: SkuunAiActionMinAggregateOutputType | null
    _max: SkuunAiActionMaxAggregateOutputType | null
  }

  type GetSkuunAiActionGroupByPayload<T extends SkuunAiActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkuunAiActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkuunAiActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkuunAiActionGroupByOutputType[P]>
            : GetScalarType<T[P], SkuunAiActionGroupByOutputType[P]>
        }
      >
    >


  export type SkuunAiActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiAction"]>

  export type SkuunAiActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiAction"]>

  export type SkuunAiActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiAction"]>

  export type SkuunAiActionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkuunAiActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "type" | "payload" | "status" | "executedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["skuunAiAction"]>
  export type SkuunAiActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }
  export type SkuunAiActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }
  export type SkuunAiActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }

  export type $SkuunAiActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkuunAiAction"
    objects: {
      session: Prisma.$SkuunAiSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      type: $Enums.AIActionType
      payload: Prisma.JsonValue
      status: $Enums.ActionStatus
      executedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skuunAiAction"]>
    composites: {}
  }

  type SkuunAiActionGetPayload<S extends boolean | null | undefined | SkuunAiActionDefaultArgs> = $Result.GetResult<Prisma.$SkuunAiActionPayload, S>

  type SkuunAiActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkuunAiActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkuunAiActionCountAggregateInputType | true
    }

  export interface SkuunAiActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkuunAiAction'], meta: { name: 'SkuunAiAction' } }
    /**
     * Find zero or one SkuunAiAction that matches the filter.
     * @param {SkuunAiActionFindUniqueArgs} args - Arguments to find a SkuunAiAction
     * @example
     * // Get one SkuunAiAction
     * const skuunAiAction = await prisma.skuunAiAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkuunAiActionFindUniqueArgs>(args: SelectSubset<T, SkuunAiActionFindUniqueArgs<ExtArgs>>): Prisma__SkuunAiActionClient<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkuunAiAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkuunAiActionFindUniqueOrThrowArgs} args - Arguments to find a SkuunAiAction
     * @example
     * // Get one SkuunAiAction
     * const skuunAiAction = await prisma.skuunAiAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkuunAiActionFindUniqueOrThrowArgs>(args: SelectSubset<T, SkuunAiActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkuunAiActionClient<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkuunAiAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiActionFindFirstArgs} args - Arguments to find a SkuunAiAction
     * @example
     * // Get one SkuunAiAction
     * const skuunAiAction = await prisma.skuunAiAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkuunAiActionFindFirstArgs>(args?: SelectSubset<T, SkuunAiActionFindFirstArgs<ExtArgs>>): Prisma__SkuunAiActionClient<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkuunAiAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiActionFindFirstOrThrowArgs} args - Arguments to find a SkuunAiAction
     * @example
     * // Get one SkuunAiAction
     * const skuunAiAction = await prisma.skuunAiAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkuunAiActionFindFirstOrThrowArgs>(args?: SelectSubset<T, SkuunAiActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkuunAiActionClient<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkuunAiActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkuunAiActions
     * const skuunAiActions = await prisma.skuunAiAction.findMany()
     * 
     * // Get first 10 SkuunAiActions
     * const skuunAiActions = await prisma.skuunAiAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skuunAiActionWithIdOnly = await prisma.skuunAiAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkuunAiActionFindManyArgs>(args?: SelectSubset<T, SkuunAiActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkuunAiAction.
     * @param {SkuunAiActionCreateArgs} args - Arguments to create a SkuunAiAction.
     * @example
     * // Create one SkuunAiAction
     * const SkuunAiAction = await prisma.skuunAiAction.create({
     *   data: {
     *     // ... data to create a SkuunAiAction
     *   }
     * })
     * 
     */
    create<T extends SkuunAiActionCreateArgs>(args: SelectSubset<T, SkuunAiActionCreateArgs<ExtArgs>>): Prisma__SkuunAiActionClient<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkuunAiActions.
     * @param {SkuunAiActionCreateManyArgs} args - Arguments to create many SkuunAiActions.
     * @example
     * // Create many SkuunAiActions
     * const skuunAiAction = await prisma.skuunAiAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkuunAiActionCreateManyArgs>(args?: SelectSubset<T, SkuunAiActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkuunAiActions and returns the data saved in the database.
     * @param {SkuunAiActionCreateManyAndReturnArgs} args - Arguments to create many SkuunAiActions.
     * @example
     * // Create many SkuunAiActions
     * const skuunAiAction = await prisma.skuunAiAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkuunAiActions and only return the `id`
     * const skuunAiActionWithIdOnly = await prisma.skuunAiAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkuunAiActionCreateManyAndReturnArgs>(args?: SelectSubset<T, SkuunAiActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SkuunAiAction.
     * @param {SkuunAiActionDeleteArgs} args - Arguments to delete one SkuunAiAction.
     * @example
     * // Delete one SkuunAiAction
     * const SkuunAiAction = await prisma.skuunAiAction.delete({
     *   where: {
     *     // ... filter to delete one SkuunAiAction
     *   }
     * })
     * 
     */
    delete<T extends SkuunAiActionDeleteArgs>(args: SelectSubset<T, SkuunAiActionDeleteArgs<ExtArgs>>): Prisma__SkuunAiActionClient<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkuunAiAction.
     * @param {SkuunAiActionUpdateArgs} args - Arguments to update one SkuunAiAction.
     * @example
     * // Update one SkuunAiAction
     * const skuunAiAction = await prisma.skuunAiAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkuunAiActionUpdateArgs>(args: SelectSubset<T, SkuunAiActionUpdateArgs<ExtArgs>>): Prisma__SkuunAiActionClient<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkuunAiActions.
     * @param {SkuunAiActionDeleteManyArgs} args - Arguments to filter SkuunAiActions to delete.
     * @example
     * // Delete a few SkuunAiActions
     * const { count } = await prisma.skuunAiAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkuunAiActionDeleteManyArgs>(args?: SelectSubset<T, SkuunAiActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuunAiActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkuunAiActions
     * const skuunAiAction = await prisma.skuunAiAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkuunAiActionUpdateManyArgs>(args: SelectSubset<T, SkuunAiActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuunAiActions and returns the data updated in the database.
     * @param {SkuunAiActionUpdateManyAndReturnArgs} args - Arguments to update many SkuunAiActions.
     * @example
     * // Update many SkuunAiActions
     * const skuunAiAction = await prisma.skuunAiAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkuunAiActions and only return the `id`
     * const skuunAiActionWithIdOnly = await prisma.skuunAiAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkuunAiActionUpdateManyAndReturnArgs>(args: SelectSubset<T, SkuunAiActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SkuunAiAction.
     * @param {SkuunAiActionUpsertArgs} args - Arguments to update or create a SkuunAiAction.
     * @example
     * // Update or create a SkuunAiAction
     * const skuunAiAction = await prisma.skuunAiAction.upsert({
     *   create: {
     *     // ... data to create a SkuunAiAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkuunAiAction we want to update
     *   }
     * })
     */
    upsert<T extends SkuunAiActionUpsertArgs>(args: SelectSubset<T, SkuunAiActionUpsertArgs<ExtArgs>>): Prisma__SkuunAiActionClient<$Result.GetResult<Prisma.$SkuunAiActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SkuunAiActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiActionCountArgs} args - Arguments to filter SkuunAiActions to count.
     * @example
     * // Count the number of SkuunAiActions
     * const count = await prisma.skuunAiAction.count({
     *   where: {
     *     // ... the filter for the SkuunAiActions we want to count
     *   }
     * })
    **/
    count<T extends SkuunAiActionCountArgs>(
      args?: Subset<T, SkuunAiActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkuunAiActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkuunAiAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkuunAiActionAggregateArgs>(args: Subset<T, SkuunAiActionAggregateArgs>): Prisma.PrismaPromise<GetSkuunAiActionAggregateType<T>>

    /**
     * Group by SkuunAiAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkuunAiActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkuunAiActionGroupByArgs['orderBy'] }
        : { orderBy?: SkuunAiActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkuunAiActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkuunAiActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkuunAiAction model
   */
  readonly fields: SkuunAiActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkuunAiAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkuunAiActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SkuunAiSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkuunAiSessionDefaultArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkuunAiAction model
   */
  interface SkuunAiActionFieldRefs {
    readonly id: FieldRef<"SkuunAiAction", 'String'>
    readonly sessionId: FieldRef<"SkuunAiAction", 'String'>
    readonly type: FieldRef<"SkuunAiAction", 'AIActionType'>
    readonly payload: FieldRef<"SkuunAiAction", 'Json'>
    readonly status: FieldRef<"SkuunAiAction", 'ActionStatus'>
    readonly executedAt: FieldRef<"SkuunAiAction", 'DateTime'>
    readonly createdAt: FieldRef<"SkuunAiAction", 'DateTime'>
    readonly updatedAt: FieldRef<"SkuunAiAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkuunAiAction findUnique
   */
  export type SkuunAiActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiAction to fetch.
     */
    where: SkuunAiActionWhereUniqueInput
  }

  /**
   * SkuunAiAction findUniqueOrThrow
   */
  export type SkuunAiActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiAction to fetch.
     */
    where: SkuunAiActionWhereUniqueInput
  }

  /**
   * SkuunAiAction findFirst
   */
  export type SkuunAiActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiAction to fetch.
     */
    where?: SkuunAiActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiActions to fetch.
     */
    orderBy?: SkuunAiActionOrderByWithRelationInput | SkuunAiActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuunAiActions.
     */
    cursor?: SkuunAiActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuunAiActions.
     */
    distinct?: SkuunAiActionScalarFieldEnum | SkuunAiActionScalarFieldEnum[]
  }

  /**
   * SkuunAiAction findFirstOrThrow
   */
  export type SkuunAiActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiAction to fetch.
     */
    where?: SkuunAiActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiActions to fetch.
     */
    orderBy?: SkuunAiActionOrderByWithRelationInput | SkuunAiActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuunAiActions.
     */
    cursor?: SkuunAiActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuunAiActions.
     */
    distinct?: SkuunAiActionScalarFieldEnum | SkuunAiActionScalarFieldEnum[]
  }

  /**
   * SkuunAiAction findMany
   */
  export type SkuunAiActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiActions to fetch.
     */
    where?: SkuunAiActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiActions to fetch.
     */
    orderBy?: SkuunAiActionOrderByWithRelationInput | SkuunAiActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkuunAiActions.
     */
    cursor?: SkuunAiActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiActions.
     */
    skip?: number
    distinct?: SkuunAiActionScalarFieldEnum | SkuunAiActionScalarFieldEnum[]
  }

  /**
   * SkuunAiAction create
   */
  export type SkuunAiActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * The data needed to create a SkuunAiAction.
     */
    data: XOR<SkuunAiActionCreateInput, SkuunAiActionUncheckedCreateInput>
  }

  /**
   * SkuunAiAction createMany
   */
  export type SkuunAiActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkuunAiActions.
     */
    data: SkuunAiActionCreateManyInput | SkuunAiActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkuunAiAction createManyAndReturn
   */
  export type SkuunAiActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * The data used to create many SkuunAiActions.
     */
    data: SkuunAiActionCreateManyInput | SkuunAiActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuunAiAction update
   */
  export type SkuunAiActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * The data needed to update a SkuunAiAction.
     */
    data: XOR<SkuunAiActionUpdateInput, SkuunAiActionUncheckedUpdateInput>
    /**
     * Choose, which SkuunAiAction to update.
     */
    where: SkuunAiActionWhereUniqueInput
  }

  /**
   * SkuunAiAction updateMany
   */
  export type SkuunAiActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkuunAiActions.
     */
    data: XOR<SkuunAiActionUpdateManyMutationInput, SkuunAiActionUncheckedUpdateManyInput>
    /**
     * Filter which SkuunAiActions to update
     */
    where?: SkuunAiActionWhereInput
    /**
     * Limit how many SkuunAiActions to update.
     */
    limit?: number
  }

  /**
   * SkuunAiAction updateManyAndReturn
   */
  export type SkuunAiActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * The data used to update SkuunAiActions.
     */
    data: XOR<SkuunAiActionUpdateManyMutationInput, SkuunAiActionUncheckedUpdateManyInput>
    /**
     * Filter which SkuunAiActions to update
     */
    where?: SkuunAiActionWhereInput
    /**
     * Limit how many SkuunAiActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuunAiAction upsert
   */
  export type SkuunAiActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * The filter to search for the SkuunAiAction to update in case it exists.
     */
    where: SkuunAiActionWhereUniqueInput
    /**
     * In case the SkuunAiAction found by the `where` argument doesn't exist, create a new SkuunAiAction with this data.
     */
    create: XOR<SkuunAiActionCreateInput, SkuunAiActionUncheckedCreateInput>
    /**
     * In case the SkuunAiAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkuunAiActionUpdateInput, SkuunAiActionUncheckedUpdateInput>
  }

  /**
   * SkuunAiAction delete
   */
  export type SkuunAiActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
    /**
     * Filter which SkuunAiAction to delete.
     */
    where: SkuunAiActionWhereUniqueInput
  }

  /**
   * SkuunAiAction deleteMany
   */
  export type SkuunAiActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuunAiActions to delete
     */
    where?: SkuunAiActionWhereInput
    /**
     * Limit how many SkuunAiActions to delete.
     */
    limit?: number
  }

  /**
   * SkuunAiAction without action
   */
  export type SkuunAiActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiAction
     */
    select?: SkuunAiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiAction
     */
    omit?: SkuunAiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiActionInclude<ExtArgs> | null
  }


  /**
   * Model SkuunAiRecommendation
   */

  export type AggregateSkuunAiRecommendation = {
    _count: SkuunAiRecommendationCountAggregateOutputType | null
    _min: SkuunAiRecommendationMinAggregateOutputType | null
    _max: SkuunAiRecommendationMaxAggregateOutputType | null
  }

  export type SkuunAiRecommendationMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    category: string | null
    targetId: string | null
    message: string | null
    resolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkuunAiRecommendationMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    category: string | null
    targetId: string | null
    message: string | null
    resolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkuunAiRecommendationCountAggregateOutputType = {
    id: number
    sessionId: number
    category: number
    targetId: number
    message: number
    data: number
    resolved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkuunAiRecommendationMinAggregateInputType = {
    id?: true
    sessionId?: true
    category?: true
    targetId?: true
    message?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkuunAiRecommendationMaxAggregateInputType = {
    id?: true
    sessionId?: true
    category?: true
    targetId?: true
    message?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkuunAiRecommendationCountAggregateInputType = {
    id?: true
    sessionId?: true
    category?: true
    targetId?: true
    message?: true
    data?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkuunAiRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuunAiRecommendation to aggregate.
     */
    where?: SkuunAiRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiRecommendations to fetch.
     */
    orderBy?: SkuunAiRecommendationOrderByWithRelationInput | SkuunAiRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkuunAiRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkuunAiRecommendations
    **/
    _count?: true | SkuunAiRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkuunAiRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkuunAiRecommendationMaxAggregateInputType
  }

  export type GetSkuunAiRecommendationAggregateType<T extends SkuunAiRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateSkuunAiRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkuunAiRecommendation[P]>
      : GetScalarType<T[P], AggregateSkuunAiRecommendation[P]>
  }




  export type SkuunAiRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuunAiRecommendationWhereInput
    orderBy?: SkuunAiRecommendationOrderByWithAggregationInput | SkuunAiRecommendationOrderByWithAggregationInput[]
    by: SkuunAiRecommendationScalarFieldEnum[] | SkuunAiRecommendationScalarFieldEnum
    having?: SkuunAiRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkuunAiRecommendationCountAggregateInputType | true
    _min?: SkuunAiRecommendationMinAggregateInputType
    _max?: SkuunAiRecommendationMaxAggregateInputType
  }

  export type SkuunAiRecommendationGroupByOutputType = {
    id: string
    sessionId: string
    category: string
    targetId: string | null
    message: string
    data: JsonValue | null
    resolved: boolean
    createdAt: Date
    updatedAt: Date
    _count: SkuunAiRecommendationCountAggregateOutputType | null
    _min: SkuunAiRecommendationMinAggregateOutputType | null
    _max: SkuunAiRecommendationMaxAggregateOutputType | null
  }

  type GetSkuunAiRecommendationGroupByPayload<T extends SkuunAiRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkuunAiRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkuunAiRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkuunAiRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], SkuunAiRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type SkuunAiRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    category?: boolean
    targetId?: boolean
    message?: boolean
    data?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiRecommendation"]>

  export type SkuunAiRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    category?: boolean
    targetId?: boolean
    message?: boolean
    data?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiRecommendation"]>

  export type SkuunAiRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    category?: boolean
    targetId?: boolean
    message?: boolean
    data?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuunAiRecommendation"]>

  export type SkuunAiRecommendationSelectScalar = {
    id?: boolean
    sessionId?: boolean
    category?: boolean
    targetId?: boolean
    message?: boolean
    data?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkuunAiRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "category" | "targetId" | "message" | "data" | "resolved" | "createdAt" | "updatedAt", ExtArgs["result"]["skuunAiRecommendation"]>
  export type SkuunAiRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }
  export type SkuunAiRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }
  export type SkuunAiRecommendationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SkuunAiSessionDefaultArgs<ExtArgs>
  }

  export type $SkuunAiRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkuunAiRecommendation"
    objects: {
      session: Prisma.$SkuunAiSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      category: string
      targetId: string | null
      message: string
      data: Prisma.JsonValue | null
      resolved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skuunAiRecommendation"]>
    composites: {}
  }

  type SkuunAiRecommendationGetPayload<S extends boolean | null | undefined | SkuunAiRecommendationDefaultArgs> = $Result.GetResult<Prisma.$SkuunAiRecommendationPayload, S>

  type SkuunAiRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkuunAiRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkuunAiRecommendationCountAggregateInputType | true
    }

  export interface SkuunAiRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkuunAiRecommendation'], meta: { name: 'SkuunAiRecommendation' } }
    /**
     * Find zero or one SkuunAiRecommendation that matches the filter.
     * @param {SkuunAiRecommendationFindUniqueArgs} args - Arguments to find a SkuunAiRecommendation
     * @example
     * // Get one SkuunAiRecommendation
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkuunAiRecommendationFindUniqueArgs>(args: SelectSubset<T, SkuunAiRecommendationFindUniqueArgs<ExtArgs>>): Prisma__SkuunAiRecommendationClient<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkuunAiRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkuunAiRecommendationFindUniqueOrThrowArgs} args - Arguments to find a SkuunAiRecommendation
     * @example
     * // Get one SkuunAiRecommendation
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkuunAiRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, SkuunAiRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkuunAiRecommendationClient<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkuunAiRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiRecommendationFindFirstArgs} args - Arguments to find a SkuunAiRecommendation
     * @example
     * // Get one SkuunAiRecommendation
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkuunAiRecommendationFindFirstArgs>(args?: SelectSubset<T, SkuunAiRecommendationFindFirstArgs<ExtArgs>>): Prisma__SkuunAiRecommendationClient<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkuunAiRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiRecommendationFindFirstOrThrowArgs} args - Arguments to find a SkuunAiRecommendation
     * @example
     * // Get one SkuunAiRecommendation
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkuunAiRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, SkuunAiRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkuunAiRecommendationClient<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkuunAiRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkuunAiRecommendations
     * const skuunAiRecommendations = await prisma.skuunAiRecommendation.findMany()
     * 
     * // Get first 10 SkuunAiRecommendations
     * const skuunAiRecommendations = await prisma.skuunAiRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skuunAiRecommendationWithIdOnly = await prisma.skuunAiRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkuunAiRecommendationFindManyArgs>(args?: SelectSubset<T, SkuunAiRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkuunAiRecommendation.
     * @param {SkuunAiRecommendationCreateArgs} args - Arguments to create a SkuunAiRecommendation.
     * @example
     * // Create one SkuunAiRecommendation
     * const SkuunAiRecommendation = await prisma.skuunAiRecommendation.create({
     *   data: {
     *     // ... data to create a SkuunAiRecommendation
     *   }
     * })
     * 
     */
    create<T extends SkuunAiRecommendationCreateArgs>(args: SelectSubset<T, SkuunAiRecommendationCreateArgs<ExtArgs>>): Prisma__SkuunAiRecommendationClient<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkuunAiRecommendations.
     * @param {SkuunAiRecommendationCreateManyArgs} args - Arguments to create many SkuunAiRecommendations.
     * @example
     * // Create many SkuunAiRecommendations
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkuunAiRecommendationCreateManyArgs>(args?: SelectSubset<T, SkuunAiRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkuunAiRecommendations and returns the data saved in the database.
     * @param {SkuunAiRecommendationCreateManyAndReturnArgs} args - Arguments to create many SkuunAiRecommendations.
     * @example
     * // Create many SkuunAiRecommendations
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkuunAiRecommendations and only return the `id`
     * const skuunAiRecommendationWithIdOnly = await prisma.skuunAiRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkuunAiRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, SkuunAiRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SkuunAiRecommendation.
     * @param {SkuunAiRecommendationDeleteArgs} args - Arguments to delete one SkuunAiRecommendation.
     * @example
     * // Delete one SkuunAiRecommendation
     * const SkuunAiRecommendation = await prisma.skuunAiRecommendation.delete({
     *   where: {
     *     // ... filter to delete one SkuunAiRecommendation
     *   }
     * })
     * 
     */
    delete<T extends SkuunAiRecommendationDeleteArgs>(args: SelectSubset<T, SkuunAiRecommendationDeleteArgs<ExtArgs>>): Prisma__SkuunAiRecommendationClient<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkuunAiRecommendation.
     * @param {SkuunAiRecommendationUpdateArgs} args - Arguments to update one SkuunAiRecommendation.
     * @example
     * // Update one SkuunAiRecommendation
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkuunAiRecommendationUpdateArgs>(args: SelectSubset<T, SkuunAiRecommendationUpdateArgs<ExtArgs>>): Prisma__SkuunAiRecommendationClient<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkuunAiRecommendations.
     * @param {SkuunAiRecommendationDeleteManyArgs} args - Arguments to filter SkuunAiRecommendations to delete.
     * @example
     * // Delete a few SkuunAiRecommendations
     * const { count } = await prisma.skuunAiRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkuunAiRecommendationDeleteManyArgs>(args?: SelectSubset<T, SkuunAiRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuunAiRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkuunAiRecommendations
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkuunAiRecommendationUpdateManyArgs>(args: SelectSubset<T, SkuunAiRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuunAiRecommendations and returns the data updated in the database.
     * @param {SkuunAiRecommendationUpdateManyAndReturnArgs} args - Arguments to update many SkuunAiRecommendations.
     * @example
     * // Update many SkuunAiRecommendations
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkuunAiRecommendations and only return the `id`
     * const skuunAiRecommendationWithIdOnly = await prisma.skuunAiRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkuunAiRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, SkuunAiRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SkuunAiRecommendation.
     * @param {SkuunAiRecommendationUpsertArgs} args - Arguments to update or create a SkuunAiRecommendation.
     * @example
     * // Update or create a SkuunAiRecommendation
     * const skuunAiRecommendation = await prisma.skuunAiRecommendation.upsert({
     *   create: {
     *     // ... data to create a SkuunAiRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkuunAiRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends SkuunAiRecommendationUpsertArgs>(args: SelectSubset<T, SkuunAiRecommendationUpsertArgs<ExtArgs>>): Prisma__SkuunAiRecommendationClient<$Result.GetResult<Prisma.$SkuunAiRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SkuunAiRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiRecommendationCountArgs} args - Arguments to filter SkuunAiRecommendations to count.
     * @example
     * // Count the number of SkuunAiRecommendations
     * const count = await prisma.skuunAiRecommendation.count({
     *   where: {
     *     // ... the filter for the SkuunAiRecommendations we want to count
     *   }
     * })
    **/
    count<T extends SkuunAiRecommendationCountArgs>(
      args?: Subset<T, SkuunAiRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkuunAiRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkuunAiRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkuunAiRecommendationAggregateArgs>(args: Subset<T, SkuunAiRecommendationAggregateArgs>): Prisma.PrismaPromise<GetSkuunAiRecommendationAggregateType<T>>

    /**
     * Group by SkuunAiRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuunAiRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkuunAiRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkuunAiRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: SkuunAiRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkuunAiRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkuunAiRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkuunAiRecommendation model
   */
  readonly fields: SkuunAiRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkuunAiRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkuunAiRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SkuunAiSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkuunAiSessionDefaultArgs<ExtArgs>>): Prisma__SkuunAiSessionClient<$Result.GetResult<Prisma.$SkuunAiSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkuunAiRecommendation model
   */
  interface SkuunAiRecommendationFieldRefs {
    readonly id: FieldRef<"SkuunAiRecommendation", 'String'>
    readonly sessionId: FieldRef<"SkuunAiRecommendation", 'String'>
    readonly category: FieldRef<"SkuunAiRecommendation", 'String'>
    readonly targetId: FieldRef<"SkuunAiRecommendation", 'String'>
    readonly message: FieldRef<"SkuunAiRecommendation", 'String'>
    readonly data: FieldRef<"SkuunAiRecommendation", 'Json'>
    readonly resolved: FieldRef<"SkuunAiRecommendation", 'Boolean'>
    readonly createdAt: FieldRef<"SkuunAiRecommendation", 'DateTime'>
    readonly updatedAt: FieldRef<"SkuunAiRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkuunAiRecommendation findUnique
   */
  export type SkuunAiRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiRecommendation to fetch.
     */
    where: SkuunAiRecommendationWhereUniqueInput
  }

  /**
   * SkuunAiRecommendation findUniqueOrThrow
   */
  export type SkuunAiRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiRecommendation to fetch.
     */
    where: SkuunAiRecommendationWhereUniqueInput
  }

  /**
   * SkuunAiRecommendation findFirst
   */
  export type SkuunAiRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiRecommendation to fetch.
     */
    where?: SkuunAiRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiRecommendations to fetch.
     */
    orderBy?: SkuunAiRecommendationOrderByWithRelationInput | SkuunAiRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuunAiRecommendations.
     */
    cursor?: SkuunAiRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuunAiRecommendations.
     */
    distinct?: SkuunAiRecommendationScalarFieldEnum | SkuunAiRecommendationScalarFieldEnum[]
  }

  /**
   * SkuunAiRecommendation findFirstOrThrow
   */
  export type SkuunAiRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiRecommendation to fetch.
     */
    where?: SkuunAiRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiRecommendations to fetch.
     */
    orderBy?: SkuunAiRecommendationOrderByWithRelationInput | SkuunAiRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuunAiRecommendations.
     */
    cursor?: SkuunAiRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuunAiRecommendations.
     */
    distinct?: SkuunAiRecommendationScalarFieldEnum | SkuunAiRecommendationScalarFieldEnum[]
  }

  /**
   * SkuunAiRecommendation findMany
   */
  export type SkuunAiRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuunAiRecommendations to fetch.
     */
    where?: SkuunAiRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuunAiRecommendations to fetch.
     */
    orderBy?: SkuunAiRecommendationOrderByWithRelationInput | SkuunAiRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkuunAiRecommendations.
     */
    cursor?: SkuunAiRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuunAiRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuunAiRecommendations.
     */
    skip?: number
    distinct?: SkuunAiRecommendationScalarFieldEnum | SkuunAiRecommendationScalarFieldEnum[]
  }

  /**
   * SkuunAiRecommendation create
   */
  export type SkuunAiRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a SkuunAiRecommendation.
     */
    data: XOR<SkuunAiRecommendationCreateInput, SkuunAiRecommendationUncheckedCreateInput>
  }

  /**
   * SkuunAiRecommendation createMany
   */
  export type SkuunAiRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkuunAiRecommendations.
     */
    data: SkuunAiRecommendationCreateManyInput | SkuunAiRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkuunAiRecommendation createManyAndReturn
   */
  export type SkuunAiRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many SkuunAiRecommendations.
     */
    data: SkuunAiRecommendationCreateManyInput | SkuunAiRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuunAiRecommendation update
   */
  export type SkuunAiRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a SkuunAiRecommendation.
     */
    data: XOR<SkuunAiRecommendationUpdateInput, SkuunAiRecommendationUncheckedUpdateInput>
    /**
     * Choose, which SkuunAiRecommendation to update.
     */
    where: SkuunAiRecommendationWhereUniqueInput
  }

  /**
   * SkuunAiRecommendation updateMany
   */
  export type SkuunAiRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkuunAiRecommendations.
     */
    data: XOR<SkuunAiRecommendationUpdateManyMutationInput, SkuunAiRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which SkuunAiRecommendations to update
     */
    where?: SkuunAiRecommendationWhereInput
    /**
     * Limit how many SkuunAiRecommendations to update.
     */
    limit?: number
  }

  /**
   * SkuunAiRecommendation updateManyAndReturn
   */
  export type SkuunAiRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update SkuunAiRecommendations.
     */
    data: XOR<SkuunAiRecommendationUpdateManyMutationInput, SkuunAiRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which SkuunAiRecommendations to update
     */
    where?: SkuunAiRecommendationWhereInput
    /**
     * Limit how many SkuunAiRecommendations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuunAiRecommendation upsert
   */
  export type SkuunAiRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the SkuunAiRecommendation to update in case it exists.
     */
    where: SkuunAiRecommendationWhereUniqueInput
    /**
     * In case the SkuunAiRecommendation found by the `where` argument doesn't exist, create a new SkuunAiRecommendation with this data.
     */
    create: XOR<SkuunAiRecommendationCreateInput, SkuunAiRecommendationUncheckedCreateInput>
    /**
     * In case the SkuunAiRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkuunAiRecommendationUpdateInput, SkuunAiRecommendationUncheckedUpdateInput>
  }

  /**
   * SkuunAiRecommendation delete
   */
  export type SkuunAiRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
    /**
     * Filter which SkuunAiRecommendation to delete.
     */
    where: SkuunAiRecommendationWhereUniqueInput
  }

  /**
   * SkuunAiRecommendation deleteMany
   */
  export type SkuunAiRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuunAiRecommendations to delete
     */
    where?: SkuunAiRecommendationWhereInput
    /**
     * Limit how many SkuunAiRecommendations to delete.
     */
    limit?: number
  }

  /**
   * SkuunAiRecommendation without action
   */
  export type SkuunAiRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuunAiRecommendation
     */
    select?: SkuunAiRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkuunAiRecommendation
     */
    omit?: SkuunAiRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuunAiRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model DecisionRecord
   */

  export type AggregateDecisionRecord = {
    _count: DecisionRecordCountAggregateOutputType | null
    _min: DecisionRecordMinAggregateOutputType | null
    _max: DecisionRecordMaxAggregateOutputType | null
  }

  export type DecisionRecordMinAggregateOutputType = {
    id: string | null
    title: string | null
    context: string | null
    decision: string | null
    consequences: string | null
    status: $Enums.DecisionStatus | null
    supersedesId: string | null
    authorId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    implementedAt: Date | null
  }

  export type DecisionRecordMaxAggregateOutputType = {
    id: string | null
    title: string | null
    context: string | null
    decision: string | null
    consequences: string | null
    status: $Enums.DecisionStatus | null
    supersedesId: string | null
    authorId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    implementedAt: Date | null
  }

  export type DecisionRecordCountAggregateOutputType = {
    id: number
    title: number
    context: number
    decision: number
    consequences: number
    status: number
    supersedesId: number
    authorId: number
    schoolId: number
    createdAt: number
    updatedAt: number
    implementedAt: number
    _all: number
  }


  export type DecisionRecordMinAggregateInputType = {
    id?: true
    title?: true
    context?: true
    decision?: true
    consequences?: true
    status?: true
    supersedesId?: true
    authorId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    implementedAt?: true
  }

  export type DecisionRecordMaxAggregateInputType = {
    id?: true
    title?: true
    context?: true
    decision?: true
    consequences?: true
    status?: true
    supersedesId?: true
    authorId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    implementedAt?: true
  }

  export type DecisionRecordCountAggregateInputType = {
    id?: true
    title?: true
    context?: true
    decision?: true
    consequences?: true
    status?: true
    supersedesId?: true
    authorId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    implementedAt?: true
    _all?: true
  }

  export type DecisionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DecisionRecord to aggregate.
     */
    where?: DecisionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionRecords to fetch.
     */
    orderBy?: DecisionRecordOrderByWithRelationInput | DecisionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DecisionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DecisionRecords
    **/
    _count?: true | DecisionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DecisionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DecisionRecordMaxAggregateInputType
  }

  export type GetDecisionRecordAggregateType<T extends DecisionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateDecisionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecisionRecord[P]>
      : GetScalarType<T[P], AggregateDecisionRecord[P]>
  }




  export type DecisionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionRecordWhereInput
    orderBy?: DecisionRecordOrderByWithAggregationInput | DecisionRecordOrderByWithAggregationInput[]
    by: DecisionRecordScalarFieldEnum[] | DecisionRecordScalarFieldEnum
    having?: DecisionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DecisionRecordCountAggregateInputType | true
    _min?: DecisionRecordMinAggregateInputType
    _max?: DecisionRecordMaxAggregateInputType
  }

  export type DecisionRecordGroupByOutputType = {
    id: string
    title: string
    context: string
    decision: string
    consequences: string
    status: $Enums.DecisionStatus
    supersedesId: string | null
    authorId: string
    schoolId: string
    createdAt: Date
    updatedAt: Date
    implementedAt: Date | null
    _count: DecisionRecordCountAggregateOutputType | null
    _min: DecisionRecordMinAggregateOutputType | null
    _max: DecisionRecordMaxAggregateOutputType | null
  }

  type GetDecisionRecordGroupByPayload<T extends DecisionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DecisionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DecisionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DecisionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], DecisionRecordGroupByOutputType[P]>
        }
      >
    >


  export type DecisionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    context?: boolean
    decision?: boolean
    consequences?: boolean
    status?: boolean
    supersedesId?: boolean
    authorId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    implementedAt?: boolean
    supersedes?: boolean | DecisionRecord$supersedesArgs<ExtArgs>
    supersededBy?: boolean | DecisionRecord$supersededByArgs<ExtArgs>
    _count?: boolean | DecisionRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decisionRecord"]>

  export type DecisionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    context?: boolean
    decision?: boolean
    consequences?: boolean
    status?: boolean
    supersedesId?: boolean
    authorId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    implementedAt?: boolean
    supersedes?: boolean | DecisionRecord$supersedesArgs<ExtArgs>
  }, ExtArgs["result"]["decisionRecord"]>

  export type DecisionRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    context?: boolean
    decision?: boolean
    consequences?: boolean
    status?: boolean
    supersedesId?: boolean
    authorId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    implementedAt?: boolean
    supersedes?: boolean | DecisionRecord$supersedesArgs<ExtArgs>
  }, ExtArgs["result"]["decisionRecord"]>

  export type DecisionRecordSelectScalar = {
    id?: boolean
    title?: boolean
    context?: boolean
    decision?: boolean
    consequences?: boolean
    status?: boolean
    supersedesId?: boolean
    authorId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    implementedAt?: boolean
  }

  export type DecisionRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "context" | "decision" | "consequences" | "status" | "supersedesId" | "authorId" | "schoolId" | "createdAt" | "updatedAt" | "implementedAt", ExtArgs["result"]["decisionRecord"]>
  export type DecisionRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supersedes?: boolean | DecisionRecord$supersedesArgs<ExtArgs>
    supersededBy?: boolean | DecisionRecord$supersededByArgs<ExtArgs>
    _count?: boolean | DecisionRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DecisionRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supersedes?: boolean | DecisionRecord$supersedesArgs<ExtArgs>
  }
  export type DecisionRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supersedes?: boolean | DecisionRecord$supersedesArgs<ExtArgs>
  }

  export type $DecisionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DecisionRecord"
    objects: {
      supersedes: Prisma.$DecisionRecordPayload<ExtArgs> | null
      supersededBy: Prisma.$DecisionRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      context: string
      decision: string
      consequences: string
      status: $Enums.DecisionStatus
      supersedesId: string | null
      authorId: string
      schoolId: string
      createdAt: Date
      updatedAt: Date
      implementedAt: Date | null
    }, ExtArgs["result"]["decisionRecord"]>
    composites: {}
  }

  type DecisionRecordGetPayload<S extends boolean | null | undefined | DecisionRecordDefaultArgs> = $Result.GetResult<Prisma.$DecisionRecordPayload, S>

  type DecisionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DecisionRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DecisionRecordCountAggregateInputType | true
    }

  export interface DecisionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DecisionRecord'], meta: { name: 'DecisionRecord' } }
    /**
     * Find zero or one DecisionRecord that matches the filter.
     * @param {DecisionRecordFindUniqueArgs} args - Arguments to find a DecisionRecord
     * @example
     * // Get one DecisionRecord
     * const decisionRecord = await prisma.decisionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DecisionRecordFindUniqueArgs>(args: SelectSubset<T, DecisionRecordFindUniqueArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DecisionRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DecisionRecordFindUniqueOrThrowArgs} args - Arguments to find a DecisionRecord
     * @example
     * // Get one DecisionRecord
     * const decisionRecord = await prisma.decisionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DecisionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, DecisionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DecisionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionRecordFindFirstArgs} args - Arguments to find a DecisionRecord
     * @example
     * // Get one DecisionRecord
     * const decisionRecord = await prisma.decisionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DecisionRecordFindFirstArgs>(args?: SelectSubset<T, DecisionRecordFindFirstArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DecisionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionRecordFindFirstOrThrowArgs} args - Arguments to find a DecisionRecord
     * @example
     * // Get one DecisionRecord
     * const decisionRecord = await prisma.decisionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DecisionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, DecisionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DecisionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DecisionRecords
     * const decisionRecords = await prisma.decisionRecord.findMany()
     * 
     * // Get first 10 DecisionRecords
     * const decisionRecords = await prisma.decisionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const decisionRecordWithIdOnly = await prisma.decisionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DecisionRecordFindManyArgs>(args?: SelectSubset<T, DecisionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DecisionRecord.
     * @param {DecisionRecordCreateArgs} args - Arguments to create a DecisionRecord.
     * @example
     * // Create one DecisionRecord
     * const DecisionRecord = await prisma.decisionRecord.create({
     *   data: {
     *     // ... data to create a DecisionRecord
     *   }
     * })
     * 
     */
    create<T extends DecisionRecordCreateArgs>(args: SelectSubset<T, DecisionRecordCreateArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DecisionRecords.
     * @param {DecisionRecordCreateManyArgs} args - Arguments to create many DecisionRecords.
     * @example
     * // Create many DecisionRecords
     * const decisionRecord = await prisma.decisionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DecisionRecordCreateManyArgs>(args?: SelectSubset<T, DecisionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DecisionRecords and returns the data saved in the database.
     * @param {DecisionRecordCreateManyAndReturnArgs} args - Arguments to create many DecisionRecords.
     * @example
     * // Create many DecisionRecords
     * const decisionRecord = await prisma.decisionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DecisionRecords and only return the `id`
     * const decisionRecordWithIdOnly = await prisma.decisionRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DecisionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, DecisionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DecisionRecord.
     * @param {DecisionRecordDeleteArgs} args - Arguments to delete one DecisionRecord.
     * @example
     * // Delete one DecisionRecord
     * const DecisionRecord = await prisma.decisionRecord.delete({
     *   where: {
     *     // ... filter to delete one DecisionRecord
     *   }
     * })
     * 
     */
    delete<T extends DecisionRecordDeleteArgs>(args: SelectSubset<T, DecisionRecordDeleteArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DecisionRecord.
     * @param {DecisionRecordUpdateArgs} args - Arguments to update one DecisionRecord.
     * @example
     * // Update one DecisionRecord
     * const decisionRecord = await prisma.decisionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DecisionRecordUpdateArgs>(args: SelectSubset<T, DecisionRecordUpdateArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DecisionRecords.
     * @param {DecisionRecordDeleteManyArgs} args - Arguments to filter DecisionRecords to delete.
     * @example
     * // Delete a few DecisionRecords
     * const { count } = await prisma.decisionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DecisionRecordDeleteManyArgs>(args?: SelectSubset<T, DecisionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DecisionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DecisionRecords
     * const decisionRecord = await prisma.decisionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DecisionRecordUpdateManyArgs>(args: SelectSubset<T, DecisionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DecisionRecords and returns the data updated in the database.
     * @param {DecisionRecordUpdateManyAndReturnArgs} args - Arguments to update many DecisionRecords.
     * @example
     * // Update many DecisionRecords
     * const decisionRecord = await prisma.decisionRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DecisionRecords and only return the `id`
     * const decisionRecordWithIdOnly = await prisma.decisionRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DecisionRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, DecisionRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DecisionRecord.
     * @param {DecisionRecordUpsertArgs} args - Arguments to update or create a DecisionRecord.
     * @example
     * // Update or create a DecisionRecord
     * const decisionRecord = await prisma.decisionRecord.upsert({
     *   create: {
     *     // ... data to create a DecisionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DecisionRecord we want to update
     *   }
     * })
     */
    upsert<T extends DecisionRecordUpsertArgs>(args: SelectSubset<T, DecisionRecordUpsertArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DecisionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionRecordCountArgs} args - Arguments to filter DecisionRecords to count.
     * @example
     * // Count the number of DecisionRecords
     * const count = await prisma.decisionRecord.count({
     *   where: {
     *     // ... the filter for the DecisionRecords we want to count
     *   }
     * })
    **/
    count<T extends DecisionRecordCountArgs>(
      args?: Subset<T, DecisionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DecisionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DecisionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DecisionRecordAggregateArgs>(args: Subset<T, DecisionRecordAggregateArgs>): Prisma.PrismaPromise<GetDecisionRecordAggregateType<T>>

    /**
     * Group by DecisionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DecisionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DecisionRecordGroupByArgs['orderBy'] }
        : { orderBy?: DecisionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DecisionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDecisionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DecisionRecord model
   */
  readonly fields: DecisionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DecisionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DecisionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supersedes<T extends DecisionRecord$supersedesArgs<ExtArgs> = {}>(args?: Subset<T, DecisionRecord$supersedesArgs<ExtArgs>>): Prisma__DecisionRecordClient<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supersededBy<T extends DecisionRecord$supersededByArgs<ExtArgs> = {}>(args?: Subset<T, DecisionRecord$supersededByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DecisionRecord model
   */
  interface DecisionRecordFieldRefs {
    readonly id: FieldRef<"DecisionRecord", 'String'>
    readonly title: FieldRef<"DecisionRecord", 'String'>
    readonly context: FieldRef<"DecisionRecord", 'String'>
    readonly decision: FieldRef<"DecisionRecord", 'String'>
    readonly consequences: FieldRef<"DecisionRecord", 'String'>
    readonly status: FieldRef<"DecisionRecord", 'DecisionStatus'>
    readonly supersedesId: FieldRef<"DecisionRecord", 'String'>
    readonly authorId: FieldRef<"DecisionRecord", 'String'>
    readonly schoolId: FieldRef<"DecisionRecord", 'String'>
    readonly createdAt: FieldRef<"DecisionRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"DecisionRecord", 'DateTime'>
    readonly implementedAt: FieldRef<"DecisionRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DecisionRecord findUnique
   */
  export type DecisionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * Filter, which DecisionRecord to fetch.
     */
    where: DecisionRecordWhereUniqueInput
  }

  /**
   * DecisionRecord findUniqueOrThrow
   */
  export type DecisionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * Filter, which DecisionRecord to fetch.
     */
    where: DecisionRecordWhereUniqueInput
  }

  /**
   * DecisionRecord findFirst
   */
  export type DecisionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * Filter, which DecisionRecord to fetch.
     */
    where?: DecisionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionRecords to fetch.
     */
    orderBy?: DecisionRecordOrderByWithRelationInput | DecisionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DecisionRecords.
     */
    cursor?: DecisionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DecisionRecords.
     */
    distinct?: DecisionRecordScalarFieldEnum | DecisionRecordScalarFieldEnum[]
  }

  /**
   * DecisionRecord findFirstOrThrow
   */
  export type DecisionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * Filter, which DecisionRecord to fetch.
     */
    where?: DecisionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionRecords to fetch.
     */
    orderBy?: DecisionRecordOrderByWithRelationInput | DecisionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DecisionRecords.
     */
    cursor?: DecisionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DecisionRecords.
     */
    distinct?: DecisionRecordScalarFieldEnum | DecisionRecordScalarFieldEnum[]
  }

  /**
   * DecisionRecord findMany
   */
  export type DecisionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * Filter, which DecisionRecords to fetch.
     */
    where?: DecisionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionRecords to fetch.
     */
    orderBy?: DecisionRecordOrderByWithRelationInput | DecisionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DecisionRecords.
     */
    cursor?: DecisionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionRecords.
     */
    skip?: number
    distinct?: DecisionRecordScalarFieldEnum | DecisionRecordScalarFieldEnum[]
  }

  /**
   * DecisionRecord create
   */
  export type DecisionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a DecisionRecord.
     */
    data: XOR<DecisionRecordCreateInput, DecisionRecordUncheckedCreateInput>
  }

  /**
   * DecisionRecord createMany
   */
  export type DecisionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DecisionRecords.
     */
    data: DecisionRecordCreateManyInput | DecisionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DecisionRecord createManyAndReturn
   */
  export type DecisionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * The data used to create many DecisionRecords.
     */
    data: DecisionRecordCreateManyInput | DecisionRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DecisionRecord update
   */
  export type DecisionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a DecisionRecord.
     */
    data: XOR<DecisionRecordUpdateInput, DecisionRecordUncheckedUpdateInput>
    /**
     * Choose, which DecisionRecord to update.
     */
    where: DecisionRecordWhereUniqueInput
  }

  /**
   * DecisionRecord updateMany
   */
  export type DecisionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DecisionRecords.
     */
    data: XOR<DecisionRecordUpdateManyMutationInput, DecisionRecordUncheckedUpdateManyInput>
    /**
     * Filter which DecisionRecords to update
     */
    where?: DecisionRecordWhereInput
    /**
     * Limit how many DecisionRecords to update.
     */
    limit?: number
  }

  /**
   * DecisionRecord updateManyAndReturn
   */
  export type DecisionRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * The data used to update DecisionRecords.
     */
    data: XOR<DecisionRecordUpdateManyMutationInput, DecisionRecordUncheckedUpdateManyInput>
    /**
     * Filter which DecisionRecords to update
     */
    where?: DecisionRecordWhereInput
    /**
     * Limit how many DecisionRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DecisionRecord upsert
   */
  export type DecisionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the DecisionRecord to update in case it exists.
     */
    where: DecisionRecordWhereUniqueInput
    /**
     * In case the DecisionRecord found by the `where` argument doesn't exist, create a new DecisionRecord with this data.
     */
    create: XOR<DecisionRecordCreateInput, DecisionRecordUncheckedCreateInput>
    /**
     * In case the DecisionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DecisionRecordUpdateInput, DecisionRecordUncheckedUpdateInput>
  }

  /**
   * DecisionRecord delete
   */
  export type DecisionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    /**
     * Filter which DecisionRecord to delete.
     */
    where: DecisionRecordWhereUniqueInput
  }

  /**
   * DecisionRecord deleteMany
   */
  export type DecisionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DecisionRecords to delete
     */
    where?: DecisionRecordWhereInput
    /**
     * Limit how many DecisionRecords to delete.
     */
    limit?: number
  }

  /**
   * DecisionRecord.supersedes
   */
  export type DecisionRecord$supersedesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    where?: DecisionRecordWhereInput
  }

  /**
   * DecisionRecord.supersededBy
   */
  export type DecisionRecord$supersededByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
    where?: DecisionRecordWhereInput
    orderBy?: DecisionRecordOrderByWithRelationInput | DecisionRecordOrderByWithRelationInput[]
    cursor?: DecisionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionRecordScalarFieldEnum | DecisionRecordScalarFieldEnum[]
  }

  /**
   * DecisionRecord without action
   */
  export type DecisionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionRecord
     */
    select?: DecisionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionRecord
     */
    omit?: DecisionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionRecordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    email: 'email',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    surname: 'surname',
    firstName: 'firstName',
    otherNames: 'otherNames',
    email: 'email',
    password: 'password',
    role: 'role',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    schoolId: 'schoolId',
    enrolledAt: 'enrolledAt',
    classId: 'classId',
    gradeId: 'gradeId'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    classId: 'classId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    studentId: 'studentId',
    classId: 'classId',
    subjectId: 'subjectId',
    score: 'score',
    maxScore: 'maxScore',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    userId: 'userId',
    schoolId: 'schoolId',
    admissionPaymentId: 'admissionPaymentId',
    dateOfBirth: 'dateOfBirth',
    nationality: 'nationality',
    sex: 'sex',
    languages: 'languages',
    gradeId: 'gradeId',
    mothersTongue: 'mothersTongue',
    religion: 'religion',
    denomination: 'denomination',
    hometown: 'hometown',
    region: 'region',
    profilePicture: 'profilePicture',
    wardLivesWith: 'wardLivesWith',
    numberOfSiblings: 'numberOfSiblings',
    siblingsOlder: 'siblingsOlder',
    siblingsYounger: 'siblingsYounger',
    postalAddress: 'postalAddress',
    residentialAddress: 'residentialAddress',
    wardMobile: 'wardMobile',
    emergencyContact: 'emergencyContact',
    emergencyMedicalContact: 'emergencyMedicalContact',
    medicalSummary: 'medicalSummary',
    bloodType: 'bloodType',
    specialDisability: 'specialDisability',
    feesAcknowledged: 'feesAcknowledged',
    declarationSigned: 'declarationSigned',
    signature: 'signature',
    submissionDate: 'submissionDate',
    classification: 'classification',
    submittedBy: 'submittedBy',
    receivedBy: 'receivedBy',
    receivedDate: 'receivedDate',
    remarks: 'remarks',
    status: 'status',
    progress: 'progress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const PreviousSchoolScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    name: 'name',
    location: 'location',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PreviousSchoolScalarFieldEnum = (typeof PreviousSchoolScalarFieldEnum)[keyof typeof PreviousSchoolScalarFieldEnum]


  export const FamilyMemberScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    relation: 'relation',
    name: 'name',
    postalAddress: 'postalAddress',
    residentialAddress: 'residentialAddress',
    phone: 'phone',
    email: 'email',
    occupation: 'occupation',
    workplace: 'workplace',
    religion: 'religion',
    isAlive: 'isAlive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FamilyMemberScalarFieldEnum = (typeof FamilyMemberScalarFieldEnum)[keyof typeof FamilyMemberScalarFieldEnum]


  export const StaffApplicationScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    schoolId: 'schoolId',
    surname: 'surname',
    firstName: 'firstName',
    otherNames: 'otherNames',
    dateOfBirth: 'dateOfBirth',
    nationality: 'nationality',
    sex: 'sex',
    languages: 'languages',
    maritalStatus: 'maritalStatus',
    religion: 'religion',
    denomination: 'denomination',
    hometown: 'hometown',
    region: 'region',
    profilePicture: 'profilePicture',
    residentialAddress: 'residentialAddress',
    postalAddress: 'postalAddress',
    mobile: 'mobile',
    email: 'email',
    emergencyContact: 'emergencyContact',
    nextOfKin: 'nextOfKin',
    position: 'position',
    departmentId: 'departmentId',
    hireDate: 'hireDate',
    salary: 'salary',
    qualifications: 'qualifications',
    bloodType: 'bloodType',
    medicalConditions: 'medicalConditions',
    specialDisability: 'specialDisability',
    declarationSigned: 'declarationSigned',
    signature: 'signature',
    submissionDate: 'submissionDate',
    classification: 'classification',
    submittedBy: 'submittedBy',
    receivedBy: 'receivedBy',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffApplicationScalarFieldEnum = (typeof StaffApplicationScalarFieldEnum)[keyof typeof StaffApplicationScalarFieldEnum]


  export const PreviousJobScalarFieldEnum: {
    id: 'id',
    staffApplicationId: 'staffApplicationId',
    company: 'company',
    role: 'role',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PreviousJobScalarFieldEnum = (typeof PreviousJobScalarFieldEnum)[keyof typeof PreviousJobScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    classId: 'classId',
    position: 'position',
    salary: 'salary',
    hireDate: 'hireDate',
    departmentId: 'departmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const StudentAttendanceScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    date: 'date',
    status: 'status',
    timeIn: 'timeIn',
    timeOut: 'timeOut',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentAttendanceScalarFieldEnum = (typeof StudentAttendanceScalarFieldEnum)[keyof typeof StudentAttendanceScalarFieldEnum]


  export const StaffAttendanceScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    date: 'date',
    status: 'status',
    timeIn: 'timeIn',
    timeOut: 'timeOut',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffAttendanceScalarFieldEnum = (typeof StaffAttendanceScalarFieldEnum)[keyof typeof StaffAttendanceScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const AuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isbn: 'isbn',
    authorId: 'authorId',
    categoryId: 'categoryId',
    totalCopies: 'totalCopies',
    available: 'available',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const BorrowScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    studentId: 'studentId',
    borrowedAt: 'borrowedAt',
    dueAt: 'dueAt',
    returnedAt: 'returnedAt',
    fine: 'fine',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BorrowScalarFieldEnum = (typeof BorrowScalarFieldEnum)[keyof typeof BorrowScalarFieldEnum]


  export const LibraryStaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    departmentId: 'departmentId',
    position: 'position',
    hireDate: 'hireDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryStaffScalarFieldEnum = (typeof LibraryStaffScalarFieldEnum)[keyof typeof LibraryStaffScalarFieldEnum]


  export const AdmissionPaymentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    schoolId: 'schoolId',
    amount: 'amount',
    pinCode: 'pinCode',
    used: 'used',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionPaymentScalarFieldEnum = (typeof AdmissionPaymentScalarFieldEnum)[keyof typeof AdmissionPaymentScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    type: 'type',
    feeType: 'feeType',
    amount: 'amount',
    date: 'date',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const FinanceScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    type: 'type',
    amount: 'amount',
    description: 'description',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinanceScalarFieldEnum = (typeof FinanceScalarFieldEnum)[keyof typeof FinanceScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    unitPrice: 'unitPrice',
    quantity: 'quantity',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    resourceId: 'resourceId',
    quantity: 'quantity',
    totalCost: 'totalCost',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const BusScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    plateNumber: 'plateNumber',
    driverName: 'driverName',
    capacity: 'capacity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusScalarFieldEnum = (typeof BusScalarFieldEnum)[keyof typeof BusScalarFieldEnum]


  export const SkuunAiSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkuunAiSessionScalarFieldEnum = (typeof SkuunAiSessionScalarFieldEnum)[keyof typeof SkuunAiSessionScalarFieldEnum]


  export const SkuunAiMessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    sender: 'sender',
    type: 'type',
    content: 'content',
    payload: 'payload',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkuunAiMessageScalarFieldEnum = (typeof SkuunAiMessageScalarFieldEnum)[keyof typeof SkuunAiMessageScalarFieldEnum]


  export const SkuunAiActionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    type: 'type',
    payload: 'payload',
    status: 'status',
    executedAt: 'executedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkuunAiActionScalarFieldEnum = (typeof SkuunAiActionScalarFieldEnum)[keyof typeof SkuunAiActionScalarFieldEnum]


  export const SkuunAiRecommendationScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    category: 'category',
    targetId: 'targetId',
    message: 'message',
    data: 'data',
    resolved: 'resolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkuunAiRecommendationScalarFieldEnum = (typeof SkuunAiRecommendationScalarFieldEnum)[keyof typeof SkuunAiRecommendationScalarFieldEnum]


  export const DecisionRecordScalarFieldEnum: {
    id: 'id',
    title: 'title',
    context: 'context',
    decision: 'decision',
    consequences: 'consequences',
    status: 'status',
    supersedesId: 'supersedesId',
    authorId: 'authorId',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    implementedAt: 'implementedAt'
  };

  export type DecisionRecordScalarFieldEnum = (typeof DecisionRecordScalarFieldEnum)[keyof typeof DecisionRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'FinanceType'
   */
  export type EnumFinanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceType'>
    


  /**
   * Reference to a field of type 'FinanceType[]'
   */
  export type ListEnumFinanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinanceType[]'>
    


  /**
   * Reference to a field of type 'FeeType'
   */
  export type EnumFeeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeType'>
    


  /**
   * Reference to a field of type 'FeeType[]'
   */
  export type ListEnumFeeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeType[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AIActionType'
   */
  export type EnumAIActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIActionType'>
    


  /**
   * Reference to a field of type 'AIActionType[]'
   */
  export type ListEnumAIActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIActionType[]'>
    


  /**
   * Reference to a field of type 'ActionStatus'
   */
  export type EnumActionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionStatus'>
    


  /**
   * Reference to a field of type 'ActionStatus[]'
   */
  export type ListEnumActionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionStatus[]'>
    


  /**
   * Reference to a field of type 'DecisionStatus'
   */
  export type EnumDecisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DecisionStatus'>
    


  /**
   * Reference to a field of type 'DecisionStatus[]'
   */
  export type ListEnumDecisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DecisionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    domain?: StringFilter<"School"> | string
    email?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    classes?: ClassListRelationFilter
    buses?: BusListRelationFilter
    finances?: FinanceListRelationFilter
    activities?: ActivityListRelationFilter
    resources?: ResourceListRelationFilter
    Book?: BookListRelationFilter
    applications?: ApplicationListRelationFilter
    StaffApplication?: StaffApplicationListRelationFilter
    Student?: StudentListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    email?: SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    buses?: BusOrderByRelationAggregateInput
    finances?: FinanceOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    resources?: ResourceOrderByRelationAggregateInput
    Book?: BookOrderByRelationAggregateInput
    applications?: ApplicationOrderByRelationAggregateInput
    StaffApplication?: StaffApplicationOrderByRelationAggregateInput
    Student?: StudentOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    domain?: string
    email?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    address?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    classes?: ClassListRelationFilter
    buses?: BusListRelationFilter
    finances?: FinanceListRelationFilter
    activities?: ActivityListRelationFilter
    resources?: ResourceListRelationFilter
    Book?: BookListRelationFilter
    applications?: ApplicationListRelationFilter
    StaffApplication?: StaffApplicationListRelationFilter
    Student?: StudentListRelationFilter
  }, "id" | "name" | "domain" | "email">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    email?: SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    domain?: StringWithAggregatesFilter<"School"> | string
    email?: StringWithAggregatesFilter<"School"> | string
    address?: StringNullableWithAggregatesFilter<"School"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    surname?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    otherNames?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    LibraryStaff?: XOR<LibraryStaffNullableScalarRelationFilter, LibraryStaffWhereInput> | null
    createdSubjects?: SubjectListRelationFilter
    application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null
    SkuunAiSession?: SkuunAiSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
    LibraryStaff?: LibraryStaffOrderByWithRelationInput
    createdSubjects?: SubjectOrderByRelationAggregateInput
    application?: ApplicationOrderByWithRelationInput
    SkuunAiSession?: SkuunAiSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    surname?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    otherNames?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    LibraryStaff?: XOR<LibraryStaffNullableScalarRelationFilter, LibraryStaffWhereInput> | null
    createdSubjects?: SubjectListRelationFilter
    application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null
    SkuunAiSession?: SkuunAiSessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    surname?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    otherNames?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    schoolId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    name?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    enrolledAt?: DateTimeFilter<"Student"> | Date | string
    classId?: StringNullableFilter<"Student"> | string | null
    gradeId?: StringNullableFilter<"Student"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    subjects?: SubjectListRelationFilter
    application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null
    Class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    Exam?: ExamListRelationFilter
    StudentAttendance?: StudentAttendanceListRelationFilter
    Parent?: ParentListRelationFilter
    Borrow?: BorrowListRelationFilter
    Transaction?: TransactionListRelationFilter
    Purchase?: PurchaseListRelationFilter
    Grade?: XOR<GradeNullableScalarRelationFilter, GradeWhereInput> | null
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    enrolledAt?: SortOrder
    classId?: SortOrderInput | SortOrder
    gradeId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    subjects?: SubjectOrderByRelationAggregateInput
    application?: ApplicationOrderByWithRelationInput
    Class?: ClassOrderByWithRelationInput
    Exam?: ExamOrderByRelationAggregateInput
    StudentAttendance?: StudentAttendanceOrderByRelationAggregateInput
    Parent?: ParentOrderByRelationAggregateInput
    Borrow?: BorrowOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
    Purchase?: PurchaseOrderByRelationAggregateInput
    Grade?: GradeOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    name?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    enrolledAt?: DateTimeFilter<"Student"> | Date | string
    classId?: StringNullableFilter<"Student"> | string | null
    gradeId?: StringNullableFilter<"Student"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    subjects?: SubjectListRelationFilter
    application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null
    Class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    Exam?: ExamListRelationFilter
    StudentAttendance?: StudentAttendanceListRelationFilter
    Parent?: ParentListRelationFilter
    Borrow?: BorrowListRelationFilter
    Transaction?: TransactionListRelationFilter
    Purchase?: PurchaseListRelationFilter
    Grade?: XOR<GradeNullableScalarRelationFilter, GradeWhereInput> | null
  }, "id" | "userId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    enrolledAt?: SortOrder
    classId?: SortOrderInput | SortOrder
    gradeId?: SortOrderInput | SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    name?: StringNullableWithAggregatesFilter<"Student"> | string | null
    schoolId?: StringWithAggregatesFilter<"Student"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    classId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    gradeId?: StringNullableWithAggregatesFilter<"Student"> | string | null
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    grades?: GradeListRelationFilter
    students?: StudentListRelationFilter
    staff?: StaffListRelationFilter
    exams?: ExamListRelationFilter
    subjects?: SubjectListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    grades?: GradeOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    staff?: StaffOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_schoolId?: ClassNameSchoolIdCompoundUniqueInput
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    grades?: GradeListRelationFilter
    students?: StudentListRelationFilter
    staff?: StaffListRelationFilter
    exams?: ExamListRelationFilter
    subjects?: SubjectListRelationFilter
  }, "id" | "name_schoolId">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    schoolId?: StringWithAggregatesFilter<"Class"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    name?: StringFilter<"Grade"> | string
    classId?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    students?: StudentListRelationFilter
    staff?: StaffListRelationFilter
    Application?: ApplicationListRelationFilter
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    classId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    staff?: StaffOrderByRelationAggregateInput
    Application?: ApplicationOrderByRelationAggregateInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_classId?: GradeNameClassIdCompoundUniqueInput
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    name?: StringFilter<"Grade"> | string
    classId?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    students?: StudentListRelationFilter
    staff?: StaffListRelationFilter
    Application?: ApplicationListRelationFilter
  }, "id" | "name_classId">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    classId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    name?: StringWithAggregatesFilter<"Grade"> | string
    classId?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    createdById?: StringNullableFilter<"Subject"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    exams?: ExamListRelationFilter
    staff?: StaffListRelationFilter
    students?: StudentListRelationFilter
    classes?: ClassListRelationFilter
    staffApplications?: StaffApplicationListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    exams?: ExamOrderByRelationAggregateInput
    staff?: StaffOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    staffApplications?: StaffApplicationOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    createdById?: StringNullableFilter<"Subject"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    exams?: ExamListRelationFilter
    staff?: StaffListRelationFilter
    students?: StudentListRelationFilter
    classes?: ClassListRelationFilter
    staffApplications?: StaffApplicationListRelationFilter
  }, "id" | "name" | "code">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Subject"> | string | null
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    studentId?: StringNullableFilter<"Exam"> | string | null
    classId?: StringNullableFilter<"Exam"> | string | null
    subjectId?: StringFilter<"Exam"> | string
    score?: FloatNullableFilter<"Exam"> | number | null
    maxScore?: FloatNullableFilter<"Exam"> | number | null
    date?: DateTimeFilter<"Exam"> | Date | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    studentId?: SortOrderInput | SortOrder
    classId?: SortOrderInput | SortOrder
    subjectId?: SortOrder
    score?: SortOrderInput | SortOrder
    maxScore?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    studentId?: StringNullableFilter<"Exam"> | string | null
    classId?: StringNullableFilter<"Exam"> | string | null
    subjectId?: StringFilter<"Exam"> | string
    score?: FloatNullableFilter<"Exam"> | number | null
    maxScore?: FloatNullableFilter<"Exam"> | number | null
    date?: DateTimeFilter<"Exam"> | Date | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    studentId?: SortOrderInput | SortOrder
    classId?: SortOrderInput | SortOrder
    subjectId?: SortOrder
    score?: SortOrderInput | SortOrder
    maxScore?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    studentId?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    classId?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    subjectId?: StringWithAggregatesFilter<"Exam"> | string
    score?: FloatNullableWithAggregatesFilter<"Exam"> | number | null
    maxScore?: FloatNullableWithAggregatesFilter<"Exam"> | number | null
    date?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: StringFilter<"Application"> | string
    studentId?: StringNullableFilter<"Application"> | string | null
    userId?: StringNullableFilter<"Application"> | string | null
    schoolId?: StringNullableFilter<"Application"> | string | null
    admissionPaymentId?: StringNullableFilter<"Application"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Application"> | Date | string | null
    nationality?: StringNullableFilter<"Application"> | string | null
    sex?: StringNullableFilter<"Application"> | string | null
    languages?: StringNullableListFilter<"Application">
    gradeId?: StringNullableFilter<"Application"> | string | null
    mothersTongue?: StringNullableFilter<"Application"> | string | null
    religion?: StringNullableFilter<"Application"> | string | null
    denomination?: StringNullableFilter<"Application"> | string | null
    hometown?: StringNullableFilter<"Application"> | string | null
    region?: StringNullableFilter<"Application"> | string | null
    profilePicture?: StringNullableFilter<"Application"> | string | null
    wardLivesWith?: StringNullableFilter<"Application"> | string | null
    numberOfSiblings?: IntNullableFilter<"Application"> | number | null
    siblingsOlder?: IntNullableFilter<"Application"> | number | null
    siblingsYounger?: IntNullableFilter<"Application"> | number | null
    postalAddress?: StringNullableFilter<"Application"> | string | null
    residentialAddress?: StringNullableFilter<"Application"> | string | null
    wardMobile?: StringNullableFilter<"Application"> | string | null
    emergencyContact?: StringNullableFilter<"Application"> | string | null
    emergencyMedicalContact?: StringNullableFilter<"Application"> | string | null
    medicalSummary?: StringNullableFilter<"Application"> | string | null
    bloodType?: StringNullableFilter<"Application"> | string | null
    specialDisability?: StringNullableFilter<"Application"> | string | null
    feesAcknowledged?: BoolFilter<"Application"> | boolean
    declarationSigned?: BoolFilter<"Application"> | boolean
    signature?: StringNullableFilter<"Application"> | string | null
    submissionDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    classification?: StringNullableFilter<"Application"> | string | null
    submittedBy?: StringNullableFilter<"Application"> | string | null
    receivedBy?: StringNullableFilter<"Application"> | string | null
    receivedDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    remarks?: StringNullableFilter<"Application"> | string | null
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    progress?: IntFilter<"Application"> | number
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    admissionPayment?: XOR<AdmissionPaymentNullableScalarRelationFilter, AdmissionPaymentWhereInput> | null
    previousSchools?: PreviousSchoolListRelationFilter
    familyMembers?: FamilyMemberListRelationFilter
    grade?: XOR<GradeNullableScalarRelationFilter, GradeWhereInput> | null
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    admissionPaymentId?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    languages?: SortOrder
    gradeId?: SortOrderInput | SortOrder
    mothersTongue?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    denomination?: SortOrderInput | SortOrder
    hometown?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    wardLivesWith?: SortOrderInput | SortOrder
    numberOfSiblings?: SortOrderInput | SortOrder
    siblingsOlder?: SortOrderInput | SortOrder
    siblingsYounger?: SortOrderInput | SortOrder
    postalAddress?: SortOrderInput | SortOrder
    residentialAddress?: SortOrderInput | SortOrder
    wardMobile?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyMedicalContact?: SortOrderInput | SortOrder
    medicalSummary?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    specialDisability?: SortOrderInput | SortOrder
    feesAcknowledged?: SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrderInput | SortOrder
    submissionDate?: SortOrderInput | SortOrder
    classification?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    admissionPayment?: AdmissionPaymentOrderByWithRelationInput
    previousSchools?: PreviousSchoolOrderByRelationAggregateInput
    familyMembers?: FamilyMemberOrderByRelationAggregateInput
    grade?: GradeOrderByWithRelationInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    userId?: string
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    schoolId?: StringNullableFilter<"Application"> | string | null
    admissionPaymentId?: StringNullableFilter<"Application"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Application"> | Date | string | null
    nationality?: StringNullableFilter<"Application"> | string | null
    sex?: StringNullableFilter<"Application"> | string | null
    languages?: StringNullableListFilter<"Application">
    gradeId?: StringNullableFilter<"Application"> | string | null
    mothersTongue?: StringNullableFilter<"Application"> | string | null
    religion?: StringNullableFilter<"Application"> | string | null
    denomination?: StringNullableFilter<"Application"> | string | null
    hometown?: StringNullableFilter<"Application"> | string | null
    region?: StringNullableFilter<"Application"> | string | null
    profilePicture?: StringNullableFilter<"Application"> | string | null
    wardLivesWith?: StringNullableFilter<"Application"> | string | null
    numberOfSiblings?: IntNullableFilter<"Application"> | number | null
    siblingsOlder?: IntNullableFilter<"Application"> | number | null
    siblingsYounger?: IntNullableFilter<"Application"> | number | null
    postalAddress?: StringNullableFilter<"Application"> | string | null
    residentialAddress?: StringNullableFilter<"Application"> | string | null
    wardMobile?: StringNullableFilter<"Application"> | string | null
    emergencyContact?: StringNullableFilter<"Application"> | string | null
    emergencyMedicalContact?: StringNullableFilter<"Application"> | string | null
    medicalSummary?: StringNullableFilter<"Application"> | string | null
    bloodType?: StringNullableFilter<"Application"> | string | null
    specialDisability?: StringNullableFilter<"Application"> | string | null
    feesAcknowledged?: BoolFilter<"Application"> | boolean
    declarationSigned?: BoolFilter<"Application"> | boolean
    signature?: StringNullableFilter<"Application"> | string | null
    submissionDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    classification?: StringNullableFilter<"Application"> | string | null
    submittedBy?: StringNullableFilter<"Application"> | string | null
    receivedBy?: StringNullableFilter<"Application"> | string | null
    receivedDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    remarks?: StringNullableFilter<"Application"> | string | null
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    progress?: IntFilter<"Application"> | number
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    admissionPayment?: XOR<AdmissionPaymentNullableScalarRelationFilter, AdmissionPaymentWhereInput> | null
    previousSchools?: PreviousSchoolListRelationFilter
    familyMembers?: FamilyMemberListRelationFilter
    grade?: XOR<GradeNullableScalarRelationFilter, GradeWhereInput> | null
  }, "id" | "studentId" | "userId">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    admissionPaymentId?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    languages?: SortOrder
    gradeId?: SortOrderInput | SortOrder
    mothersTongue?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    denomination?: SortOrderInput | SortOrder
    hometown?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    wardLivesWith?: SortOrderInput | SortOrder
    numberOfSiblings?: SortOrderInput | SortOrder
    siblingsOlder?: SortOrderInput | SortOrder
    siblingsYounger?: SortOrderInput | SortOrder
    postalAddress?: SortOrderInput | SortOrder
    residentialAddress?: SortOrderInput | SortOrder
    wardMobile?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyMedicalContact?: SortOrderInput | SortOrder
    medicalSummary?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    specialDisability?: SortOrderInput | SortOrder
    feesAcknowledged?: SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrderInput | SortOrder
    submissionDate?: SortOrderInput | SortOrder
    classification?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _avg?: ApplicationAvgOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
    _sum?: ApplicationSumOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Application"> | string
    studentId?: StringNullableWithAggregatesFilter<"Application"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Application"> | string | null
    schoolId?: StringNullableWithAggregatesFilter<"Application"> | string | null
    admissionPaymentId?: StringNullableWithAggregatesFilter<"Application"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    nationality?: StringNullableWithAggregatesFilter<"Application"> | string | null
    sex?: StringNullableWithAggregatesFilter<"Application"> | string | null
    languages?: StringNullableListFilter<"Application">
    gradeId?: StringNullableWithAggregatesFilter<"Application"> | string | null
    mothersTongue?: StringNullableWithAggregatesFilter<"Application"> | string | null
    religion?: StringNullableWithAggregatesFilter<"Application"> | string | null
    denomination?: StringNullableWithAggregatesFilter<"Application"> | string | null
    hometown?: StringNullableWithAggregatesFilter<"Application"> | string | null
    region?: StringNullableWithAggregatesFilter<"Application"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"Application"> | string | null
    wardLivesWith?: StringNullableWithAggregatesFilter<"Application"> | string | null
    numberOfSiblings?: IntNullableWithAggregatesFilter<"Application"> | number | null
    siblingsOlder?: IntNullableWithAggregatesFilter<"Application"> | number | null
    siblingsYounger?: IntNullableWithAggregatesFilter<"Application"> | number | null
    postalAddress?: StringNullableWithAggregatesFilter<"Application"> | string | null
    residentialAddress?: StringNullableWithAggregatesFilter<"Application"> | string | null
    wardMobile?: StringNullableWithAggregatesFilter<"Application"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Application"> | string | null
    emergencyMedicalContact?: StringNullableWithAggregatesFilter<"Application"> | string | null
    medicalSummary?: StringNullableWithAggregatesFilter<"Application"> | string | null
    bloodType?: StringNullableWithAggregatesFilter<"Application"> | string | null
    specialDisability?: StringNullableWithAggregatesFilter<"Application"> | string | null
    feesAcknowledged?: BoolWithAggregatesFilter<"Application"> | boolean
    declarationSigned?: BoolWithAggregatesFilter<"Application"> | boolean
    signature?: StringNullableWithAggregatesFilter<"Application"> | string | null
    submissionDate?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    classification?: StringNullableWithAggregatesFilter<"Application"> | string | null
    submittedBy?: StringNullableWithAggregatesFilter<"Application"> | string | null
    receivedBy?: StringNullableWithAggregatesFilter<"Application"> | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    remarks?: StringNullableWithAggregatesFilter<"Application"> | string | null
    status?: EnumApplicationStatusWithAggregatesFilter<"Application"> | $Enums.ApplicationStatus
    progress?: IntWithAggregatesFilter<"Application"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
  }

  export type PreviousSchoolWhereInput = {
    AND?: PreviousSchoolWhereInput | PreviousSchoolWhereInput[]
    OR?: PreviousSchoolWhereInput[]
    NOT?: PreviousSchoolWhereInput | PreviousSchoolWhereInput[]
    id?: StringFilter<"PreviousSchool"> | string
    applicationId?: StringFilter<"PreviousSchool"> | string
    name?: StringFilter<"PreviousSchool"> | string
    location?: StringFilter<"PreviousSchool"> | string
    startDate?: DateTimeFilter<"PreviousSchool"> | Date | string
    endDate?: DateTimeFilter<"PreviousSchool"> | Date | string
    createdAt?: DateTimeFilter<"PreviousSchool"> | Date | string
    updatedAt?: DateTimeFilter<"PreviousSchool"> | Date | string
    application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
  }

  export type PreviousSchoolOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    application?: ApplicationOrderByWithRelationInput
  }

  export type PreviousSchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PreviousSchoolWhereInput | PreviousSchoolWhereInput[]
    OR?: PreviousSchoolWhereInput[]
    NOT?: PreviousSchoolWhereInput | PreviousSchoolWhereInput[]
    applicationId?: StringFilter<"PreviousSchool"> | string
    name?: StringFilter<"PreviousSchool"> | string
    location?: StringFilter<"PreviousSchool"> | string
    startDate?: DateTimeFilter<"PreviousSchool"> | Date | string
    endDate?: DateTimeFilter<"PreviousSchool"> | Date | string
    createdAt?: DateTimeFilter<"PreviousSchool"> | Date | string
    updatedAt?: DateTimeFilter<"PreviousSchool"> | Date | string
    application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
  }, "id">

  export type PreviousSchoolOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PreviousSchoolCountOrderByAggregateInput
    _max?: PreviousSchoolMaxOrderByAggregateInput
    _min?: PreviousSchoolMinOrderByAggregateInput
  }

  export type PreviousSchoolScalarWhereWithAggregatesInput = {
    AND?: PreviousSchoolScalarWhereWithAggregatesInput | PreviousSchoolScalarWhereWithAggregatesInput[]
    OR?: PreviousSchoolScalarWhereWithAggregatesInput[]
    NOT?: PreviousSchoolScalarWhereWithAggregatesInput | PreviousSchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PreviousSchool"> | string
    applicationId?: StringWithAggregatesFilter<"PreviousSchool"> | string
    name?: StringWithAggregatesFilter<"PreviousSchool"> | string
    location?: StringWithAggregatesFilter<"PreviousSchool"> | string
    startDate?: DateTimeWithAggregatesFilter<"PreviousSchool"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"PreviousSchool"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PreviousSchool"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PreviousSchool"> | Date | string
  }

  export type FamilyMemberWhereInput = {
    AND?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    OR?: FamilyMemberWhereInput[]
    NOT?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    id?: StringFilter<"FamilyMember"> | string
    applicationId?: StringFilter<"FamilyMember"> | string
    relation?: StringFilter<"FamilyMember"> | string
    name?: StringFilter<"FamilyMember"> | string
    postalAddress?: StringFilter<"FamilyMember"> | string
    residentialAddress?: StringFilter<"FamilyMember"> | string
    phone?: StringNullableFilter<"FamilyMember"> | string | null
    email?: StringNullableFilter<"FamilyMember"> | string | null
    occupation?: StringNullableFilter<"FamilyMember"> | string | null
    workplace?: StringNullableFilter<"FamilyMember"> | string | null
    religion?: StringNullableFilter<"FamilyMember"> | string | null
    isAlive?: BoolFilter<"FamilyMember"> | boolean
    createdAt?: DateTimeFilter<"FamilyMember"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMember"> | Date | string
    application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
  }

  export type FamilyMemberOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    relation?: SortOrder
    name?: SortOrder
    postalAddress?: SortOrder
    residentialAddress?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    workplace?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    isAlive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    application?: ApplicationOrderByWithRelationInput
  }

  export type FamilyMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    OR?: FamilyMemberWhereInput[]
    NOT?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    applicationId?: StringFilter<"FamilyMember"> | string
    relation?: StringFilter<"FamilyMember"> | string
    name?: StringFilter<"FamilyMember"> | string
    postalAddress?: StringFilter<"FamilyMember"> | string
    residentialAddress?: StringFilter<"FamilyMember"> | string
    phone?: StringNullableFilter<"FamilyMember"> | string | null
    email?: StringNullableFilter<"FamilyMember"> | string | null
    occupation?: StringNullableFilter<"FamilyMember"> | string | null
    workplace?: StringNullableFilter<"FamilyMember"> | string | null
    religion?: StringNullableFilter<"FamilyMember"> | string | null
    isAlive?: BoolFilter<"FamilyMember"> | boolean
    createdAt?: DateTimeFilter<"FamilyMember"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMember"> | Date | string
    application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
  }, "id">

  export type FamilyMemberOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    relation?: SortOrder
    name?: SortOrder
    postalAddress?: SortOrder
    residentialAddress?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    workplace?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    isAlive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FamilyMemberCountOrderByAggregateInput
    _max?: FamilyMemberMaxOrderByAggregateInput
    _min?: FamilyMemberMinOrderByAggregateInput
  }

  export type FamilyMemberScalarWhereWithAggregatesInput = {
    AND?: FamilyMemberScalarWhereWithAggregatesInput | FamilyMemberScalarWhereWithAggregatesInput[]
    OR?: FamilyMemberScalarWhereWithAggregatesInput[]
    NOT?: FamilyMemberScalarWhereWithAggregatesInput | FamilyMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyMember"> | string
    applicationId?: StringWithAggregatesFilter<"FamilyMember"> | string
    relation?: StringWithAggregatesFilter<"FamilyMember"> | string
    name?: StringWithAggregatesFilter<"FamilyMember"> | string
    postalAddress?: StringWithAggregatesFilter<"FamilyMember"> | string
    residentialAddress?: StringWithAggregatesFilter<"FamilyMember"> | string
    phone?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    email?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    workplace?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    religion?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    isAlive?: BoolWithAggregatesFilter<"FamilyMember"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FamilyMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FamilyMember"> | Date | string
  }

  export type StaffApplicationWhereInput = {
    AND?: StaffApplicationWhereInput | StaffApplicationWhereInput[]
    OR?: StaffApplicationWhereInput[]
    NOT?: StaffApplicationWhereInput | StaffApplicationWhereInput[]
    id?: StringFilter<"StaffApplication"> | string
    staffId?: StringNullableFilter<"StaffApplication"> | string | null
    schoolId?: StringFilter<"StaffApplication"> | string
    surname?: StringFilter<"StaffApplication"> | string
    firstName?: StringFilter<"StaffApplication"> | string
    otherNames?: StringNullableFilter<"StaffApplication"> | string | null
    dateOfBirth?: DateTimeFilter<"StaffApplication"> | Date | string
    nationality?: StringFilter<"StaffApplication"> | string
    sex?: StringFilter<"StaffApplication"> | string
    languages?: StringNullableListFilter<"StaffApplication">
    maritalStatus?: StringNullableFilter<"StaffApplication"> | string | null
    religion?: StringFilter<"StaffApplication"> | string
    denomination?: StringNullableFilter<"StaffApplication"> | string | null
    hometown?: StringFilter<"StaffApplication"> | string
    region?: StringFilter<"StaffApplication"> | string
    profilePicture?: StringNullableFilter<"StaffApplication"> | string | null
    residentialAddress?: StringFilter<"StaffApplication"> | string
    postalAddress?: StringFilter<"StaffApplication"> | string
    mobile?: StringNullableFilter<"StaffApplication"> | string | null
    email?: StringNullableFilter<"StaffApplication"> | string | null
    emergencyContact?: StringFilter<"StaffApplication"> | string
    nextOfKin?: StringNullableFilter<"StaffApplication"> | string | null
    position?: StringFilter<"StaffApplication"> | string
    departmentId?: StringNullableFilter<"StaffApplication"> | string | null
    hireDate?: DateTimeNullableFilter<"StaffApplication"> | Date | string | null
    salary?: FloatNullableFilter<"StaffApplication"> | number | null
    qualifications?: StringNullableFilter<"StaffApplication"> | string | null
    bloodType?: StringNullableFilter<"StaffApplication"> | string | null
    medicalConditions?: StringNullableFilter<"StaffApplication"> | string | null
    specialDisability?: StringNullableFilter<"StaffApplication"> | string | null
    declarationSigned?: BoolFilter<"StaffApplication"> | boolean
    signature?: StringNullableFilter<"StaffApplication"> | string | null
    submissionDate?: DateTimeFilter<"StaffApplication"> | Date | string
    classification?: StringNullableFilter<"StaffApplication"> | string | null
    submittedBy?: StringNullableFilter<"StaffApplication"> | string | null
    receivedBy?: StringNullableFilter<"StaffApplication"> | string | null
    remarks?: StringNullableFilter<"StaffApplication"> | string | null
    createdAt?: DateTimeFilter<"StaffApplication"> | Date | string
    updatedAt?: DateTimeFilter<"StaffApplication"> | Date | string
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    subjects?: SubjectListRelationFilter
    previousJobs?: PreviousJobListRelationFilter
  }

  export type StaffApplicationOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    sex?: SortOrder
    languages?: SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    religion?: SortOrder
    denomination?: SortOrderInput | SortOrder
    hometown?: SortOrder
    region?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    residentialAddress?: SortOrder
    postalAddress?: SortOrder
    mobile?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emergencyContact?: SortOrder
    nextOfKin?: SortOrderInput | SortOrder
    position?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    medicalConditions?: SortOrderInput | SortOrder
    specialDisability?: SortOrderInput | SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrderInput | SortOrder
    submissionDate?: SortOrder
    classification?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    subjects?: SubjectOrderByRelationAggregateInput
    previousJobs?: PreviousJobOrderByRelationAggregateInput
  }

  export type StaffApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    staffId?: string
    AND?: StaffApplicationWhereInput | StaffApplicationWhereInput[]
    OR?: StaffApplicationWhereInput[]
    NOT?: StaffApplicationWhereInput | StaffApplicationWhereInput[]
    schoolId?: StringFilter<"StaffApplication"> | string
    surname?: StringFilter<"StaffApplication"> | string
    firstName?: StringFilter<"StaffApplication"> | string
    otherNames?: StringNullableFilter<"StaffApplication"> | string | null
    dateOfBirth?: DateTimeFilter<"StaffApplication"> | Date | string
    nationality?: StringFilter<"StaffApplication"> | string
    sex?: StringFilter<"StaffApplication"> | string
    languages?: StringNullableListFilter<"StaffApplication">
    maritalStatus?: StringNullableFilter<"StaffApplication"> | string | null
    religion?: StringFilter<"StaffApplication"> | string
    denomination?: StringNullableFilter<"StaffApplication"> | string | null
    hometown?: StringFilter<"StaffApplication"> | string
    region?: StringFilter<"StaffApplication"> | string
    profilePicture?: StringNullableFilter<"StaffApplication"> | string | null
    residentialAddress?: StringFilter<"StaffApplication"> | string
    postalAddress?: StringFilter<"StaffApplication"> | string
    mobile?: StringNullableFilter<"StaffApplication"> | string | null
    email?: StringNullableFilter<"StaffApplication"> | string | null
    emergencyContact?: StringFilter<"StaffApplication"> | string
    nextOfKin?: StringNullableFilter<"StaffApplication"> | string | null
    position?: StringFilter<"StaffApplication"> | string
    departmentId?: StringNullableFilter<"StaffApplication"> | string | null
    hireDate?: DateTimeNullableFilter<"StaffApplication"> | Date | string | null
    salary?: FloatNullableFilter<"StaffApplication"> | number | null
    qualifications?: StringNullableFilter<"StaffApplication"> | string | null
    bloodType?: StringNullableFilter<"StaffApplication"> | string | null
    medicalConditions?: StringNullableFilter<"StaffApplication"> | string | null
    specialDisability?: StringNullableFilter<"StaffApplication"> | string | null
    declarationSigned?: BoolFilter<"StaffApplication"> | boolean
    signature?: StringNullableFilter<"StaffApplication"> | string | null
    submissionDate?: DateTimeFilter<"StaffApplication"> | Date | string
    classification?: StringNullableFilter<"StaffApplication"> | string | null
    submittedBy?: StringNullableFilter<"StaffApplication"> | string | null
    receivedBy?: StringNullableFilter<"StaffApplication"> | string | null
    remarks?: StringNullableFilter<"StaffApplication"> | string | null
    createdAt?: DateTimeFilter<"StaffApplication"> | Date | string
    updatedAt?: DateTimeFilter<"StaffApplication"> | Date | string
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    subjects?: SubjectListRelationFilter
    previousJobs?: PreviousJobListRelationFilter
  }, "id" | "staffId">

  export type StaffApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    sex?: SortOrder
    languages?: SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    religion?: SortOrder
    denomination?: SortOrderInput | SortOrder
    hometown?: SortOrder
    region?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    residentialAddress?: SortOrder
    postalAddress?: SortOrder
    mobile?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emergencyContact?: SortOrder
    nextOfKin?: SortOrderInput | SortOrder
    position?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    medicalConditions?: SortOrderInput | SortOrder
    specialDisability?: SortOrderInput | SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrderInput | SortOrder
    submissionDate?: SortOrder
    classification?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffApplicationCountOrderByAggregateInput
    _avg?: StaffApplicationAvgOrderByAggregateInput
    _max?: StaffApplicationMaxOrderByAggregateInput
    _min?: StaffApplicationMinOrderByAggregateInput
    _sum?: StaffApplicationSumOrderByAggregateInput
  }

  export type StaffApplicationScalarWhereWithAggregatesInput = {
    AND?: StaffApplicationScalarWhereWithAggregatesInput | StaffApplicationScalarWhereWithAggregatesInput[]
    OR?: StaffApplicationScalarWhereWithAggregatesInput[]
    NOT?: StaffApplicationScalarWhereWithAggregatesInput | StaffApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffApplication"> | string
    staffId?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    schoolId?: StringWithAggregatesFilter<"StaffApplication"> | string
    surname?: StringWithAggregatesFilter<"StaffApplication"> | string
    firstName?: StringWithAggregatesFilter<"StaffApplication"> | string
    otherNames?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    dateOfBirth?: DateTimeWithAggregatesFilter<"StaffApplication"> | Date | string
    nationality?: StringWithAggregatesFilter<"StaffApplication"> | string
    sex?: StringWithAggregatesFilter<"StaffApplication"> | string
    languages?: StringNullableListFilter<"StaffApplication">
    maritalStatus?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    religion?: StringWithAggregatesFilter<"StaffApplication"> | string
    denomination?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    hometown?: StringWithAggregatesFilter<"StaffApplication"> | string
    region?: StringWithAggregatesFilter<"StaffApplication"> | string
    profilePicture?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    residentialAddress?: StringWithAggregatesFilter<"StaffApplication"> | string
    postalAddress?: StringWithAggregatesFilter<"StaffApplication"> | string
    mobile?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    email?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    emergencyContact?: StringWithAggregatesFilter<"StaffApplication"> | string
    nextOfKin?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    position?: StringWithAggregatesFilter<"StaffApplication"> | string
    departmentId?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    hireDate?: DateTimeNullableWithAggregatesFilter<"StaffApplication"> | Date | string | null
    salary?: FloatNullableWithAggregatesFilter<"StaffApplication"> | number | null
    qualifications?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    bloodType?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    medicalConditions?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    specialDisability?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    declarationSigned?: BoolWithAggregatesFilter<"StaffApplication"> | boolean
    signature?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    submissionDate?: DateTimeWithAggregatesFilter<"StaffApplication"> | Date | string
    classification?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    submittedBy?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    receivedBy?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"StaffApplication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StaffApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StaffApplication"> | Date | string
  }

  export type PreviousJobWhereInput = {
    AND?: PreviousJobWhereInput | PreviousJobWhereInput[]
    OR?: PreviousJobWhereInput[]
    NOT?: PreviousJobWhereInput | PreviousJobWhereInput[]
    id?: StringFilter<"PreviousJob"> | string
    staffApplicationId?: StringFilter<"PreviousJob"> | string
    company?: StringFilter<"PreviousJob"> | string
    role?: StringFilter<"PreviousJob"> | string
    startDate?: DateTimeFilter<"PreviousJob"> | Date | string
    endDate?: DateTimeNullableFilter<"PreviousJob"> | Date | string | null
    createdAt?: DateTimeFilter<"PreviousJob"> | Date | string
    updatedAt?: DateTimeFilter<"PreviousJob"> | Date | string
    staffApplication?: XOR<StaffApplicationScalarRelationFilter, StaffApplicationWhereInput>
  }

  export type PreviousJobOrderByWithRelationInput = {
    id?: SortOrder
    staffApplicationId?: SortOrder
    company?: SortOrder
    role?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staffApplication?: StaffApplicationOrderByWithRelationInput
  }

  export type PreviousJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PreviousJobWhereInput | PreviousJobWhereInput[]
    OR?: PreviousJobWhereInput[]
    NOT?: PreviousJobWhereInput | PreviousJobWhereInput[]
    staffApplicationId?: StringFilter<"PreviousJob"> | string
    company?: StringFilter<"PreviousJob"> | string
    role?: StringFilter<"PreviousJob"> | string
    startDate?: DateTimeFilter<"PreviousJob"> | Date | string
    endDate?: DateTimeNullableFilter<"PreviousJob"> | Date | string | null
    createdAt?: DateTimeFilter<"PreviousJob"> | Date | string
    updatedAt?: DateTimeFilter<"PreviousJob"> | Date | string
    staffApplication?: XOR<StaffApplicationScalarRelationFilter, StaffApplicationWhereInput>
  }, "id">

  export type PreviousJobOrderByWithAggregationInput = {
    id?: SortOrder
    staffApplicationId?: SortOrder
    company?: SortOrder
    role?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PreviousJobCountOrderByAggregateInput
    _max?: PreviousJobMaxOrderByAggregateInput
    _min?: PreviousJobMinOrderByAggregateInput
  }

  export type PreviousJobScalarWhereWithAggregatesInput = {
    AND?: PreviousJobScalarWhereWithAggregatesInput | PreviousJobScalarWhereWithAggregatesInput[]
    OR?: PreviousJobScalarWhereWithAggregatesInput[]
    NOT?: PreviousJobScalarWhereWithAggregatesInput | PreviousJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PreviousJob"> | string
    staffApplicationId?: StringWithAggregatesFilter<"PreviousJob"> | string
    company?: StringWithAggregatesFilter<"PreviousJob"> | string
    role?: StringWithAggregatesFilter<"PreviousJob"> | string
    startDate?: DateTimeWithAggregatesFilter<"PreviousJob"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"PreviousJob"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PreviousJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PreviousJob"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: StringFilter<"Staff"> | string
    userId?: StringFilter<"Staff"> | string
    classId?: StringNullableFilter<"Staff"> | string | null
    position?: StringNullableFilter<"Staff"> | string | null
    salary?: FloatNullableFilter<"Staff"> | number | null
    hireDate?: DateTimeNullableFilter<"Staff"> | Date | string | null
    departmentId?: StringNullableFilter<"Staff"> | string | null
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    grades?: GradeListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    subjects?: SubjectListRelationFilter
    attendances?: StaffAttendanceListRelationFilter
    StaffApplication?: XOR<StaffApplicationNullableScalarRelationFilter, StaffApplicationWhereInput> | null
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    grades?: GradeOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    subjects?: SubjectOrderByRelationAggregateInput
    attendances?: StaffAttendanceOrderByRelationAggregateInput
    StaffApplication?: StaffApplicationOrderByWithRelationInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    classId?: StringNullableFilter<"Staff"> | string | null
    position?: StringNullableFilter<"Staff"> | string | null
    salary?: FloatNullableFilter<"Staff"> | number | null
    hireDate?: DateTimeNullableFilter<"Staff"> | Date | string | null
    departmentId?: StringNullableFilter<"Staff"> | string | null
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    grades?: GradeListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    subjects?: SubjectListRelationFilter
    attendances?: StaffAttendanceListRelationFilter
    StaffApplication?: XOR<StaffApplicationNullableScalarRelationFilter, StaffApplicationWhereInput> | null
  }, "id" | "userId">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _avg?: StaffAvgOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
    _sum?: StaffSumOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff"> | string
    userId?: StringWithAggregatesFilter<"Staff"> | string
    classId?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    position?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    salary?: FloatNullableWithAggregatesFilter<"Staff"> | number | null
    hireDate?: DateTimeNullableWithAggregatesFilter<"Staff"> | Date | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    staff?: StaffListRelationFilter
    LibraryStaff?: LibraryStaffListRelationFilter
    StaffApplication?: StaffApplicationListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    staff?: StaffOrderByRelationAggregateInput
    LibraryStaff?: LibraryStaffOrderByRelationAggregateInput
    StaffApplication?: StaffApplicationOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    staff?: StaffListRelationFilter
    LibraryStaff?: LibraryStaffListRelationFilter
    StaffApplication?: StaffApplicationListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
  }

  export type StudentAttendanceWhereInput = {
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    id?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    classId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    timeIn?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    remarks?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrderInput | SortOrder
    timeOut?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_date?: StudentAttendanceStudentId_dateCompoundUniqueInput
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    studentId?: StringFilter<"StudentAttendance"> | string
    classId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    timeIn?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    remarks?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId_date">

  export type StudentAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrderInput | SortOrder
    timeOut?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentAttendanceCountOrderByAggregateInput
    _max?: StudentAttendanceMaxOrderByAggregateInput
    _min?: StudentAttendanceMinOrderByAggregateInput
  }

  export type StudentAttendanceScalarWhereWithAggregatesInput = {
    AND?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    OR?: StudentAttendanceScalarWhereWithAggregatesInput[]
    NOT?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAttendance"> | string
    studentId?: StringWithAggregatesFilter<"StudentAttendance"> | string
    classId?: StringWithAggregatesFilter<"StudentAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    timeIn?: DateTimeNullableWithAggregatesFilter<"StudentAttendance"> | Date | string | null
    timeOut?: DateTimeNullableWithAggregatesFilter<"StudentAttendance"> | Date | string | null
    remarks?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
  }

  export type StaffAttendanceWhereInput = {
    AND?: StaffAttendanceWhereInput | StaffAttendanceWhereInput[]
    OR?: StaffAttendanceWhereInput[]
    NOT?: StaffAttendanceWhereInput | StaffAttendanceWhereInput[]
    id?: StringFilter<"StaffAttendance"> | string
    staffId?: StringFilter<"StaffAttendance"> | string
    date?: DateTimeFilter<"StaffAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StaffAttendance"> | $Enums.AttendanceStatus
    timeIn?: DateTimeNullableFilter<"StaffAttendance"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"StaffAttendance"> | Date | string | null
    remarks?: StringNullableFilter<"StaffAttendance"> | string | null
    createdAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }

  export type StaffAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrderInput | SortOrder
    timeOut?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
  }

  export type StaffAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StaffAttendanceWhereInput | StaffAttendanceWhereInput[]
    OR?: StaffAttendanceWhereInput[]
    NOT?: StaffAttendanceWhereInput | StaffAttendanceWhereInput[]
    staffId?: StringFilter<"StaffAttendance"> | string
    date?: DateTimeFilter<"StaffAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StaffAttendance"> | $Enums.AttendanceStatus
    timeIn?: DateTimeNullableFilter<"StaffAttendance"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"StaffAttendance"> | Date | string | null
    remarks?: StringNullableFilter<"StaffAttendance"> | string | null
    createdAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }, "id">

  export type StaffAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrderInput | SortOrder
    timeOut?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffAttendanceCountOrderByAggregateInput
    _max?: StaffAttendanceMaxOrderByAggregateInput
    _min?: StaffAttendanceMinOrderByAggregateInput
  }

  export type StaffAttendanceScalarWhereWithAggregatesInput = {
    AND?: StaffAttendanceScalarWhereWithAggregatesInput | StaffAttendanceScalarWhereWithAggregatesInput[]
    OR?: StaffAttendanceScalarWhereWithAggregatesInput[]
    NOT?: StaffAttendanceScalarWhereWithAggregatesInput | StaffAttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffAttendance"> | string
    staffId?: StringWithAggregatesFilter<"StaffAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"StaffAttendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"StaffAttendance"> | $Enums.AttendanceStatus
    timeIn?: DateTimeNullableWithAggregatesFilter<"StaffAttendance"> | Date | string | null
    timeOut?: DateTimeNullableWithAggregatesFilter<"StaffAttendance"> | Date | string | null
    remarks?: StringNullableWithAggregatesFilter<"StaffAttendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StaffAttendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StaffAttendance"> | Date | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    studentId?: StringFilter<"Parent"> | string
    name?: StringFilter<"Parent"> | string
    email?: StringFilter<"Parent"> | string
    phone?: StringNullableFilter<"Parent"> | string | null
    profilePicture?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    studentId?: StringFilter<"Parent"> | string
    name?: StringFilter<"Parent"> | string
    phone?: StringNullableFilter<"Parent"> | string | null
    profilePicture?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "email">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    studentId?: StringWithAggregatesFilter<"Parent"> | string
    name?: StringWithAggregatesFilter<"Parent"> | string
    email?: StringWithAggregatesFilter<"Parent"> | string
    phone?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type AuthorWhereInput = {
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    id?: StringFilter<"Author"> | string
    name?: StringFilter<"Author"> | string
    bio?: StringNullableFilter<"Author"> | string | null
    createdAt?: DateTimeFilter<"Author"> | Date | string
    updatedAt?: DateTimeFilter<"Author"> | Date | string
    books?: BookListRelationFilter
  }

  export type AuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    books?: BookOrderByRelationAggregateInput
  }

  export type AuthorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    name?: StringFilter<"Author"> | string
    bio?: StringNullableFilter<"Author"> | string | null
    createdAt?: DateTimeFilter<"Author"> | Date | string
    updatedAt?: DateTimeFilter<"Author"> | Date | string
    books?: BookListRelationFilter
  }, "id">

  export type AuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthorCountOrderByAggregateInput
    _max?: AuthorMaxOrderByAggregateInput
    _min?: AuthorMinOrderByAggregateInput
  }

  export type AuthorScalarWhereWithAggregatesInput = {
    AND?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    OR?: AuthorScalarWhereWithAggregatesInput[]
    NOT?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Author"> | string
    name?: StringWithAggregatesFilter<"Author"> | string
    bio?: StringNullableWithAggregatesFilter<"Author"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Author"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Author"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    books?: BookListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    books?: BookOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    books?: BookListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type BookWhereInput = {
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    id?: StringFilter<"Book"> | string
    title?: StringFilter<"Book"> | string
    isbn?: StringFilter<"Book"> | string
    authorId?: StringFilter<"Book"> | string
    categoryId?: StringNullableFilter<"Book"> | string | null
    totalCopies?: IntFilter<"Book"> | number
    available?: IntFilter<"Book"> | number
    schoolId?: StringFilter<"Book"> | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
    author?: XOR<AuthorScalarRelationFilter, AuthorWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    borrows?: BorrowListRelationFilter
  }

  export type BookOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    totalCopies?: SortOrder
    available?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: AuthorOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    borrows?: BorrowOrderByRelationAggregateInput
  }

  export type BookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    isbn?: string
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    title?: StringFilter<"Book"> | string
    authorId?: StringFilter<"Book"> | string
    categoryId?: StringNullableFilter<"Book"> | string | null
    totalCopies?: IntFilter<"Book"> | number
    available?: IntFilter<"Book"> | number
    schoolId?: StringFilter<"Book"> | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
    author?: XOR<AuthorScalarRelationFilter, AuthorWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    borrows?: BorrowListRelationFilter
  }, "id" | "isbn">

  export type BookOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    totalCopies?: SortOrder
    available?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookCountOrderByAggregateInput
    _avg?: BookAvgOrderByAggregateInput
    _max?: BookMaxOrderByAggregateInput
    _min?: BookMinOrderByAggregateInput
    _sum?: BookSumOrderByAggregateInput
  }

  export type BookScalarWhereWithAggregatesInput = {
    AND?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    OR?: BookScalarWhereWithAggregatesInput[]
    NOT?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Book"> | string
    title?: StringWithAggregatesFilter<"Book"> | string
    isbn?: StringWithAggregatesFilter<"Book"> | string
    authorId?: StringWithAggregatesFilter<"Book"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Book"> | string | null
    totalCopies?: IntWithAggregatesFilter<"Book"> | number
    available?: IntWithAggregatesFilter<"Book"> | number
    schoolId?: StringWithAggregatesFilter<"Book"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
  }

  export type BorrowWhereInput = {
    AND?: BorrowWhereInput | BorrowWhereInput[]
    OR?: BorrowWhereInput[]
    NOT?: BorrowWhereInput | BorrowWhereInput[]
    id?: StringFilter<"Borrow"> | string
    bookId?: StringFilter<"Borrow"> | string
    studentId?: StringFilter<"Borrow"> | string
    borrowedAt?: DateTimeFilter<"Borrow"> | Date | string
    dueAt?: DateTimeFilter<"Borrow"> | Date | string
    returnedAt?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    fine?: FloatFilter<"Borrow"> | number
    createdAt?: DateTimeFilter<"Borrow"> | Date | string
    updatedAt?: DateTimeFilter<"Borrow"> | Date | string
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type BorrowOrderByWithRelationInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    borrowedAt?: SortOrder
    dueAt?: SortOrder
    returnedAt?: SortOrderInput | SortOrder
    fine?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    book?: BookOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type BorrowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_borrow?: BorrowUnique_borrowCompoundUniqueInput
    AND?: BorrowWhereInput | BorrowWhereInput[]
    OR?: BorrowWhereInput[]
    NOT?: BorrowWhereInput | BorrowWhereInput[]
    bookId?: StringFilter<"Borrow"> | string
    studentId?: StringFilter<"Borrow"> | string
    borrowedAt?: DateTimeFilter<"Borrow"> | Date | string
    dueAt?: DateTimeFilter<"Borrow"> | Date | string
    returnedAt?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    fine?: FloatFilter<"Borrow"> | number
    createdAt?: DateTimeFilter<"Borrow"> | Date | string
    updatedAt?: DateTimeFilter<"Borrow"> | Date | string
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "unique_borrow">

  export type BorrowOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    borrowedAt?: SortOrder
    dueAt?: SortOrder
    returnedAt?: SortOrderInput | SortOrder
    fine?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BorrowCountOrderByAggregateInput
    _avg?: BorrowAvgOrderByAggregateInput
    _max?: BorrowMaxOrderByAggregateInput
    _min?: BorrowMinOrderByAggregateInput
    _sum?: BorrowSumOrderByAggregateInput
  }

  export type BorrowScalarWhereWithAggregatesInput = {
    AND?: BorrowScalarWhereWithAggregatesInput | BorrowScalarWhereWithAggregatesInput[]
    OR?: BorrowScalarWhereWithAggregatesInput[]
    NOT?: BorrowScalarWhereWithAggregatesInput | BorrowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Borrow"> | string
    bookId?: StringWithAggregatesFilter<"Borrow"> | string
    studentId?: StringWithAggregatesFilter<"Borrow"> | string
    borrowedAt?: DateTimeWithAggregatesFilter<"Borrow"> | Date | string
    dueAt?: DateTimeWithAggregatesFilter<"Borrow"> | Date | string
    returnedAt?: DateTimeNullableWithAggregatesFilter<"Borrow"> | Date | string | null
    fine?: FloatWithAggregatesFilter<"Borrow"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Borrow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Borrow"> | Date | string
  }

  export type LibraryStaffWhereInput = {
    AND?: LibraryStaffWhereInput | LibraryStaffWhereInput[]
    OR?: LibraryStaffWhereInput[]
    NOT?: LibraryStaffWhereInput | LibraryStaffWhereInput[]
    id?: StringFilter<"LibraryStaff"> | string
    userId?: StringFilter<"LibraryStaff"> | string
    departmentId?: StringFilter<"LibraryStaff"> | string
    position?: StringNullableFilter<"LibraryStaff"> | string | null
    hireDate?: DateTimeNullableFilter<"LibraryStaff"> | Date | string | null
    createdAt?: DateTimeFilter<"LibraryStaff"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }

  export type LibraryStaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
    position?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
  }

  export type LibraryStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LibraryStaffWhereInput | LibraryStaffWhereInput[]
    OR?: LibraryStaffWhereInput[]
    NOT?: LibraryStaffWhereInput | LibraryStaffWhereInput[]
    departmentId?: StringFilter<"LibraryStaff"> | string
    position?: StringNullableFilter<"LibraryStaff"> | string | null
    hireDate?: DateTimeNullableFilter<"LibraryStaff"> | Date | string | null
    createdAt?: DateTimeFilter<"LibraryStaff"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }, "id" | "userId">

  export type LibraryStaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
    position?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryStaffCountOrderByAggregateInput
    _max?: LibraryStaffMaxOrderByAggregateInput
    _min?: LibraryStaffMinOrderByAggregateInput
  }

  export type LibraryStaffScalarWhereWithAggregatesInput = {
    AND?: LibraryStaffScalarWhereWithAggregatesInput | LibraryStaffScalarWhereWithAggregatesInput[]
    OR?: LibraryStaffScalarWhereWithAggregatesInput[]
    NOT?: LibraryStaffScalarWhereWithAggregatesInput | LibraryStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LibraryStaff"> | string
    userId?: StringWithAggregatesFilter<"LibraryStaff"> | string
    departmentId?: StringWithAggregatesFilter<"LibraryStaff"> | string
    position?: StringNullableWithAggregatesFilter<"LibraryStaff"> | string | null
    hireDate?: DateTimeNullableWithAggregatesFilter<"LibraryStaff"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LibraryStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LibraryStaff"> | Date | string
  }

  export type AdmissionPaymentWhereInput = {
    AND?: AdmissionPaymentWhereInput | AdmissionPaymentWhereInput[]
    OR?: AdmissionPaymentWhereInput[]
    NOT?: AdmissionPaymentWhereInput | AdmissionPaymentWhereInput[]
    id?: StringFilter<"AdmissionPayment"> | string
    studentId?: StringFilter<"AdmissionPayment"> | string
    schoolId?: StringFilter<"AdmissionPayment"> | string
    amount?: FloatFilter<"AdmissionPayment"> | number
    pinCode?: StringFilter<"AdmissionPayment"> | string
    used?: BoolFilter<"AdmissionPayment"> | boolean
    createdAt?: DateTimeFilter<"AdmissionPayment"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionPayment"> | Date | string
    Application?: ApplicationListRelationFilter
  }

  export type AdmissionPaymentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    pinCode?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Application?: ApplicationOrderByRelationAggregateInput
  }

  export type AdmissionPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pinCode?: string
    AND?: AdmissionPaymentWhereInput | AdmissionPaymentWhereInput[]
    OR?: AdmissionPaymentWhereInput[]
    NOT?: AdmissionPaymentWhereInput | AdmissionPaymentWhereInput[]
    studentId?: StringFilter<"AdmissionPayment"> | string
    schoolId?: StringFilter<"AdmissionPayment"> | string
    amount?: FloatFilter<"AdmissionPayment"> | number
    used?: BoolFilter<"AdmissionPayment"> | boolean
    createdAt?: DateTimeFilter<"AdmissionPayment"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionPayment"> | Date | string
    Application?: ApplicationListRelationFilter
  }, "id" | "pinCode">

  export type AdmissionPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    pinCode?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmissionPaymentCountOrderByAggregateInput
    _avg?: AdmissionPaymentAvgOrderByAggregateInput
    _max?: AdmissionPaymentMaxOrderByAggregateInput
    _min?: AdmissionPaymentMinOrderByAggregateInput
    _sum?: AdmissionPaymentSumOrderByAggregateInput
  }

  export type AdmissionPaymentScalarWhereWithAggregatesInput = {
    AND?: AdmissionPaymentScalarWhereWithAggregatesInput | AdmissionPaymentScalarWhereWithAggregatesInput[]
    OR?: AdmissionPaymentScalarWhereWithAggregatesInput[]
    NOT?: AdmissionPaymentScalarWhereWithAggregatesInput | AdmissionPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmissionPayment"> | string
    studentId?: StringWithAggregatesFilter<"AdmissionPayment"> | string
    schoolId?: StringWithAggregatesFilter<"AdmissionPayment"> | string
    amount?: FloatWithAggregatesFilter<"AdmissionPayment"> | number
    pinCode?: StringWithAggregatesFilter<"AdmissionPayment"> | string
    used?: BoolWithAggregatesFilter<"AdmissionPayment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdmissionPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdmissionPayment"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    studentId?: StringFilter<"Transaction"> | string
    type?: EnumFinanceTypeFilter<"Transaction"> | $Enums.FinanceType
    feeType?: EnumFeeTypeNullableFilter<"Transaction"> | $Enums.FeeType | null
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    feeType?: SortOrderInput | SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    studentId?: StringFilter<"Transaction"> | string
    type?: EnumFinanceTypeFilter<"Transaction"> | $Enums.FinanceType
    feeType?: EnumFeeTypeNullableFilter<"Transaction"> | $Enums.FeeType | null
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    feeType?: SortOrderInput | SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    studentId?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumFinanceTypeWithAggregatesFilter<"Transaction"> | $Enums.FinanceType
    feeType?: EnumFeeTypeNullableWithAggregatesFilter<"Transaction"> | $Enums.FeeType | null
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type FinanceWhereInput = {
    AND?: FinanceWhereInput | FinanceWhereInput[]
    OR?: FinanceWhereInput[]
    NOT?: FinanceWhereInput | FinanceWhereInput[]
    id?: StringFilter<"Finance"> | string
    schoolId?: StringFilter<"Finance"> | string
    type?: EnumFinanceTypeFilter<"Finance"> | $Enums.FinanceType
    amount?: FloatFilter<"Finance"> | number
    description?: StringNullableFilter<"Finance"> | string | null
    date?: DateTimeFilter<"Finance"> | Date | string
    createdAt?: DateTimeFilter<"Finance"> | Date | string
    updatedAt?: DateTimeFilter<"Finance"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type FinanceOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type FinanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinanceWhereInput | FinanceWhereInput[]
    OR?: FinanceWhereInput[]
    NOT?: FinanceWhereInput | FinanceWhereInput[]
    schoolId?: StringFilter<"Finance"> | string
    type?: EnumFinanceTypeFilter<"Finance"> | $Enums.FinanceType
    amount?: FloatFilter<"Finance"> | number
    description?: StringNullableFilter<"Finance"> | string | null
    date?: DateTimeFilter<"Finance"> | Date | string
    createdAt?: DateTimeFilter<"Finance"> | Date | string
    updatedAt?: DateTimeFilter<"Finance"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id">

  export type FinanceOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinanceCountOrderByAggregateInput
    _avg?: FinanceAvgOrderByAggregateInput
    _max?: FinanceMaxOrderByAggregateInput
    _min?: FinanceMinOrderByAggregateInput
    _sum?: FinanceSumOrderByAggregateInput
  }

  export type FinanceScalarWhereWithAggregatesInput = {
    AND?: FinanceScalarWhereWithAggregatesInput | FinanceScalarWhereWithAggregatesInput[]
    OR?: FinanceScalarWhereWithAggregatesInput[]
    NOT?: FinanceScalarWhereWithAggregatesInput | FinanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Finance"> | string
    schoolId?: StringWithAggregatesFilter<"Finance"> | string
    type?: EnumFinanceTypeWithAggregatesFilter<"Finance"> | $Enums.FinanceType
    amount?: FloatWithAggregatesFilter<"Finance"> | number
    description?: StringNullableWithAggregatesFilter<"Finance"> | string | null
    date?: DateTimeWithAggregatesFilter<"Finance"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Finance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Finance"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: StringFilter<"Resource"> | string
    name?: StringFilter<"Resource"> | string
    category?: StringNullableFilter<"Resource"> | string | null
    unitPrice?: FloatFilter<"Resource"> | number
    quantity?: IntFilter<"Resource"> | number
    schoolId?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    purchases?: PurchaseListRelationFilter
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    purchases?: PurchaseOrderByRelationAggregateInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_schoolId?: ResourceNameSchoolIdCompoundUniqueInput
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    name?: StringFilter<"Resource"> | string
    category?: StringNullableFilter<"Resource"> | string | null
    unitPrice?: FloatFilter<"Resource"> | number
    quantity?: IntFilter<"Resource"> | number
    schoolId?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    purchases?: PurchaseListRelationFilter
  }, "id" | "name_schoolId">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resource"> | string
    name?: StringWithAggregatesFilter<"Resource"> | string
    category?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    unitPrice?: FloatWithAggregatesFilter<"Resource"> | number
    quantity?: IntWithAggregatesFilter<"Resource"> | number
    schoolId?: StringWithAggregatesFilter<"Resource"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    studentId?: StringFilter<"Purchase"> | string
    resourceId?: StringFilter<"Purchase"> | string
    quantity?: IntFilter<"Purchase"> | number
    totalCost?: FloatFilter<"Purchase"> | number
    date?: DateTimeFilter<"Purchase"> | Date | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    studentId?: StringFilter<"Purchase"> | string
    resourceId?: StringFilter<"Purchase"> | string
    quantity?: IntFilter<"Purchase"> | number
    totalCost?: FloatFilter<"Purchase"> | number
    date?: DateTimeFilter<"Purchase"> | Date | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    studentId?: StringWithAggregatesFilter<"Purchase"> | string
    resourceId?: StringWithAggregatesFilter<"Purchase"> | string
    quantity?: IntWithAggregatesFilter<"Purchase"> | number
    totalCost?: FloatWithAggregatesFilter<"Purchase"> | number
    date?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    schoolId?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    schoolId?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    title?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    schoolId?: StringWithAggregatesFilter<"Activity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type BusWhereInput = {
    AND?: BusWhereInput | BusWhereInput[]
    OR?: BusWhereInput[]
    NOT?: BusWhereInput | BusWhereInput[]
    id?: StringFilter<"Bus"> | string
    schoolId?: StringFilter<"Bus"> | string
    plateNumber?: StringFilter<"Bus"> | string
    driverName?: StringFilter<"Bus"> | string
    capacity?: IntFilter<"Bus"> | number
    createdAt?: DateTimeFilter<"Bus"> | Date | string
    updatedAt?: DateTimeFilter<"Bus"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type BusOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    plateNumber?: SortOrder
    driverName?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type BusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    plateNumber?: string
    AND?: BusWhereInput | BusWhereInput[]
    OR?: BusWhereInput[]
    NOT?: BusWhereInput | BusWhereInput[]
    schoolId?: StringFilter<"Bus"> | string
    driverName?: StringFilter<"Bus"> | string
    capacity?: IntFilter<"Bus"> | number
    createdAt?: DateTimeFilter<"Bus"> | Date | string
    updatedAt?: DateTimeFilter<"Bus"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id" | "plateNumber">

  export type BusOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    plateNumber?: SortOrder
    driverName?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusCountOrderByAggregateInput
    _avg?: BusAvgOrderByAggregateInput
    _max?: BusMaxOrderByAggregateInput
    _min?: BusMinOrderByAggregateInput
    _sum?: BusSumOrderByAggregateInput
  }

  export type BusScalarWhereWithAggregatesInput = {
    AND?: BusScalarWhereWithAggregatesInput | BusScalarWhereWithAggregatesInput[]
    OR?: BusScalarWhereWithAggregatesInput[]
    NOT?: BusScalarWhereWithAggregatesInput | BusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bus"> | string
    schoolId?: StringWithAggregatesFilter<"Bus"> | string
    plateNumber?: StringWithAggregatesFilter<"Bus"> | string
    driverName?: StringWithAggregatesFilter<"Bus"> | string
    capacity?: IntWithAggregatesFilter<"Bus"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Bus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bus"> | Date | string
  }

  export type SkuunAiSessionWhereInput = {
    AND?: SkuunAiSessionWhereInput | SkuunAiSessionWhereInput[]
    OR?: SkuunAiSessionWhereInput[]
    NOT?: SkuunAiSessionWhereInput | SkuunAiSessionWhereInput[]
    id?: StringFilter<"SkuunAiSession"> | string
    userId?: StringFilter<"SkuunAiSession"> | string
    role?: EnumRoleFilter<"SkuunAiSession"> | $Enums.Role
    createdAt?: DateTimeFilter<"SkuunAiSession"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: SkuunAiMessageListRelationFilter
    actions?: SkuunAiActionListRelationFilter
    SkuunAiRecommendation?: SkuunAiRecommendationListRelationFilter
  }

  export type SkuunAiSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: SkuunAiMessageOrderByRelationAggregateInput
    actions?: SkuunAiActionOrderByRelationAggregateInput
    SkuunAiRecommendation?: SkuunAiRecommendationOrderByRelationAggregateInput
  }

  export type SkuunAiSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkuunAiSessionWhereInput | SkuunAiSessionWhereInput[]
    OR?: SkuunAiSessionWhereInput[]
    NOT?: SkuunAiSessionWhereInput | SkuunAiSessionWhereInput[]
    userId?: StringFilter<"SkuunAiSession"> | string
    role?: EnumRoleFilter<"SkuunAiSession"> | $Enums.Role
    createdAt?: DateTimeFilter<"SkuunAiSession"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: SkuunAiMessageListRelationFilter
    actions?: SkuunAiActionListRelationFilter
    SkuunAiRecommendation?: SkuunAiRecommendationListRelationFilter
  }, "id">

  export type SkuunAiSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkuunAiSessionCountOrderByAggregateInput
    _max?: SkuunAiSessionMaxOrderByAggregateInput
    _min?: SkuunAiSessionMinOrderByAggregateInput
  }

  export type SkuunAiSessionScalarWhereWithAggregatesInput = {
    AND?: SkuunAiSessionScalarWhereWithAggregatesInput | SkuunAiSessionScalarWhereWithAggregatesInput[]
    OR?: SkuunAiSessionScalarWhereWithAggregatesInput[]
    NOT?: SkuunAiSessionScalarWhereWithAggregatesInput | SkuunAiSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkuunAiSession"> | string
    userId?: StringWithAggregatesFilter<"SkuunAiSession"> | string
    role?: EnumRoleWithAggregatesFilter<"SkuunAiSession"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"SkuunAiSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SkuunAiSession"> | Date | string
  }

  export type SkuunAiMessageWhereInput = {
    AND?: SkuunAiMessageWhereInput | SkuunAiMessageWhereInput[]
    OR?: SkuunAiMessageWhereInput[]
    NOT?: SkuunAiMessageWhereInput | SkuunAiMessageWhereInput[]
    id?: StringFilter<"SkuunAiMessage"> | string
    sessionId?: StringFilter<"SkuunAiMessage"> | string
    sender?: EnumSenderTypeFilter<"SkuunAiMessage"> | $Enums.SenderType
    type?: EnumMessageTypeFilter<"SkuunAiMessage"> | $Enums.MessageType
    content?: StringFilter<"SkuunAiMessage"> | string
    payload?: JsonNullableFilter<"SkuunAiMessage">
    createdAt?: DateTimeFilter<"SkuunAiMessage"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiMessage"> | Date | string
    session?: XOR<SkuunAiSessionScalarRelationFilter, SkuunAiSessionWhereInput>
  }

  export type SkuunAiMessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    type?: SortOrder
    content?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SkuunAiSessionOrderByWithRelationInput
  }

  export type SkuunAiMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkuunAiMessageWhereInput | SkuunAiMessageWhereInput[]
    OR?: SkuunAiMessageWhereInput[]
    NOT?: SkuunAiMessageWhereInput | SkuunAiMessageWhereInput[]
    sessionId?: StringFilter<"SkuunAiMessage"> | string
    sender?: EnumSenderTypeFilter<"SkuunAiMessage"> | $Enums.SenderType
    type?: EnumMessageTypeFilter<"SkuunAiMessage"> | $Enums.MessageType
    content?: StringFilter<"SkuunAiMessage"> | string
    payload?: JsonNullableFilter<"SkuunAiMessage">
    createdAt?: DateTimeFilter<"SkuunAiMessage"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiMessage"> | Date | string
    session?: XOR<SkuunAiSessionScalarRelationFilter, SkuunAiSessionWhereInput>
  }, "id">

  export type SkuunAiMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    type?: SortOrder
    content?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkuunAiMessageCountOrderByAggregateInput
    _max?: SkuunAiMessageMaxOrderByAggregateInput
    _min?: SkuunAiMessageMinOrderByAggregateInput
  }

  export type SkuunAiMessageScalarWhereWithAggregatesInput = {
    AND?: SkuunAiMessageScalarWhereWithAggregatesInput | SkuunAiMessageScalarWhereWithAggregatesInput[]
    OR?: SkuunAiMessageScalarWhereWithAggregatesInput[]
    NOT?: SkuunAiMessageScalarWhereWithAggregatesInput | SkuunAiMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkuunAiMessage"> | string
    sessionId?: StringWithAggregatesFilter<"SkuunAiMessage"> | string
    sender?: EnumSenderTypeWithAggregatesFilter<"SkuunAiMessage"> | $Enums.SenderType
    type?: EnumMessageTypeWithAggregatesFilter<"SkuunAiMessage"> | $Enums.MessageType
    content?: StringWithAggregatesFilter<"SkuunAiMessage"> | string
    payload?: JsonNullableWithAggregatesFilter<"SkuunAiMessage">
    createdAt?: DateTimeWithAggregatesFilter<"SkuunAiMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SkuunAiMessage"> | Date | string
  }

  export type SkuunAiActionWhereInput = {
    AND?: SkuunAiActionWhereInput | SkuunAiActionWhereInput[]
    OR?: SkuunAiActionWhereInput[]
    NOT?: SkuunAiActionWhereInput | SkuunAiActionWhereInput[]
    id?: StringFilter<"SkuunAiAction"> | string
    sessionId?: StringFilter<"SkuunAiAction"> | string
    type?: EnumAIActionTypeFilter<"SkuunAiAction"> | $Enums.AIActionType
    payload?: JsonFilter<"SkuunAiAction">
    status?: EnumActionStatusFilter<"SkuunAiAction"> | $Enums.ActionStatus
    executedAt?: DateTimeNullableFilter<"SkuunAiAction"> | Date | string | null
    createdAt?: DateTimeFilter<"SkuunAiAction"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiAction"> | Date | string
    session?: XOR<SkuunAiSessionScalarRelationFilter, SkuunAiSessionWhereInput>
  }

  export type SkuunAiActionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SkuunAiSessionOrderByWithRelationInput
  }

  export type SkuunAiActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkuunAiActionWhereInput | SkuunAiActionWhereInput[]
    OR?: SkuunAiActionWhereInput[]
    NOT?: SkuunAiActionWhereInput | SkuunAiActionWhereInput[]
    sessionId?: StringFilter<"SkuunAiAction"> | string
    type?: EnumAIActionTypeFilter<"SkuunAiAction"> | $Enums.AIActionType
    payload?: JsonFilter<"SkuunAiAction">
    status?: EnumActionStatusFilter<"SkuunAiAction"> | $Enums.ActionStatus
    executedAt?: DateTimeNullableFilter<"SkuunAiAction"> | Date | string | null
    createdAt?: DateTimeFilter<"SkuunAiAction"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiAction"> | Date | string
    session?: XOR<SkuunAiSessionScalarRelationFilter, SkuunAiSessionWhereInput>
  }, "id">

  export type SkuunAiActionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkuunAiActionCountOrderByAggregateInput
    _max?: SkuunAiActionMaxOrderByAggregateInput
    _min?: SkuunAiActionMinOrderByAggregateInput
  }

  export type SkuunAiActionScalarWhereWithAggregatesInput = {
    AND?: SkuunAiActionScalarWhereWithAggregatesInput | SkuunAiActionScalarWhereWithAggregatesInput[]
    OR?: SkuunAiActionScalarWhereWithAggregatesInput[]
    NOT?: SkuunAiActionScalarWhereWithAggregatesInput | SkuunAiActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkuunAiAction"> | string
    sessionId?: StringWithAggregatesFilter<"SkuunAiAction"> | string
    type?: EnumAIActionTypeWithAggregatesFilter<"SkuunAiAction"> | $Enums.AIActionType
    payload?: JsonWithAggregatesFilter<"SkuunAiAction">
    status?: EnumActionStatusWithAggregatesFilter<"SkuunAiAction"> | $Enums.ActionStatus
    executedAt?: DateTimeNullableWithAggregatesFilter<"SkuunAiAction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SkuunAiAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SkuunAiAction"> | Date | string
  }

  export type SkuunAiRecommendationWhereInput = {
    AND?: SkuunAiRecommendationWhereInput | SkuunAiRecommendationWhereInput[]
    OR?: SkuunAiRecommendationWhereInput[]
    NOT?: SkuunAiRecommendationWhereInput | SkuunAiRecommendationWhereInput[]
    id?: StringFilter<"SkuunAiRecommendation"> | string
    sessionId?: StringFilter<"SkuunAiRecommendation"> | string
    category?: StringFilter<"SkuunAiRecommendation"> | string
    targetId?: StringNullableFilter<"SkuunAiRecommendation"> | string | null
    message?: StringFilter<"SkuunAiRecommendation"> | string
    data?: JsonNullableFilter<"SkuunAiRecommendation">
    resolved?: BoolFilter<"SkuunAiRecommendation"> | boolean
    createdAt?: DateTimeFilter<"SkuunAiRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiRecommendation"> | Date | string
    session?: XOR<SkuunAiSessionScalarRelationFilter, SkuunAiSessionWhereInput>
  }

  export type SkuunAiRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    category?: SortOrder
    targetId?: SortOrderInput | SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SkuunAiSessionOrderByWithRelationInput
  }

  export type SkuunAiRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkuunAiRecommendationWhereInput | SkuunAiRecommendationWhereInput[]
    OR?: SkuunAiRecommendationWhereInput[]
    NOT?: SkuunAiRecommendationWhereInput | SkuunAiRecommendationWhereInput[]
    sessionId?: StringFilter<"SkuunAiRecommendation"> | string
    category?: StringFilter<"SkuunAiRecommendation"> | string
    targetId?: StringNullableFilter<"SkuunAiRecommendation"> | string | null
    message?: StringFilter<"SkuunAiRecommendation"> | string
    data?: JsonNullableFilter<"SkuunAiRecommendation">
    resolved?: BoolFilter<"SkuunAiRecommendation"> | boolean
    createdAt?: DateTimeFilter<"SkuunAiRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiRecommendation"> | Date | string
    session?: XOR<SkuunAiSessionScalarRelationFilter, SkuunAiSessionWhereInput>
  }, "id">

  export type SkuunAiRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    category?: SortOrder
    targetId?: SortOrderInput | SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkuunAiRecommendationCountOrderByAggregateInput
    _max?: SkuunAiRecommendationMaxOrderByAggregateInput
    _min?: SkuunAiRecommendationMinOrderByAggregateInput
  }

  export type SkuunAiRecommendationScalarWhereWithAggregatesInput = {
    AND?: SkuunAiRecommendationScalarWhereWithAggregatesInput | SkuunAiRecommendationScalarWhereWithAggregatesInput[]
    OR?: SkuunAiRecommendationScalarWhereWithAggregatesInput[]
    NOT?: SkuunAiRecommendationScalarWhereWithAggregatesInput | SkuunAiRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkuunAiRecommendation"> | string
    sessionId?: StringWithAggregatesFilter<"SkuunAiRecommendation"> | string
    category?: StringWithAggregatesFilter<"SkuunAiRecommendation"> | string
    targetId?: StringNullableWithAggregatesFilter<"SkuunAiRecommendation"> | string | null
    message?: StringWithAggregatesFilter<"SkuunAiRecommendation"> | string
    data?: JsonNullableWithAggregatesFilter<"SkuunAiRecommendation">
    resolved?: BoolWithAggregatesFilter<"SkuunAiRecommendation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SkuunAiRecommendation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SkuunAiRecommendation"> | Date | string
  }

  export type DecisionRecordWhereInput = {
    AND?: DecisionRecordWhereInput | DecisionRecordWhereInput[]
    OR?: DecisionRecordWhereInput[]
    NOT?: DecisionRecordWhereInput | DecisionRecordWhereInput[]
    id?: StringFilter<"DecisionRecord"> | string
    title?: StringFilter<"DecisionRecord"> | string
    context?: StringFilter<"DecisionRecord"> | string
    decision?: StringFilter<"DecisionRecord"> | string
    consequences?: StringFilter<"DecisionRecord"> | string
    status?: EnumDecisionStatusFilter<"DecisionRecord"> | $Enums.DecisionStatus
    supersedesId?: StringNullableFilter<"DecisionRecord"> | string | null
    authorId?: StringFilter<"DecisionRecord"> | string
    schoolId?: StringFilter<"DecisionRecord"> | string
    createdAt?: DateTimeFilter<"DecisionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"DecisionRecord"> | Date | string
    implementedAt?: DateTimeNullableFilter<"DecisionRecord"> | Date | string | null
    supersedes?: XOR<DecisionRecordNullableScalarRelationFilter, DecisionRecordWhereInput> | null
    supersededBy?: DecisionRecordListRelationFilter
  }

  export type DecisionRecordOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    context?: SortOrder
    decision?: SortOrder
    consequences?: SortOrder
    status?: SortOrder
    supersedesId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    implementedAt?: SortOrderInput | SortOrder
    supersedes?: DecisionRecordOrderByWithRelationInput
    supersededBy?: DecisionRecordOrderByRelationAggregateInput
  }

  export type DecisionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DecisionRecordWhereInput | DecisionRecordWhereInput[]
    OR?: DecisionRecordWhereInput[]
    NOT?: DecisionRecordWhereInput | DecisionRecordWhereInput[]
    title?: StringFilter<"DecisionRecord"> | string
    context?: StringFilter<"DecisionRecord"> | string
    decision?: StringFilter<"DecisionRecord"> | string
    consequences?: StringFilter<"DecisionRecord"> | string
    status?: EnumDecisionStatusFilter<"DecisionRecord"> | $Enums.DecisionStatus
    supersedesId?: StringNullableFilter<"DecisionRecord"> | string | null
    authorId?: StringFilter<"DecisionRecord"> | string
    schoolId?: StringFilter<"DecisionRecord"> | string
    createdAt?: DateTimeFilter<"DecisionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"DecisionRecord"> | Date | string
    implementedAt?: DateTimeNullableFilter<"DecisionRecord"> | Date | string | null
    supersedes?: XOR<DecisionRecordNullableScalarRelationFilter, DecisionRecordWhereInput> | null
    supersededBy?: DecisionRecordListRelationFilter
  }, "id">

  export type DecisionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    context?: SortOrder
    decision?: SortOrder
    consequences?: SortOrder
    status?: SortOrder
    supersedesId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    implementedAt?: SortOrderInput | SortOrder
    _count?: DecisionRecordCountOrderByAggregateInput
    _max?: DecisionRecordMaxOrderByAggregateInput
    _min?: DecisionRecordMinOrderByAggregateInput
  }

  export type DecisionRecordScalarWhereWithAggregatesInput = {
    AND?: DecisionRecordScalarWhereWithAggregatesInput | DecisionRecordScalarWhereWithAggregatesInput[]
    OR?: DecisionRecordScalarWhereWithAggregatesInput[]
    NOT?: DecisionRecordScalarWhereWithAggregatesInput | DecisionRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DecisionRecord"> | string
    title?: StringWithAggregatesFilter<"DecisionRecord"> | string
    context?: StringWithAggregatesFilter<"DecisionRecord"> | string
    decision?: StringWithAggregatesFilter<"DecisionRecord"> | string
    consequences?: StringWithAggregatesFilter<"DecisionRecord"> | string
    status?: EnumDecisionStatusWithAggregatesFilter<"DecisionRecord"> | $Enums.DecisionStatus
    supersedesId?: StringNullableWithAggregatesFilter<"DecisionRecord"> | string | null
    authorId?: StringWithAggregatesFilter<"DecisionRecord"> | string
    schoolId?: StringWithAggregatesFilter<"DecisionRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DecisionRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DecisionRecord"> | Date | string
    implementedAt?: DateTimeNullableWithAggregatesFilter<"DecisionRecord"> | Date | string | null
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    application?: ApplicationCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    application?: ApplicationUncheckedCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    grades?: GradeCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    staff?: StaffCreateNestedManyWithoutClassInput
    exams?: ExamCreateNestedManyWithoutClassInput
    subjects?: SubjectCreateNestedManyWithoutClassesInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    staff?: StaffUncheckedCreateNestedManyWithoutClassInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassesInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    staff?: StaffUpdateManyWithoutClassNestedInput
    exams?: ExamUpdateManyWithoutClassNestedInput
    subjects?: SubjectUpdateManyWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    staff?: StaffUncheckedUpdateManyWithoutClassNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateInput = {
    id?: string
    name?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutGradesInput
    students?: StudentCreateNestedManyWithoutGradeInput
    staff?: StaffCreateNestedManyWithoutGradesInput
    Application?: ApplicationCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    name?: string
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutGradeInput
    staff?: StaffUncheckedCreateNestedManyWithoutGradesInput
    Application?: ApplicationUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutGradesNestedInput
    students?: StudentUpdateManyWithoutGradeNestedInput
    staff?: StaffUpdateManyWithoutGradesNestedInput
    Application?: ApplicationUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutGradeNestedInput
    staff?: StaffUncheckedUpdateManyWithoutGradesNestedInput
    Application?: ApplicationUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeCreateManyInput = {
    id?: string
    name?: string
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
    staff?: StaffCreateNestedManyWithoutSubjectsInput
    students?: StudentCreateNestedManyWithoutSubjectsInput
    classes?: ClassCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    staff?: StaffUncheckedCreateNestedManyWithoutSubjectsInput
    students?: StudentUncheckedCreateNestedManyWithoutSubjectsInput
    classes?: ClassUncheckedCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
    staff?: StaffUpdateManyWithoutSubjectsNestedInput
    students?: StudentUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    staff?: StaffUncheckedUpdateManyWithoutSubjectsNestedInput
    students?: StudentUncheckedUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutExamInput
    class?: ClassCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    title: string
    studentId?: string | null
    classId?: string | null
    subjectId: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutExamNestedInput
    class?: ClassUpdateOneWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyInput = {
    id?: string
    title: string
    studentId?: string | null
    classId?: string | null
    subjectId: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateInput = {
    id?: string
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutApplicationInput
    user?: UserCreateNestedOneWithoutApplicationInput
    school?: SchoolCreateNestedOneWithoutApplicationsInput
    admissionPayment?: AdmissionPaymentCreateNestedOneWithoutApplicationInput
    previousSchools?: PreviousSchoolCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutApplicationInput
    grade?: GradeCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    schoolId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    previousSchools?: PreviousSchoolUncheckedCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutApplicationNestedInput
    user?: UserUpdateOneWithoutApplicationNestedInput
    school?: SchoolUpdateOneWithoutApplicationsNestedInput
    admissionPayment?: AdmissionPaymentUpdateOneWithoutApplicationNestedInput
    previousSchools?: PreviousSchoolUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutApplicationNestedInput
    grade?: GradeUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousSchools?: PreviousSchoolUncheckedUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationCreateManyInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    schoolId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousSchoolCreateInput = {
    id?: string
    name: string
    location: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    application: ApplicationCreateNestedOneWithoutPreviousSchoolsInput
  }

  export type PreviousSchoolUncheckedCreateInput = {
    id?: string
    applicationId: string
    name: string
    location: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousSchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: ApplicationUpdateOneRequiredWithoutPreviousSchoolsNestedInput
  }

  export type PreviousSchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousSchoolCreateManyInput = {
    id?: string
    applicationId: string
    name: string
    location: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousSchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousSchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberCreateInput = {
    id?: string
    relation: string
    name: string
    postalAddress: string
    residentialAddress: string
    phone?: string | null
    email?: string | null
    occupation?: string | null
    workplace?: string | null
    religion?: string | null
    isAlive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    application: ApplicationCreateNestedOneWithoutFamilyMembersInput
  }

  export type FamilyMemberUncheckedCreateInput = {
    id?: string
    applicationId: string
    relation: string
    name: string
    postalAddress: string
    residentialAddress: string
    phone?: string | null
    email?: string | null
    occupation?: string | null
    workplace?: string | null
    religion?: string | null
    isAlive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    residentialAddress?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: ApplicationUpdateOneRequiredWithoutFamilyMembersNestedInput
  }

  export type FamilyMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    residentialAddress?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberCreateManyInput = {
    id?: string
    applicationId: string
    relation: string
    name: string
    postalAddress: string
    residentialAddress: string
    phone?: string | null
    email?: string | null
    occupation?: string | null
    workplace?: string | null
    religion?: string | null
    isAlive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    residentialAddress?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    residentialAddress?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffApplicationCreateInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutStaffApplicationInput
    school: SchoolCreateNestedOneWithoutStaffApplicationInput
    department?: DepartmentCreateNestedOneWithoutStaffApplicationInput
    subjects?: SubjectCreateNestedManyWithoutStaffApplicationsInput
    previousJobs?: PreviousJobCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationUncheckedCreateInput = {
    id?: string
    staffId?: string | null
    schoolId: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    departmentId?: string | null
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffApplicationsInput
    previousJobs?: PreviousJobUncheckedCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutStaffApplicationNestedInput
    school?: SchoolUpdateOneRequiredWithoutStaffApplicationNestedInput
    department?: DepartmentUpdateOneWithoutStaffApplicationNestedInput
    subjects?: SubjectUpdateManyWithoutStaffApplicationsNestedInput
    previousJobs?: PreviousJobUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutStaffApplicationsNestedInput
    previousJobs?: PreviousJobUncheckedUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationCreateManyInput = {
    id?: string
    staffId?: string | null
    schoolId: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    departmentId?: string | null
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousJobCreateInput = {
    id?: string
    company: string
    role: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staffApplication: StaffApplicationCreateNestedOneWithoutPreviousJobsInput
  }

  export type PreviousJobUncheckedCreateInput = {
    id?: string
    staffApplicationId: string
    company: string
    role: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffApplication?: StaffApplicationUpdateOneRequiredWithoutPreviousJobsNestedInput
  }

  export type PreviousJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffApplicationId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousJobCreateManyInput = {
    id?: string
    staffApplicationId: string
    company: string
    role: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffApplicationId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffInput
    class?: ClassCreateNestedOneWithoutStaffInput
    grades?: GradeCreateNestedManyWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    subjects?: SubjectCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    userId: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStaffInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceUncheckedCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
    class?: ClassUpdateOneWithoutStaffNestedInput
    grades?: GradeUpdateManyWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    subjects?: SubjectUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStaffNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUncheckedUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: string
    userId: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    LibraryStaff?: LibraryStaffCreateNestedManyWithoutDepartmentInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedManyWithoutDepartmentInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    LibraryStaff?: LibraryStaffUpdateManyWithoutDepartmentNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateManyWithoutDepartmentNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAttendanceCreateInput = {
    id?: string
    classId: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentAttendanceInput
  }

  export type StudentAttendanceUncheckedCreateInput = {
    id?: string
    studentId: string
    classId: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentAttendanceNestedInput
  }

  export type StudentAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateManyInput = {
    id?: string
    studentId: string
    classId: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceCreateInput = {
    id?: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutAttendancesInput
  }

  export type StaffAttendanceUncheckedCreateInput = {
    id?: string
    staffId: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type StaffAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceCreateManyInput = {
    id?: string
    staffId: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    studentId: string
    name: string
    email: string
    phone?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateManyInput = {
    id?: string
    studentId: string
    name: string
    email: string
    phone?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorCreateInput = {
    id?: string
    name: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateInput = {
    id?: string
    name: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorCreateManyInput = {
    id?: string
    name: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateInput = {
    id?: string
    title: string
    isbn: string
    totalCopies?: number
    available?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AuthorCreateNestedOneWithoutBooksInput
    category?: CategoryCreateNestedOneWithoutBooksInput
    school: SchoolCreateNestedOneWithoutBookInput
    borrows?: BorrowCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateInput = {
    id?: string
    title: string
    isbn: string
    authorId: string
    categoryId?: string | null
    totalCopies?: number
    available?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrows?: BorrowUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutBooksNestedInput
    category?: CategoryUpdateOneWithoutBooksNestedInput
    school?: SchoolUpdateOneRequiredWithoutBookNestedInput
    borrows?: BorrowUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrows?: BorrowUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookCreateManyInput = {
    id?: string
    title: string
    isbn: string
    authorId: string
    categoryId?: string | null
    totalCopies?: number
    available?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowCreateInput = {
    id?: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutBorrowsInput
    student: StudentCreateNestedOneWithoutBorrowInput
  }

  export type BorrowUncheckedCreateInput = {
    id?: string
    bookId: string
    studentId: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutBorrowsNestedInput
    student?: StudentUpdateOneRequiredWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowCreateManyInput = {
    id?: string
    bookId: string
    studentId: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStaffCreateInput = {
    id?: string
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLibraryStaffInput
    department: DepartmentCreateNestedOneWithoutLibraryStaffInput
  }

  export type LibraryStaffUncheckedCreateInput = {
    id?: string
    userId: string
    departmentId: string
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLibraryStaffNestedInput
    department?: DepartmentUpdateOneRequiredWithoutLibraryStaffNestedInput
  }

  export type LibraryStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStaffCreateManyInput = {
    id?: string
    userId: string
    departmentId: string
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionPaymentCreateInput = {
    id?: string
    studentId: string
    schoolId: string
    amount: number
    pinCode: string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Application?: ApplicationCreateNestedManyWithoutAdmissionPaymentInput
  }

  export type AdmissionPaymentUncheckedCreateInput = {
    id?: string
    studentId: string
    schoolId: string
    amount: number
    pinCode: string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Application?: ApplicationUncheckedCreateNestedManyWithoutAdmissionPaymentInput
  }

  export type AdmissionPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    pinCode?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Application?: ApplicationUpdateManyWithoutAdmissionPaymentNestedInput
  }

  export type AdmissionPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    pinCode?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Application?: ApplicationUncheckedUpdateManyWithoutAdmissionPaymentNestedInput
  }

  export type AdmissionPaymentCreateManyInput = {
    id?: string
    studentId: string
    schoolId: string
    amount: number
    pinCode: string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    pinCode?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    pinCode?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type?: $Enums.FinanceType
    feeType?: $Enums.FeeType | null
    amount: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    studentId: string
    type?: $Enums.FinanceType
    feeType?: $Enums.FeeType | null
    amount: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    feeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    feeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    studentId: string
    type?: $Enums.FinanceType
    feeType?: $Enums.FeeType | null
    amount: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    feeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    feeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinanceCreateInput = {
    id?: string
    type?: $Enums.FinanceType
    amount: number
    description?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFinancesInput
  }

  export type FinanceUncheckedCreateInput = {
    id?: string
    schoolId: string
    type?: $Enums.FinanceType
    amount: number
    description?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFinancesNestedInput
  }

  export type FinanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinanceCreateManyInput = {
    id?: string
    schoolId: string
    type?: $Enums.FinanceType
    amount: number
    description?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    id?: string
    name: string
    category?: string | null
    unitPrice: number
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutResourcesInput
    purchases?: PurchaseCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    name: string
    category?: string | null
    unitPrice: number
    quantity?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutResourcesNestedInput
    purchases?: PurchaseUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: string
    name: string
    category?: string | null
    unitPrice: number
    quantity?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutPurchaseInput
    resource: ResourceCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    studentId: string
    resourceId: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutPurchaseNestedInput
    resource?: ResourceUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyInput = {
    id?: string
    studentId: string
    resourceId: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusCreateInput = {
    id?: string
    plateNumber: string
    driverName: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutBusesInput
  }

  export type BusUncheckedCreateInput = {
    id?: string
    schoolId: string
    plateNumber: string
    driverName: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    driverName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutBusesNestedInput
  }

  export type BusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    driverName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusCreateManyInput = {
    id?: string
    schoolId: string
    plateNumber: string
    driverName: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    driverName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    driverName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiSessionCreateInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSkuunAiSessionInput
    messages?: SkuunAiMessageCreateNestedManyWithoutSessionInput
    actions?: SkuunAiActionCreateNestedManyWithoutSessionInput
    SkuunAiRecommendation?: SkuunAiRecommendationCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionUncheckedCreateInput = {
    id?: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SkuunAiMessageUncheckedCreateNestedManyWithoutSessionInput
    actions?: SkuunAiActionUncheckedCreateNestedManyWithoutSessionInput
    SkuunAiRecommendation?: SkuunAiRecommendationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkuunAiSessionNestedInput
    messages?: SkuunAiMessageUpdateManyWithoutSessionNestedInput
    actions?: SkuunAiActionUpdateManyWithoutSessionNestedInput
    SkuunAiRecommendation?: SkuunAiRecommendationUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SkuunAiMessageUncheckedUpdateManyWithoutSessionNestedInput
    actions?: SkuunAiActionUncheckedUpdateManyWithoutSessionNestedInput
    SkuunAiRecommendation?: SkuunAiRecommendationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionCreateManyInput = {
    id?: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiMessageCreateInput = {
    id?: string
    sender: $Enums.SenderType
    type: $Enums.MessageType
    content: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SkuunAiSessionCreateNestedOneWithoutMessagesInput
  }

  export type SkuunAiMessageUncheckedCreateInput = {
    id?: string
    sessionId: string
    sender: $Enums.SenderType
    type: $Enums.MessageType
    content: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SkuunAiSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type SkuunAiMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiMessageCreateManyInput = {
    id?: string
    sessionId: string
    sender: $Enums.SenderType
    type: $Enums.MessageType
    content: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiActionCreateInput = {
    id?: string
    type: $Enums.AIActionType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ActionStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SkuunAiSessionCreateNestedOneWithoutActionsInput
  }

  export type SkuunAiActionUncheckedCreateInput = {
    id?: string
    sessionId: string
    type: $Enums.AIActionType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ActionStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAIActionTypeFieldUpdateOperationsInput | $Enums.AIActionType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SkuunAiSessionUpdateOneRequiredWithoutActionsNestedInput
  }

  export type SkuunAiActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumAIActionTypeFieldUpdateOperationsInput | $Enums.AIActionType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiActionCreateManyInput = {
    id?: string
    sessionId: string
    type: $Enums.AIActionType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ActionStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAIActionTypeFieldUpdateOperationsInput | $Enums.AIActionType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumAIActionTypeFieldUpdateOperationsInput | $Enums.AIActionType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiRecommendationCreateInput = {
    id?: string
    category: string
    targetId?: string | null
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SkuunAiSessionCreateNestedOneWithoutSkuunAiRecommendationInput
  }

  export type SkuunAiRecommendationUncheckedCreateInput = {
    id?: string
    sessionId: string
    category: string
    targetId?: string | null
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SkuunAiSessionUpdateOneRequiredWithoutSkuunAiRecommendationNestedInput
  }

  export type SkuunAiRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiRecommendationCreateManyInput = {
    id?: string
    sessionId: string
    category: string
    targetId?: string | null
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionRecordCreateInput = {
    id?: string
    title: string
    context: string
    decision: string
    consequences: string
    status?: $Enums.DecisionStatus
    authorId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    implementedAt?: Date | string | null
    supersedes?: DecisionRecordCreateNestedOneWithoutSupersededByInput
    supersededBy?: DecisionRecordCreateNestedManyWithoutSupersedesInput
  }

  export type DecisionRecordUncheckedCreateInput = {
    id?: string
    title: string
    context: string
    decision: string
    consequences: string
    status?: $Enums.DecisionStatus
    supersedesId?: string | null
    authorId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    implementedAt?: Date | string | null
    supersededBy?: DecisionRecordUncheckedCreateNestedManyWithoutSupersedesInput
  }

  export type DecisionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supersedes?: DecisionRecordUpdateOneWithoutSupersededByNestedInput
    supersededBy?: DecisionRecordUpdateManyWithoutSupersedesNestedInput
  }

  export type DecisionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    supersedesId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supersededBy?: DecisionRecordUncheckedUpdateManyWithoutSupersedesNestedInput
  }

  export type DecisionRecordCreateManyInput = {
    id?: string
    title: string
    context: string
    decision: string
    consequences: string
    status?: $Enums.DecisionStatus
    supersedesId?: string | null
    authorId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    implementedAt?: Date | string | null
  }

  export type DecisionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DecisionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    supersedesId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type BusListRelationFilter = {
    every?: BusWhereInput
    some?: BusWhereInput
    none?: BusWhereInput
  }

  export type FinanceListRelationFilter = {
    every?: FinanceWhereInput
    some?: FinanceWhereInput
    none?: FinanceWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type BookListRelationFilter = {
    every?: BookWhereInput
    some?: BookWhereInput
    none?: BookWhereInput
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type StaffApplicationListRelationFilter = {
    every?: StaffApplicationWhereInput
    some?: StaffApplicationWhereInput
    none?: StaffApplicationWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type SchoolScalarRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type StaffNullableScalarRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type LibraryStaffNullableScalarRelationFilter = {
    is?: LibraryStaffWhereInput | null
    isNot?: LibraryStaffWhereInput | null
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type ApplicationNullableScalarRelationFilter = {
    is?: ApplicationWhereInput | null
    isNot?: ApplicationWhereInput | null
  }

  export type SkuunAiSessionListRelationFilter = {
    every?: SkuunAiSessionWhereInput
    some?: SkuunAiSessionWhereInput
    none?: SkuunAiSessionWhereInput
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkuunAiSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type StudentAttendanceListRelationFilter = {
    every?: StudentAttendanceWhereInput
    some?: StudentAttendanceWhereInput
    none?: StudentAttendanceWhereInput
  }

  export type ParentListRelationFilter = {
    every?: ParentWhereInput
    some?: ParentWhereInput
    none?: ParentWhereInput
  }

  export type BorrowListRelationFilter = {
    every?: BorrowWhereInput
    some?: BorrowWhereInput
    none?: BorrowWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type GradeNullableScalarRelationFilter = {
    is?: GradeWhereInput | null
    isNot?: GradeWhereInput | null
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BorrowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    enrolledAt?: SortOrder
    classId?: SortOrder
    gradeId?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    enrolledAt?: SortOrder
    classId?: SortOrder
    gradeId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    enrolledAt?: SortOrder
    classId?: SortOrder
    gradeId?: SortOrder
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type StaffListRelationFilter = {
    every?: StaffWhereInput
    some?: StaffWhereInput
    none?: StaffWhereInput
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassNameSchoolIdCompoundUniqueInput = {
    name: string
    schoolId: string
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeNameClassIdCompoundUniqueInput = {
    name: string
    classId: string
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SchoolNullableScalarRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type AdmissionPaymentNullableScalarRelationFilter = {
    is?: AdmissionPaymentWhereInput | null
    isNot?: AdmissionPaymentWhereInput | null
  }

  export type PreviousSchoolListRelationFilter = {
    every?: PreviousSchoolWhereInput
    some?: PreviousSchoolWhereInput
    none?: PreviousSchoolWhereInput
  }

  export type FamilyMemberListRelationFilter = {
    every?: FamilyMemberWhereInput
    some?: FamilyMemberWhereInput
    none?: FamilyMemberWhereInput
  }

  export type PreviousSchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    admissionPaymentId?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    sex?: SortOrder
    languages?: SortOrder
    gradeId?: SortOrder
    mothersTongue?: SortOrder
    religion?: SortOrder
    denomination?: SortOrder
    hometown?: SortOrder
    region?: SortOrder
    profilePicture?: SortOrder
    wardLivesWith?: SortOrder
    numberOfSiblings?: SortOrder
    siblingsOlder?: SortOrder
    siblingsYounger?: SortOrder
    postalAddress?: SortOrder
    residentialAddress?: SortOrder
    wardMobile?: SortOrder
    emergencyContact?: SortOrder
    emergencyMedicalContact?: SortOrder
    medicalSummary?: SortOrder
    bloodType?: SortOrder
    specialDisability?: SortOrder
    feesAcknowledged?: SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrder
    submissionDate?: SortOrder
    classification?: SortOrder
    submittedBy?: SortOrder
    receivedBy?: SortOrder
    receivedDate?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationAvgOrderByAggregateInput = {
    numberOfSiblings?: SortOrder
    siblingsOlder?: SortOrder
    siblingsYounger?: SortOrder
    progress?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    admissionPaymentId?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    sex?: SortOrder
    gradeId?: SortOrder
    mothersTongue?: SortOrder
    religion?: SortOrder
    denomination?: SortOrder
    hometown?: SortOrder
    region?: SortOrder
    profilePicture?: SortOrder
    wardLivesWith?: SortOrder
    numberOfSiblings?: SortOrder
    siblingsOlder?: SortOrder
    siblingsYounger?: SortOrder
    postalAddress?: SortOrder
    residentialAddress?: SortOrder
    wardMobile?: SortOrder
    emergencyContact?: SortOrder
    emergencyMedicalContact?: SortOrder
    medicalSummary?: SortOrder
    bloodType?: SortOrder
    specialDisability?: SortOrder
    feesAcknowledged?: SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrder
    submissionDate?: SortOrder
    classification?: SortOrder
    submittedBy?: SortOrder
    receivedBy?: SortOrder
    receivedDate?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    admissionPaymentId?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    sex?: SortOrder
    gradeId?: SortOrder
    mothersTongue?: SortOrder
    religion?: SortOrder
    denomination?: SortOrder
    hometown?: SortOrder
    region?: SortOrder
    profilePicture?: SortOrder
    wardLivesWith?: SortOrder
    numberOfSiblings?: SortOrder
    siblingsOlder?: SortOrder
    siblingsYounger?: SortOrder
    postalAddress?: SortOrder
    residentialAddress?: SortOrder
    wardMobile?: SortOrder
    emergencyContact?: SortOrder
    emergencyMedicalContact?: SortOrder
    medicalSummary?: SortOrder
    bloodType?: SortOrder
    specialDisability?: SortOrder
    feesAcknowledged?: SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrder
    submissionDate?: SortOrder
    classification?: SortOrder
    submittedBy?: SortOrder
    receivedBy?: SortOrder
    receivedDate?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationSumOrderByAggregateInput = {
    numberOfSiblings?: SortOrder
    siblingsOlder?: SortOrder
    siblingsYounger?: SortOrder
    progress?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ApplicationScalarRelationFilter = {
    is?: ApplicationWhereInput
    isNot?: ApplicationWhereInput
  }

  export type PreviousSchoolCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreviousSchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreviousSchoolMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyMemberCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    relation?: SortOrder
    name?: SortOrder
    postalAddress?: SortOrder
    residentialAddress?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    occupation?: SortOrder
    workplace?: SortOrder
    religion?: SortOrder
    isAlive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    relation?: SortOrder
    name?: SortOrder
    postalAddress?: SortOrder
    residentialAddress?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    occupation?: SortOrder
    workplace?: SortOrder
    religion?: SortOrder
    isAlive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyMemberMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    relation?: SortOrder
    name?: SortOrder
    postalAddress?: SortOrder
    residentialAddress?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    occupation?: SortOrder
    workplace?: SortOrder
    religion?: SortOrder
    isAlive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type PreviousJobListRelationFilter = {
    every?: PreviousJobWhereInput
    some?: PreviousJobWhereInput
    none?: PreviousJobWhereInput
  }

  export type PreviousJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    schoolId?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    sex?: SortOrder
    languages?: SortOrder
    maritalStatus?: SortOrder
    religion?: SortOrder
    denomination?: SortOrder
    hometown?: SortOrder
    region?: SortOrder
    profilePicture?: SortOrder
    residentialAddress?: SortOrder
    postalAddress?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    emergencyContact?: SortOrder
    nextOfKin?: SortOrder
    position?: SortOrder
    departmentId?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    qualifications?: SortOrder
    bloodType?: SortOrder
    medicalConditions?: SortOrder
    specialDisability?: SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrder
    submissionDate?: SortOrder
    classification?: SortOrder
    submittedBy?: SortOrder
    receivedBy?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffApplicationAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type StaffApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    schoolId?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    sex?: SortOrder
    maritalStatus?: SortOrder
    religion?: SortOrder
    denomination?: SortOrder
    hometown?: SortOrder
    region?: SortOrder
    profilePicture?: SortOrder
    residentialAddress?: SortOrder
    postalAddress?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    emergencyContact?: SortOrder
    nextOfKin?: SortOrder
    position?: SortOrder
    departmentId?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    qualifications?: SortOrder
    bloodType?: SortOrder
    medicalConditions?: SortOrder
    specialDisability?: SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrder
    submissionDate?: SortOrder
    classification?: SortOrder
    submittedBy?: SortOrder
    receivedBy?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    schoolId?: SortOrder
    surname?: SortOrder
    firstName?: SortOrder
    otherNames?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    sex?: SortOrder
    maritalStatus?: SortOrder
    religion?: SortOrder
    denomination?: SortOrder
    hometown?: SortOrder
    region?: SortOrder
    profilePicture?: SortOrder
    residentialAddress?: SortOrder
    postalAddress?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    emergencyContact?: SortOrder
    nextOfKin?: SortOrder
    position?: SortOrder
    departmentId?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    qualifications?: SortOrder
    bloodType?: SortOrder
    medicalConditions?: SortOrder
    specialDisability?: SortOrder
    declarationSigned?: SortOrder
    signature?: SortOrder
    submissionDate?: SortOrder
    classification?: SortOrder
    submittedBy?: SortOrder
    receivedBy?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffApplicationSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type StaffApplicationScalarRelationFilter = {
    is?: StaffApplicationWhereInput
    isNot?: StaffApplicationWhereInput
  }

  export type PreviousJobCountOrderByAggregateInput = {
    id?: SortOrder
    staffApplicationId?: SortOrder
    company?: SortOrder
    role?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreviousJobMaxOrderByAggregateInput = {
    id?: SortOrder
    staffApplicationId?: SortOrder
    company?: SortOrder
    role?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreviousJobMinOrderByAggregateInput = {
    id?: SortOrder
    staffApplicationId?: SortOrder
    company?: SortOrder
    role?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAttendanceListRelationFilter = {
    every?: StaffAttendanceWhereInput
    some?: StaffAttendanceWhereInput
    none?: StaffAttendanceWhereInput
  }

  export type StaffApplicationNullableScalarRelationFilter = {
    is?: StaffApplicationWhereInput | null
    isNot?: StaffApplicationWhereInput | null
  }

  export type StaffAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    position?: SortOrder
    salary?: SortOrder
    hireDate?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    position?: SortOrder
    salary?: SortOrder
    hireDate?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    position?: SortOrder
    salary?: SortOrder
    hireDate?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type LibraryStaffListRelationFilter = {
    every?: LibraryStaffWhereInput
    some?: LibraryStaffWhereInput
    none?: LibraryStaffWhereInput
  }

  export type LibraryStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentAttendanceStudentId_dateCompoundUniqueInput = {
    studentId: string
    date: Date | string
  }

  export type StudentAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type StaffScalarRelationFilter = {
    is?: StaffWhereInput
    isNot?: StaffWhereInput
  }

  export type StaffAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorScalarRelationFilter = {
    is?: AuthorWhereInput
    isNot?: AuthorWhereInput
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type BookCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    totalCopies?: SortOrder
    available?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookAvgOrderByAggregateInput = {
    totalCopies?: SortOrder
    available?: SortOrder
  }

  export type BookMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    totalCopies?: SortOrder
    available?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    totalCopies?: SortOrder
    available?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookSumOrderByAggregateInput = {
    totalCopies?: SortOrder
    available?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BookScalarRelationFilter = {
    is?: BookWhereInput
    isNot?: BookWhereInput
  }

  export type BorrowUnique_borrowCompoundUniqueInput = {
    bookId: string
    studentId: string
    borrowedAt: Date | string
  }

  export type BorrowCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    borrowedAt?: SortOrder
    dueAt?: SortOrder
    returnedAt?: SortOrder
    fine?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowAvgOrderByAggregateInput = {
    fine?: SortOrder
  }

  export type BorrowMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    borrowedAt?: SortOrder
    dueAt?: SortOrder
    returnedAt?: SortOrder
    fine?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    borrowedAt?: SortOrder
    dueAt?: SortOrder
    returnedAt?: SortOrder
    fine?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowSumOrderByAggregateInput = {
    fine?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type LibraryStaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryStaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    pinCode?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AdmissionPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    pinCode?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    pinCode?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumFinanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinanceType | EnumFinanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinanceType[] | ListEnumFinanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinanceType[] | ListEnumFinanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinanceTypeFilter<$PrismaModel> | $Enums.FinanceType
  }

  export type EnumFeeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeeTypeNullableFilter<$PrismaModel> | $Enums.FeeType | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    feeType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    feeType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    feeType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumFinanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinanceType | EnumFinanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinanceType[] | ListEnumFinanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinanceType[] | ListEnumFinanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinanceTypeFilter<$PrismaModel>
    _max?: NestedEnumFinanceTypeFilter<$PrismaModel>
  }

  export type EnumFeeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FeeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFeeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFeeTypeNullableFilter<$PrismaModel>
  }

  export type FinanceCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinanceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FinanceMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinanceMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinanceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ResourceNameSchoolIdCompoundUniqueInput = {
    name: string
    schoolId: string
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    unitPrice?: SortOrder
    quantity?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    unitPrice?: SortOrder
    quantity?: SortOrder
  }

  export type ResourceScalarRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    quantity?: SortOrder
    totalCost?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    quantity?: SortOrder
    totalCost?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    plateNumber?: SortOrder
    driverName?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type BusMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    plateNumber?: SortOrder
    driverName?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    plateNumber?: SortOrder
    driverName?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type SkuunAiMessageListRelationFilter = {
    every?: SkuunAiMessageWhereInput
    some?: SkuunAiMessageWhereInput
    none?: SkuunAiMessageWhereInput
  }

  export type SkuunAiActionListRelationFilter = {
    every?: SkuunAiActionWhereInput
    some?: SkuunAiActionWhereInput
    none?: SkuunAiActionWhereInput
  }

  export type SkuunAiRecommendationListRelationFilter = {
    every?: SkuunAiRecommendationWhereInput
    some?: SkuunAiRecommendationWhereInput
    none?: SkuunAiRecommendationWhereInput
  }

  export type SkuunAiMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkuunAiActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkuunAiRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkuunAiSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkuunAiSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkuunAiSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SkuunAiSessionScalarRelationFilter = {
    is?: SkuunAiSessionWhereInput
    isNot?: SkuunAiSessionWhereInput
  }

  export type SkuunAiMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    type?: SortOrder
    content?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkuunAiMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkuunAiMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAIActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIActionType | EnumAIActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIActionType[] | ListEnumAIActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIActionType[] | ListEnumAIActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIActionTypeFilter<$PrismaModel> | $Enums.AIActionType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumActionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionStatus | EnumActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionStatusFilter<$PrismaModel> | $Enums.ActionStatus
  }

  export type SkuunAiActionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkuunAiActionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkuunAiActionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAIActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIActionType | EnumAIActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIActionType[] | ListEnumAIActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIActionType[] | ListEnumAIActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAIActionTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumActionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionStatus | EnumActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionStatusFilter<$PrismaModel>
    _max?: NestedEnumActionStatusFilter<$PrismaModel>
  }

  export type SkuunAiRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    category?: SortOrder
    targetId?: SortOrder
    message?: SortOrder
    data?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkuunAiRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    category?: SortOrder
    targetId?: SortOrder
    message?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkuunAiRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    category?: SortOrder
    targetId?: SortOrder
    message?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDecisionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionStatus | EnumDecisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionStatus[] | ListEnumDecisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionStatus[] | ListEnumDecisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionStatusFilter<$PrismaModel> | $Enums.DecisionStatus
  }

  export type DecisionRecordNullableScalarRelationFilter = {
    is?: DecisionRecordWhereInput | null
    isNot?: DecisionRecordWhereInput | null
  }

  export type DecisionRecordListRelationFilter = {
    every?: DecisionRecordWhereInput
    some?: DecisionRecordWhereInput
    none?: DecisionRecordWhereInput
  }

  export type DecisionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DecisionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    context?: SortOrder
    decision?: SortOrder
    consequences?: SortOrder
    status?: SortOrder
    supersedesId?: SortOrder
    authorId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    implementedAt?: SortOrder
  }

  export type DecisionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    context?: SortOrder
    decision?: SortOrder
    consequences?: SortOrder
    status?: SortOrder
    supersedesId?: SortOrder
    authorId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    implementedAt?: SortOrder
  }

  export type DecisionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    context?: SortOrder
    decision?: SortOrder
    consequences?: SortOrder
    status?: SortOrder
    supersedesId?: SortOrder
    authorId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    implementedAt?: SortOrder
  }

  export type EnumDecisionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionStatus | EnumDecisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionStatus[] | ListEnumDecisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionStatus[] | ListEnumDecisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionStatusWithAggregatesFilter<$PrismaModel> | $Enums.DecisionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDecisionStatusFilter<$PrismaModel>
    _max?: NestedEnumDecisionStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type BusCreateNestedManyWithoutSchoolInput = {
    create?: XOR<BusCreateWithoutSchoolInput, BusUncheckedCreateWithoutSchoolInput> | BusCreateWithoutSchoolInput[] | BusUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BusCreateOrConnectWithoutSchoolInput | BusCreateOrConnectWithoutSchoolInput[]
    createMany?: BusCreateManySchoolInputEnvelope
    connect?: BusWhereUniqueInput | BusWhereUniqueInput[]
  }

  export type FinanceCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FinanceCreateWithoutSchoolInput, FinanceUncheckedCreateWithoutSchoolInput> | FinanceCreateWithoutSchoolInput[] | FinanceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FinanceCreateOrConnectWithoutSchoolInput | FinanceCreateOrConnectWithoutSchoolInput[]
    createMany?: FinanceCreateManySchoolInputEnvelope
    connect?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ActivityCreateWithoutSchoolInput, ActivityUncheckedCreateWithoutSchoolInput> | ActivityCreateWithoutSchoolInput[] | ActivityUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutSchoolInput | ActivityCreateOrConnectWithoutSchoolInput[]
    createMany?: ActivityCreateManySchoolInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ResourceCreateWithoutSchoolInput, ResourceUncheckedCreateWithoutSchoolInput> | ResourceCreateWithoutSchoolInput[] | ResourceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSchoolInput | ResourceCreateOrConnectWithoutSchoolInput[]
    createMany?: ResourceCreateManySchoolInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type BookCreateNestedManyWithoutSchoolInput = {
    create?: XOR<BookCreateWithoutSchoolInput, BookUncheckedCreateWithoutSchoolInput> | BookCreateWithoutSchoolInput[] | BookUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BookCreateOrConnectWithoutSchoolInput | BookCreateOrConnectWithoutSchoolInput[]
    createMany?: BookCreateManySchoolInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type ApplicationCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ApplicationCreateWithoutSchoolInput, ApplicationUncheckedCreateWithoutSchoolInput> | ApplicationCreateWithoutSchoolInput[] | ApplicationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutSchoolInput | ApplicationCreateOrConnectWithoutSchoolInput[]
    createMany?: ApplicationCreateManySchoolInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type StaffApplicationCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StaffApplicationCreateWithoutSchoolInput, StaffApplicationUncheckedCreateWithoutSchoolInput> | StaffApplicationCreateWithoutSchoolInput[] | StaffApplicationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutSchoolInput | StaffApplicationCreateOrConnectWithoutSchoolInput[]
    createMany?: StaffApplicationCreateManySchoolInputEnvelope
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type BusUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<BusCreateWithoutSchoolInput, BusUncheckedCreateWithoutSchoolInput> | BusCreateWithoutSchoolInput[] | BusUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BusCreateOrConnectWithoutSchoolInput | BusCreateOrConnectWithoutSchoolInput[]
    createMany?: BusCreateManySchoolInputEnvelope
    connect?: BusWhereUniqueInput | BusWhereUniqueInput[]
  }

  export type FinanceUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FinanceCreateWithoutSchoolInput, FinanceUncheckedCreateWithoutSchoolInput> | FinanceCreateWithoutSchoolInput[] | FinanceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FinanceCreateOrConnectWithoutSchoolInput | FinanceCreateOrConnectWithoutSchoolInput[]
    createMany?: FinanceCreateManySchoolInputEnvelope
    connect?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ActivityCreateWithoutSchoolInput, ActivityUncheckedCreateWithoutSchoolInput> | ActivityCreateWithoutSchoolInput[] | ActivityUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutSchoolInput | ActivityCreateOrConnectWithoutSchoolInput[]
    createMany?: ActivityCreateManySchoolInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ResourceCreateWithoutSchoolInput, ResourceUncheckedCreateWithoutSchoolInput> | ResourceCreateWithoutSchoolInput[] | ResourceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSchoolInput | ResourceCreateOrConnectWithoutSchoolInput[]
    createMany?: ResourceCreateManySchoolInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<BookCreateWithoutSchoolInput, BookUncheckedCreateWithoutSchoolInput> | BookCreateWithoutSchoolInput[] | BookUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BookCreateOrConnectWithoutSchoolInput | BookCreateOrConnectWithoutSchoolInput[]
    createMany?: BookCreateManySchoolInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ApplicationCreateWithoutSchoolInput, ApplicationUncheckedCreateWithoutSchoolInput> | ApplicationCreateWithoutSchoolInput[] | ApplicationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutSchoolInput | ApplicationCreateOrConnectWithoutSchoolInput[]
    createMany?: ApplicationCreateManySchoolInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StaffApplicationCreateWithoutSchoolInput, StaffApplicationUncheckedCreateWithoutSchoolInput> | StaffApplicationCreateWithoutSchoolInput[] | StaffApplicationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutSchoolInput | StaffApplicationCreateOrConnectWithoutSchoolInput[]
    createMany?: StaffApplicationCreateManySchoolInputEnvelope
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type BusUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<BusCreateWithoutSchoolInput, BusUncheckedCreateWithoutSchoolInput> | BusCreateWithoutSchoolInput[] | BusUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BusCreateOrConnectWithoutSchoolInput | BusCreateOrConnectWithoutSchoolInput[]
    upsert?: BusUpsertWithWhereUniqueWithoutSchoolInput | BusUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: BusCreateManySchoolInputEnvelope
    set?: BusWhereUniqueInput | BusWhereUniqueInput[]
    disconnect?: BusWhereUniqueInput | BusWhereUniqueInput[]
    delete?: BusWhereUniqueInput | BusWhereUniqueInput[]
    connect?: BusWhereUniqueInput | BusWhereUniqueInput[]
    update?: BusUpdateWithWhereUniqueWithoutSchoolInput | BusUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: BusUpdateManyWithWhereWithoutSchoolInput | BusUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: BusScalarWhereInput | BusScalarWhereInput[]
  }

  export type FinanceUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FinanceCreateWithoutSchoolInput, FinanceUncheckedCreateWithoutSchoolInput> | FinanceCreateWithoutSchoolInput[] | FinanceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FinanceCreateOrConnectWithoutSchoolInput | FinanceCreateOrConnectWithoutSchoolInput[]
    upsert?: FinanceUpsertWithWhereUniqueWithoutSchoolInput | FinanceUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FinanceCreateManySchoolInputEnvelope
    set?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
    disconnect?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
    delete?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
    connect?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
    update?: FinanceUpdateWithWhereUniqueWithoutSchoolInput | FinanceUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FinanceUpdateManyWithWhereWithoutSchoolInput | FinanceUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FinanceScalarWhereInput | FinanceScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ActivityCreateWithoutSchoolInput, ActivityUncheckedCreateWithoutSchoolInput> | ActivityCreateWithoutSchoolInput[] | ActivityUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutSchoolInput | ActivityCreateOrConnectWithoutSchoolInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutSchoolInput | ActivityUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ActivityCreateManySchoolInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutSchoolInput | ActivityUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutSchoolInput | ActivityUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ResourceCreateWithoutSchoolInput, ResourceUncheckedCreateWithoutSchoolInput> | ResourceCreateWithoutSchoolInput[] | ResourceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSchoolInput | ResourceCreateOrConnectWithoutSchoolInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutSchoolInput | ResourceUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ResourceCreateManySchoolInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutSchoolInput | ResourceUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutSchoolInput | ResourceUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type BookUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<BookCreateWithoutSchoolInput, BookUncheckedCreateWithoutSchoolInput> | BookCreateWithoutSchoolInput[] | BookUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BookCreateOrConnectWithoutSchoolInput | BookCreateOrConnectWithoutSchoolInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutSchoolInput | BookUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: BookCreateManySchoolInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutSchoolInput | BookUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: BookUpdateManyWithWhereWithoutSchoolInput | BookUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type ApplicationUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ApplicationCreateWithoutSchoolInput, ApplicationUncheckedCreateWithoutSchoolInput> | ApplicationCreateWithoutSchoolInput[] | ApplicationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutSchoolInput | ApplicationCreateOrConnectWithoutSchoolInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutSchoolInput | ApplicationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ApplicationCreateManySchoolInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutSchoolInput | ApplicationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutSchoolInput | ApplicationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StaffApplicationUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutSchoolInput, StaffApplicationUncheckedCreateWithoutSchoolInput> | StaffApplicationCreateWithoutSchoolInput[] | StaffApplicationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutSchoolInput | StaffApplicationCreateOrConnectWithoutSchoolInput[]
    upsert?: StaffApplicationUpsertWithWhereUniqueWithoutSchoolInput | StaffApplicationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StaffApplicationCreateManySchoolInputEnvelope
    set?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    disconnect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    delete?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    update?: StaffApplicationUpdateWithWhereUniqueWithoutSchoolInput | StaffApplicationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StaffApplicationUpdateManyWithWhereWithoutSchoolInput | StaffApplicationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StaffApplicationScalarWhereInput | StaffApplicationScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type BusUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<BusCreateWithoutSchoolInput, BusUncheckedCreateWithoutSchoolInput> | BusCreateWithoutSchoolInput[] | BusUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BusCreateOrConnectWithoutSchoolInput | BusCreateOrConnectWithoutSchoolInput[]
    upsert?: BusUpsertWithWhereUniqueWithoutSchoolInput | BusUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: BusCreateManySchoolInputEnvelope
    set?: BusWhereUniqueInput | BusWhereUniqueInput[]
    disconnect?: BusWhereUniqueInput | BusWhereUniqueInput[]
    delete?: BusWhereUniqueInput | BusWhereUniqueInput[]
    connect?: BusWhereUniqueInput | BusWhereUniqueInput[]
    update?: BusUpdateWithWhereUniqueWithoutSchoolInput | BusUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: BusUpdateManyWithWhereWithoutSchoolInput | BusUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: BusScalarWhereInput | BusScalarWhereInput[]
  }

  export type FinanceUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FinanceCreateWithoutSchoolInput, FinanceUncheckedCreateWithoutSchoolInput> | FinanceCreateWithoutSchoolInput[] | FinanceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FinanceCreateOrConnectWithoutSchoolInput | FinanceCreateOrConnectWithoutSchoolInput[]
    upsert?: FinanceUpsertWithWhereUniqueWithoutSchoolInput | FinanceUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FinanceCreateManySchoolInputEnvelope
    set?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
    disconnect?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
    delete?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
    connect?: FinanceWhereUniqueInput | FinanceWhereUniqueInput[]
    update?: FinanceUpdateWithWhereUniqueWithoutSchoolInput | FinanceUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FinanceUpdateManyWithWhereWithoutSchoolInput | FinanceUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FinanceScalarWhereInput | FinanceScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ActivityCreateWithoutSchoolInput, ActivityUncheckedCreateWithoutSchoolInput> | ActivityCreateWithoutSchoolInput[] | ActivityUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutSchoolInput | ActivityCreateOrConnectWithoutSchoolInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutSchoolInput | ActivityUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ActivityCreateManySchoolInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutSchoolInput | ActivityUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutSchoolInput | ActivityUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ResourceCreateWithoutSchoolInput, ResourceUncheckedCreateWithoutSchoolInput> | ResourceCreateWithoutSchoolInput[] | ResourceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSchoolInput | ResourceCreateOrConnectWithoutSchoolInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutSchoolInput | ResourceUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ResourceCreateManySchoolInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutSchoolInput | ResourceUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutSchoolInput | ResourceUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<BookCreateWithoutSchoolInput, BookUncheckedCreateWithoutSchoolInput> | BookCreateWithoutSchoolInput[] | BookUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BookCreateOrConnectWithoutSchoolInput | BookCreateOrConnectWithoutSchoolInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutSchoolInput | BookUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: BookCreateManySchoolInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutSchoolInput | BookUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: BookUpdateManyWithWhereWithoutSchoolInput | BookUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ApplicationCreateWithoutSchoolInput, ApplicationUncheckedCreateWithoutSchoolInput> | ApplicationCreateWithoutSchoolInput[] | ApplicationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutSchoolInput | ApplicationCreateOrConnectWithoutSchoolInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutSchoolInput | ApplicationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ApplicationCreateManySchoolInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutSchoolInput | ApplicationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutSchoolInput | ApplicationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutSchoolInput, StaffApplicationUncheckedCreateWithoutSchoolInput> | StaffApplicationCreateWithoutSchoolInput[] | StaffApplicationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutSchoolInput | StaffApplicationCreateOrConnectWithoutSchoolInput[]
    upsert?: StaffApplicationUpsertWithWhereUniqueWithoutSchoolInput | StaffApplicationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StaffApplicationCreateManySchoolInputEnvelope
    set?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    disconnect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    delete?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    update?: StaffApplicationUpdateWithWhereUniqueWithoutSchoolInput | StaffApplicationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StaffApplicationUpdateManyWithWhereWithoutSchoolInput | StaffApplicationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StaffApplicationScalarWhereInput | StaffApplicationScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    connect?: StaffWhereUniqueInput
  }

  export type LibraryStaffCreateNestedOneWithoutUserInput = {
    create?: XOR<LibraryStaffCreateWithoutUserInput, LibraryStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: LibraryStaffCreateOrConnectWithoutUserInput
    connect?: LibraryStaffWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput> | SubjectCreateWithoutCreatedByInput[] | SubjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCreatedByInput | SubjectCreateOrConnectWithoutCreatedByInput[]
    createMany?: SubjectCreateManyCreatedByInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ApplicationCreateNestedOneWithoutUserInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput
    connect?: ApplicationWhereUniqueInput
  }

  export type SkuunAiSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SkuunAiSessionCreateWithoutUserInput, SkuunAiSessionUncheckedCreateWithoutUserInput> | SkuunAiSessionCreateWithoutUserInput[] | SkuunAiSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutUserInput | SkuunAiSessionCreateOrConnectWithoutUserInput[]
    createMany?: SkuunAiSessionCreateManyUserInputEnvelope
    connect?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type StaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    connect?: StaffWhereUniqueInput
  }

  export type LibraryStaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LibraryStaffCreateWithoutUserInput, LibraryStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: LibraryStaffCreateOrConnectWithoutUserInput
    connect?: LibraryStaffWhereUniqueInput
  }

  export type SubjectUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput> | SubjectCreateWithoutCreatedByInput[] | SubjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCreatedByInput | SubjectCreateOrConnectWithoutCreatedByInput[]
    createMany?: SubjectCreateManyCreatedByInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput
    connect?: ApplicationWhereUniqueInput
  }

  export type SkuunAiSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SkuunAiSessionCreateWithoutUserInput, SkuunAiSessionUncheckedCreateWithoutUserInput> | SkuunAiSessionCreateWithoutUserInput[] | SkuunAiSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutUserInput | SkuunAiSessionCreateOrConnectWithoutUserInput[]
    createMany?: SkuunAiSessionCreateManyUserInputEnvelope
    connect?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type SchoolUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    upsert?: StaffUpsertWithoutUserInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutUserInput, StaffUpdateWithoutUserInput>, StaffUncheckedUpdateWithoutUserInput>
  }

  export type LibraryStaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<LibraryStaffCreateWithoutUserInput, LibraryStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: LibraryStaffCreateOrConnectWithoutUserInput
    upsert?: LibraryStaffUpsertWithoutUserInput
    disconnect?: LibraryStaffWhereInput | boolean
    delete?: LibraryStaffWhereInput | boolean
    connect?: LibraryStaffWhereUniqueInput
    update?: XOR<XOR<LibraryStaffUpdateToOneWithWhereWithoutUserInput, LibraryStaffUpdateWithoutUserInput>, LibraryStaffUncheckedUpdateWithoutUserInput>
  }

  export type SubjectUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput> | SubjectCreateWithoutCreatedByInput[] | SubjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCreatedByInput | SubjectCreateOrConnectWithoutCreatedByInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutCreatedByInput | SubjectUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SubjectCreateManyCreatedByInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutCreatedByInput | SubjectUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutCreatedByInput | SubjectUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ApplicationUpdateOneWithoutUserNestedInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput
    upsert?: ApplicationUpsertWithoutUserInput
    disconnect?: ApplicationWhereInput | boolean
    delete?: ApplicationWhereInput | boolean
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutUserInput, ApplicationUpdateWithoutUserInput>, ApplicationUncheckedUpdateWithoutUserInput>
  }

  export type SkuunAiSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SkuunAiSessionCreateWithoutUserInput, SkuunAiSessionUncheckedCreateWithoutUserInput> | SkuunAiSessionCreateWithoutUserInput[] | SkuunAiSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutUserInput | SkuunAiSessionCreateOrConnectWithoutUserInput[]
    upsert?: SkuunAiSessionUpsertWithWhereUniqueWithoutUserInput | SkuunAiSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SkuunAiSessionCreateManyUserInputEnvelope
    set?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
    disconnect?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
    delete?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
    connect?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
    update?: SkuunAiSessionUpdateWithWhereUniqueWithoutUserInput | SkuunAiSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SkuunAiSessionUpdateManyWithWhereWithoutUserInput | SkuunAiSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SkuunAiSessionScalarWhereInput | SkuunAiSessionScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    upsert?: StaffUpsertWithoutUserInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutUserInput, StaffUpdateWithoutUserInput>, StaffUncheckedUpdateWithoutUserInput>
  }

  export type LibraryStaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LibraryStaffCreateWithoutUserInput, LibraryStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: LibraryStaffCreateOrConnectWithoutUserInput
    upsert?: LibraryStaffUpsertWithoutUserInput
    disconnect?: LibraryStaffWhereInput | boolean
    delete?: LibraryStaffWhereInput | boolean
    connect?: LibraryStaffWhereUniqueInput
    update?: XOR<XOR<LibraryStaffUpdateToOneWithWhereWithoutUserInput, LibraryStaffUpdateWithoutUserInput>, LibraryStaffUncheckedUpdateWithoutUserInput>
  }

  export type SubjectUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput> | SubjectCreateWithoutCreatedByInput[] | SubjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCreatedByInput | SubjectCreateOrConnectWithoutCreatedByInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutCreatedByInput | SubjectUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SubjectCreateManyCreatedByInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutCreatedByInput | SubjectUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutCreatedByInput | SubjectUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput
    upsert?: ApplicationUpsertWithoutUserInput
    disconnect?: ApplicationWhereInput | boolean
    delete?: ApplicationWhereInput | boolean
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutUserInput, ApplicationUpdateWithoutUserInput>, ApplicationUncheckedUpdateWithoutUserInput>
  }

  export type SkuunAiSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SkuunAiSessionCreateWithoutUserInput, SkuunAiSessionUncheckedCreateWithoutUserInput> | SkuunAiSessionCreateWithoutUserInput[] | SkuunAiSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutUserInput | SkuunAiSessionCreateOrConnectWithoutUserInput[]
    upsert?: SkuunAiSessionUpsertWithWhereUniqueWithoutUserInput | SkuunAiSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SkuunAiSessionCreateManyUserInputEnvelope
    set?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
    disconnect?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
    delete?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
    connect?: SkuunAiSessionWhereUniqueInput | SkuunAiSessionWhereUniqueInput[]
    update?: SkuunAiSessionUpdateWithWhereUniqueWithoutUserInput | SkuunAiSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SkuunAiSessionUpdateManyWithWhereWithoutUserInput | SkuunAiSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SkuunAiSessionScalarWhereInput | SkuunAiSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutStudentInput = {
    create?: XOR<SchoolCreateWithoutStudentInput, SchoolUncheckedCreateWithoutStudentInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentInput
    connect?: SchoolWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutStudentsInput = {
    create?: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput> | SubjectCreateWithoutStudentsInput[] | SubjectUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStudentsInput | SubjectCreateOrConnectWithoutStudentsInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ApplicationCreateNestedOneWithoutStudentInput = {
    create?: XOR<ApplicationCreateWithoutStudentInput, ApplicationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutStudentInput
    connect?: ApplicationWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    connect?: ClassWhereUniqueInput
  }

  export type ExamCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamCreateWithoutStudentInput, ExamUncheckedCreateWithoutStudentInput> | ExamCreateWithoutStudentInput[] | ExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutStudentInput | ExamCreateOrConnectWithoutStudentInput[]
    createMany?: ExamCreateManyStudentInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type StudentAttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type ParentCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput> | ParentCreateWithoutStudentInput[] | ParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutStudentInput | ParentCreateOrConnectWithoutStudentInput[]
    createMany?: ParentCreateManyStudentInputEnvelope
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
  }

  export type BorrowCreateNestedManyWithoutStudentInput = {
    create?: XOR<BorrowCreateWithoutStudentInput, BorrowUncheckedCreateWithoutStudentInput> | BorrowCreateWithoutStudentInput[] | BorrowUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutStudentInput | BorrowCreateOrConnectWithoutStudentInput[]
    createMany?: BorrowCreateManyStudentInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutStudentInput = {
    create?: XOR<TransactionCreateWithoutStudentInput, TransactionUncheckedCreateWithoutStudentInput> | TransactionCreateWithoutStudentInput[] | TransactionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStudentInput | TransactionCreateOrConnectWithoutStudentInput[]
    createMany?: TransactionCreateManyStudentInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutStudentInput = {
    create?: XOR<PurchaseCreateWithoutStudentInput, PurchaseUncheckedCreateWithoutStudentInput> | PurchaseCreateWithoutStudentInput[] | PurchaseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStudentInput | PurchaseCreateOrConnectWithoutStudentInput[]
    createMany?: PurchaseCreateManyStudentInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type GradeCreateNestedOneWithoutStudentsInput = {
    create?: XOR<GradeCreateWithoutStudentsInput, GradeUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutStudentsInput
    connect?: GradeWhereUniqueInput
  }

  export type SubjectUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput> | SubjectCreateWithoutStudentsInput[] | SubjectUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStudentsInput | SubjectCreateOrConnectWithoutStudentsInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<ApplicationCreateWithoutStudentInput, ApplicationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutStudentInput
    connect?: ApplicationWhereUniqueInput
  }

  export type ExamUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamCreateWithoutStudentInput, ExamUncheckedCreateWithoutStudentInput> | ExamCreateWithoutStudentInput[] | ExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutStudentInput | ExamCreateOrConnectWithoutStudentInput[]
    createMany?: ExamCreateManyStudentInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type ParentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput> | ParentCreateWithoutStudentInput[] | ParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutStudentInput | ParentCreateOrConnectWithoutStudentInput[]
    createMany?: ParentCreateManyStudentInputEnvelope
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
  }

  export type BorrowUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<BorrowCreateWithoutStudentInput, BorrowUncheckedCreateWithoutStudentInput> | BorrowCreateWithoutStudentInput[] | BorrowUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutStudentInput | BorrowCreateOrConnectWithoutStudentInput[]
    createMany?: BorrowCreateManyStudentInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<TransactionCreateWithoutStudentInput, TransactionUncheckedCreateWithoutStudentInput> | TransactionCreateWithoutStudentInput[] | TransactionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStudentInput | TransactionCreateOrConnectWithoutStudentInput[]
    createMany?: TransactionCreateManyStudentInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PurchaseCreateWithoutStudentInput, PurchaseUncheckedCreateWithoutStudentInput> | PurchaseCreateWithoutStudentInput[] | PurchaseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStudentInput | PurchaseCreateOrConnectWithoutStudentInput[]
    createMany?: PurchaseCreateManyStudentInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type SchoolUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<SchoolCreateWithoutStudentInput, SchoolUncheckedCreateWithoutStudentInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentInput
    upsert?: SchoolUpsertWithoutStudentInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutStudentInput, SchoolUpdateWithoutStudentInput>, SchoolUncheckedUpdateWithoutStudentInput>
  }

  export type SubjectUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput> | SubjectCreateWithoutStudentsInput[] | SubjectUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStudentsInput | SubjectCreateOrConnectWithoutStudentsInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutStudentsInput | SubjectUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutStudentsInput | SubjectUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutStudentsInput | SubjectUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ApplicationUpdateOneWithoutStudentNestedInput = {
    create?: XOR<ApplicationCreateWithoutStudentInput, ApplicationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutStudentInput
    upsert?: ApplicationUpsertWithoutStudentInput
    disconnect?: ApplicationWhereInput | boolean
    delete?: ApplicationWhereInput | boolean
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutStudentInput, ApplicationUpdateWithoutStudentInput>, ApplicationUncheckedUpdateWithoutStudentInput>
  }

  export type ClassUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    upsert?: ClassUpsertWithoutStudentsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentsInput, ClassUpdateWithoutStudentsInput>, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ExamUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamCreateWithoutStudentInput, ExamUncheckedCreateWithoutStudentInput> | ExamCreateWithoutStudentInput[] | ExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutStudentInput | ExamCreateOrConnectWithoutStudentInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutStudentInput | ExamUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamCreateManyStudentInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutStudentInput | ExamUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutStudentInput | ExamUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type StudentAttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type ParentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput> | ParentCreateWithoutStudentInput[] | ParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutStudentInput | ParentCreateOrConnectWithoutStudentInput[]
    upsert?: ParentUpsertWithWhereUniqueWithoutStudentInput | ParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentCreateManyStudentInputEnvelope
    set?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    disconnect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    delete?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    update?: ParentUpdateWithWhereUniqueWithoutStudentInput | ParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentUpdateManyWithWhereWithoutStudentInput | ParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentScalarWhereInput | ParentScalarWhereInput[]
  }

  export type BorrowUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BorrowCreateWithoutStudentInput, BorrowUncheckedCreateWithoutStudentInput> | BorrowCreateWithoutStudentInput[] | BorrowUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutStudentInput | BorrowCreateOrConnectWithoutStudentInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutStudentInput | BorrowUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BorrowCreateManyStudentInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutStudentInput | BorrowUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutStudentInput | BorrowUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TransactionCreateWithoutStudentInput, TransactionUncheckedCreateWithoutStudentInput> | TransactionCreateWithoutStudentInput[] | TransactionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStudentInput | TransactionCreateOrConnectWithoutStudentInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutStudentInput | TransactionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TransactionCreateManyStudentInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutStudentInput | TransactionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutStudentInput | TransactionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PurchaseCreateWithoutStudentInput, PurchaseUncheckedCreateWithoutStudentInput> | PurchaseCreateWithoutStudentInput[] | PurchaseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStudentInput | PurchaseCreateOrConnectWithoutStudentInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStudentInput | PurchaseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PurchaseCreateManyStudentInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStudentInput | PurchaseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStudentInput | PurchaseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type GradeUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<GradeCreateWithoutStudentsInput, GradeUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutStudentsInput
    upsert?: GradeUpsertWithoutStudentsInput
    disconnect?: GradeWhereInput | boolean
    delete?: GradeWhereInput | boolean
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutStudentsInput, GradeUpdateWithoutStudentsInput>, GradeUncheckedUpdateWithoutStudentsInput>
  }

  export type SubjectUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput> | SubjectCreateWithoutStudentsInput[] | SubjectUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStudentsInput | SubjectCreateOrConnectWithoutStudentsInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutStudentsInput | SubjectUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutStudentsInput | SubjectUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutStudentsInput | SubjectUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<ApplicationCreateWithoutStudentInput, ApplicationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutStudentInput
    upsert?: ApplicationUpsertWithoutStudentInput
    disconnect?: ApplicationWhereInput | boolean
    delete?: ApplicationWhereInput | boolean
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutStudentInput, ApplicationUpdateWithoutStudentInput>, ApplicationUncheckedUpdateWithoutStudentInput>
  }

  export type ExamUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamCreateWithoutStudentInput, ExamUncheckedCreateWithoutStudentInput> | ExamCreateWithoutStudentInput[] | ExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutStudentInput | ExamCreateOrConnectWithoutStudentInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutStudentInput | ExamUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamCreateManyStudentInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutStudentInput | ExamUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutStudentInput | ExamUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type ParentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput> | ParentCreateWithoutStudentInput[] | ParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutStudentInput | ParentCreateOrConnectWithoutStudentInput[]
    upsert?: ParentUpsertWithWhereUniqueWithoutStudentInput | ParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentCreateManyStudentInputEnvelope
    set?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    disconnect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    delete?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    update?: ParentUpdateWithWhereUniqueWithoutStudentInput | ParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentUpdateManyWithWhereWithoutStudentInput | ParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentScalarWhereInput | ParentScalarWhereInput[]
  }

  export type BorrowUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BorrowCreateWithoutStudentInput, BorrowUncheckedCreateWithoutStudentInput> | BorrowCreateWithoutStudentInput[] | BorrowUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutStudentInput | BorrowCreateOrConnectWithoutStudentInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutStudentInput | BorrowUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BorrowCreateManyStudentInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutStudentInput | BorrowUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutStudentInput | BorrowUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TransactionCreateWithoutStudentInput, TransactionUncheckedCreateWithoutStudentInput> | TransactionCreateWithoutStudentInput[] | TransactionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStudentInput | TransactionCreateOrConnectWithoutStudentInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutStudentInput | TransactionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TransactionCreateManyStudentInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutStudentInput | TransactionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutStudentInput | TransactionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PurchaseCreateWithoutStudentInput, PurchaseUncheckedCreateWithoutStudentInput> | PurchaseCreateWithoutStudentInput[] | PurchaseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStudentInput | PurchaseCreateOrConnectWithoutStudentInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStudentInput | PurchaseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PurchaseCreateManyStudentInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStudentInput | PurchaseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStudentInput | PurchaseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutClassesInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    connect?: SchoolWhereUniqueInput
  }

  export type GradeCreateNestedManyWithoutClassInput = {
    create?: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput> | GradeCreateWithoutClassInput[] | GradeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutClassInput | GradeCreateOrConnectWithoutClassInput[]
    createMany?: GradeCreateManyClassInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StaffCreateNestedManyWithoutClassInput = {
    create?: XOR<StaffCreateWithoutClassInput, StaffUncheckedCreateWithoutClassInput> | StaffCreateWithoutClassInput[] | StaffUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutClassInput | StaffCreateOrConnectWithoutClassInput[]
    createMany?: StaffCreateManyClassInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutClassInput = {
    create?: XOR<ExamCreateWithoutClassInput, ExamUncheckedCreateWithoutClassInput> | ExamCreateWithoutClassInput[] | ExamUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutClassInput | ExamCreateOrConnectWithoutClassInput[]
    createMany?: ExamCreateManyClassInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutClassesInput = {
    create?: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput> | SubjectCreateWithoutClassesInput[] | SubjectUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassesInput | SubjectCreateOrConnectWithoutClassesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput> | GradeCreateWithoutClassInput[] | GradeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutClassInput | GradeCreateOrConnectWithoutClassInput[]
    createMany?: GradeCreateManyClassInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StaffCreateWithoutClassInput, StaffUncheckedCreateWithoutClassInput> | StaffCreateWithoutClassInput[] | StaffUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutClassInput | StaffCreateOrConnectWithoutClassInput[]
    createMany?: StaffCreateManyClassInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ExamCreateWithoutClassInput, ExamUncheckedCreateWithoutClassInput> | ExamCreateWithoutClassInput[] | ExamUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutClassInput | ExamCreateOrConnectWithoutClassInput[]
    createMany?: ExamCreateManyClassInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput> | SubjectCreateWithoutClassesInput[] | SubjectUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassesInput | SubjectCreateOrConnectWithoutClassesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    upsert?: SchoolUpsertWithoutClassesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassesInput, SchoolUpdateWithoutClassesInput>, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type GradeUpdateManyWithoutClassNestedInput = {
    create?: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput> | GradeCreateWithoutClassInput[] | GradeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutClassInput | GradeCreateOrConnectWithoutClassInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutClassInput | GradeUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: GradeCreateManyClassInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutClassInput | GradeUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutClassInput | GradeUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StaffUpdateManyWithoutClassNestedInput = {
    create?: XOR<StaffCreateWithoutClassInput, StaffUncheckedCreateWithoutClassInput> | StaffCreateWithoutClassInput[] | StaffUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutClassInput | StaffCreateOrConnectWithoutClassInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutClassInput | StaffUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StaffCreateManyClassInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutClassInput | StaffUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutClassInput | StaffUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutClassNestedInput = {
    create?: XOR<ExamCreateWithoutClassInput, ExamUncheckedCreateWithoutClassInput> | ExamCreateWithoutClassInput[] | ExamUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutClassInput | ExamCreateOrConnectWithoutClassInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutClassInput | ExamUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ExamCreateManyClassInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutClassInput | ExamUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutClassInput | ExamUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutClassesNestedInput = {
    create?: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput> | SubjectCreateWithoutClassesInput[] | SubjectUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassesInput | SubjectCreateOrConnectWithoutClassesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutClassesInput | SubjectUpsertWithWhereUniqueWithoutClassesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutClassesInput | SubjectUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutClassesInput | SubjectUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput> | GradeCreateWithoutClassInput[] | GradeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutClassInput | GradeCreateOrConnectWithoutClassInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutClassInput | GradeUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: GradeCreateManyClassInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutClassInput | GradeUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutClassInput | GradeUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StaffCreateWithoutClassInput, StaffUncheckedCreateWithoutClassInput> | StaffCreateWithoutClassInput[] | StaffUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutClassInput | StaffCreateOrConnectWithoutClassInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutClassInput | StaffUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StaffCreateManyClassInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutClassInput | StaffUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutClassInput | StaffUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ExamCreateWithoutClassInput, ExamUncheckedCreateWithoutClassInput> | ExamCreateWithoutClassInput[] | ExamUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutClassInput | ExamCreateOrConnectWithoutClassInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutClassInput | ExamUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ExamCreateManyClassInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutClassInput | ExamUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutClassInput | ExamUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput> | SubjectCreateWithoutClassesInput[] | SubjectUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassesInput | SubjectCreateOrConnectWithoutClassesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutClassesInput | SubjectUpsertWithWhereUniqueWithoutClassesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutClassesInput | SubjectUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutClassesInput | SubjectUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutGradesInput = {
    create?: XOR<ClassCreateWithoutGradesInput, ClassUncheckedCreateWithoutGradesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutGradesInput
    connect?: ClassWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutGradeInput = {
    create?: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput> | StudentCreateWithoutGradeInput[] | StudentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGradeInput | StudentCreateOrConnectWithoutGradeInput[]
    createMany?: StudentCreateManyGradeInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StaffCreateNestedManyWithoutGradesInput = {
    create?: XOR<StaffCreateWithoutGradesInput, StaffUncheckedCreateWithoutGradesInput> | StaffCreateWithoutGradesInput[] | StaffUncheckedCreateWithoutGradesInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutGradesInput | StaffCreateOrConnectWithoutGradesInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type ApplicationCreateNestedManyWithoutGradeInput = {
    create?: XOR<ApplicationCreateWithoutGradeInput, ApplicationUncheckedCreateWithoutGradeInput> | ApplicationCreateWithoutGradeInput[] | ApplicationUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutGradeInput | ApplicationCreateOrConnectWithoutGradeInput[]
    createMany?: ApplicationCreateManyGradeInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput> | StudentCreateWithoutGradeInput[] | StudentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGradeInput | StudentCreateOrConnectWithoutGradeInput[]
    createMany?: StudentCreateManyGradeInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutGradesInput = {
    create?: XOR<StaffCreateWithoutGradesInput, StaffUncheckedCreateWithoutGradesInput> | StaffCreateWithoutGradesInput[] | StaffUncheckedCreateWithoutGradesInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutGradesInput | StaffCreateOrConnectWithoutGradesInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<ApplicationCreateWithoutGradeInput, ApplicationUncheckedCreateWithoutGradeInput> | ApplicationCreateWithoutGradeInput[] | ApplicationUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutGradeInput | ApplicationCreateOrConnectWithoutGradeInput[]
    createMany?: ApplicationCreateManyGradeInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type ClassUpdateOneWithoutGradesNestedInput = {
    create?: XOR<ClassCreateWithoutGradesInput, ClassUncheckedCreateWithoutGradesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutGradesInput
    upsert?: ClassUpsertWithoutGradesInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutGradesInput, ClassUpdateWithoutGradesInput>, ClassUncheckedUpdateWithoutGradesInput>
  }

  export type StudentUpdateManyWithoutGradeNestedInput = {
    create?: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput> | StudentCreateWithoutGradeInput[] | StudentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGradeInput | StudentCreateOrConnectWithoutGradeInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutGradeInput | StudentUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: StudentCreateManyGradeInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutGradeInput | StudentUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutGradeInput | StudentUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StaffUpdateManyWithoutGradesNestedInput = {
    create?: XOR<StaffCreateWithoutGradesInput, StaffUncheckedCreateWithoutGradesInput> | StaffCreateWithoutGradesInput[] | StaffUncheckedCreateWithoutGradesInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutGradesInput | StaffCreateOrConnectWithoutGradesInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutGradesInput | StaffUpsertWithWhereUniqueWithoutGradesInput[]
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutGradesInput | StaffUpdateWithWhereUniqueWithoutGradesInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutGradesInput | StaffUpdateManyWithWhereWithoutGradesInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type ApplicationUpdateManyWithoutGradeNestedInput = {
    create?: XOR<ApplicationCreateWithoutGradeInput, ApplicationUncheckedCreateWithoutGradeInput> | ApplicationCreateWithoutGradeInput[] | ApplicationUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutGradeInput | ApplicationCreateOrConnectWithoutGradeInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutGradeInput | ApplicationUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: ApplicationCreateManyGradeInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutGradeInput | ApplicationUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutGradeInput | ApplicationUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput> | StudentCreateWithoutGradeInput[] | StudentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGradeInput | StudentCreateOrConnectWithoutGradeInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutGradeInput | StudentUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: StudentCreateManyGradeInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutGradeInput | StudentUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutGradeInput | StudentUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutGradesNestedInput = {
    create?: XOR<StaffCreateWithoutGradesInput, StaffUncheckedCreateWithoutGradesInput> | StaffCreateWithoutGradesInput[] | StaffUncheckedCreateWithoutGradesInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutGradesInput | StaffCreateOrConnectWithoutGradesInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutGradesInput | StaffUpsertWithWhereUniqueWithoutGradesInput[]
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutGradesInput | StaffUpdateWithWhereUniqueWithoutGradesInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutGradesInput | StaffUpdateManyWithWhereWithoutGradesInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<ApplicationCreateWithoutGradeInput, ApplicationUncheckedCreateWithoutGradeInput> | ApplicationCreateWithoutGradeInput[] | ApplicationUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutGradeInput | ApplicationCreateOrConnectWithoutGradeInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutGradeInput | ApplicationUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: ApplicationCreateManyGradeInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutGradeInput | ApplicationUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutGradeInput | ApplicationUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedSubjectsInput = {
    create?: XOR<UserCreateWithoutCreatedSubjectsInput, UserUncheckedCreateWithoutCreatedSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSubjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ExamCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type StaffCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<StaffCreateWithoutSubjectsInput, StaffUncheckedCreateWithoutSubjectsInput> | StaffCreateWithoutSubjectsInput[] | StaffUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSubjectsInput | StaffCreateOrConnectWithoutSubjectsInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput> | StudentCreateWithoutSubjectsInput[] | StudentUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSubjectsInput | StudentCreateOrConnectWithoutSubjectsInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput> | ClassCreateWithoutSubjectsInput[] | ClassUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput | ClassCreateOrConnectWithoutSubjectsInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type StaffApplicationCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<StaffApplicationCreateWithoutSubjectsInput, StaffApplicationUncheckedCreateWithoutSubjectsInput> | StaffApplicationCreateWithoutSubjectsInput[] | StaffApplicationUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutSubjectsInput | StaffApplicationCreateOrConnectWithoutSubjectsInput[]
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<StaffCreateWithoutSubjectsInput, StaffUncheckedCreateWithoutSubjectsInput> | StaffCreateWithoutSubjectsInput[] | StaffUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSubjectsInput | StaffCreateOrConnectWithoutSubjectsInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput> | StudentCreateWithoutSubjectsInput[] | StudentUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSubjectsInput | StudentCreateOrConnectWithoutSubjectsInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput> | ClassCreateWithoutSubjectsInput[] | ClassUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput | ClassCreateOrConnectWithoutSubjectsInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type StaffApplicationUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<StaffApplicationCreateWithoutSubjectsInput, StaffApplicationUncheckedCreateWithoutSubjectsInput> | StaffApplicationCreateWithoutSubjectsInput[] | StaffApplicationUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutSubjectsInput | StaffApplicationCreateOrConnectWithoutSubjectsInput[]
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedSubjectsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSubjectsInput, UserUncheckedCreateWithoutCreatedSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSubjectsInput
    upsert?: UserUpsertWithoutCreatedSubjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSubjectsInput, UserUpdateWithoutCreatedSubjectsInput>, UserUncheckedUpdateWithoutCreatedSubjectsInput>
  }

  export type ExamUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSubjectInput | ExamUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSubjectInput | ExamUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSubjectInput | ExamUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type StaffUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<StaffCreateWithoutSubjectsInput, StaffUncheckedCreateWithoutSubjectsInput> | StaffCreateWithoutSubjectsInput[] | StaffUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSubjectsInput | StaffCreateOrConnectWithoutSubjectsInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutSubjectsInput | StaffUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutSubjectsInput | StaffUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutSubjectsInput | StaffUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput> | StudentCreateWithoutSubjectsInput[] | StudentUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSubjectsInput | StudentCreateOrConnectWithoutSubjectsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSubjectsInput | StudentUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSubjectsInput | StudentUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSubjectsInput | StudentUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput> | ClassCreateWithoutSubjectsInput[] | ClassUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput | ClassCreateOrConnectWithoutSubjectsInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSubjectsInput | ClassUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSubjectsInput | ClassUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSubjectsInput | ClassUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type StaffApplicationUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutSubjectsInput, StaffApplicationUncheckedCreateWithoutSubjectsInput> | StaffApplicationCreateWithoutSubjectsInput[] | StaffApplicationUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutSubjectsInput | StaffApplicationCreateOrConnectWithoutSubjectsInput[]
    upsert?: StaffApplicationUpsertWithWhereUniqueWithoutSubjectsInput | StaffApplicationUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    disconnect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    delete?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    update?: StaffApplicationUpdateWithWhereUniqueWithoutSubjectsInput | StaffApplicationUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: StaffApplicationUpdateManyWithWhereWithoutSubjectsInput | StaffApplicationUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: StaffApplicationScalarWhereInput | StaffApplicationScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSubjectInput | ExamUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSubjectInput | ExamUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSubjectInput | ExamUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<StaffCreateWithoutSubjectsInput, StaffUncheckedCreateWithoutSubjectsInput> | StaffCreateWithoutSubjectsInput[] | StaffUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSubjectsInput | StaffCreateOrConnectWithoutSubjectsInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutSubjectsInput | StaffUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutSubjectsInput | StaffUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutSubjectsInput | StaffUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput> | StudentCreateWithoutSubjectsInput[] | StudentUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSubjectsInput | StudentCreateOrConnectWithoutSubjectsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSubjectsInput | StudentUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSubjectsInput | StudentUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSubjectsInput | StudentUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput> | ClassCreateWithoutSubjectsInput[] | ClassUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput | ClassCreateOrConnectWithoutSubjectsInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSubjectsInput | ClassUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSubjectsInput | ClassUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSubjectsInput | ClassUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type StaffApplicationUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutSubjectsInput, StaffApplicationUncheckedCreateWithoutSubjectsInput> | StaffApplicationCreateWithoutSubjectsInput[] | StaffApplicationUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutSubjectsInput | StaffApplicationCreateOrConnectWithoutSubjectsInput[]
    upsert?: StaffApplicationUpsertWithWhereUniqueWithoutSubjectsInput | StaffApplicationUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    disconnect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    delete?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    update?: StaffApplicationUpdateWithWhereUniqueWithoutSubjectsInput | StaffApplicationUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: StaffApplicationUpdateManyWithWhereWithoutSubjectsInput | StaffApplicationUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: StaffApplicationScalarWhereInput | StaffApplicationScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutExamInput = {
    create?: XOR<StudentCreateWithoutExamInput, StudentUncheckedCreateWithoutExamInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamInput
    connect?: StudentWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutExamsInput = {
    create?: XOR<ClassCreateWithoutExamsInput, ClassUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutExamsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutExamsInput = {
    create?: XOR<SubjectCreateWithoutExamsInput, SubjectUncheckedCreateWithoutExamsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutExamsInput
    connect?: SubjectWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneWithoutExamNestedInput = {
    create?: XOR<StudentCreateWithoutExamInput, StudentUncheckedCreateWithoutExamInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamInput
    upsert?: StudentUpsertWithoutExamInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutExamInput, StudentUpdateWithoutExamInput>, StudentUncheckedUpdateWithoutExamInput>
  }

  export type ClassUpdateOneWithoutExamsNestedInput = {
    create?: XOR<ClassCreateWithoutExamsInput, ClassUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutExamsInput
    upsert?: ClassUpsertWithoutExamsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutExamsInput, ClassUpdateWithoutExamsInput>, ClassUncheckedUpdateWithoutExamsInput>
  }

  export type SubjectUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<SubjectCreateWithoutExamsInput, SubjectUncheckedCreateWithoutExamsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutExamsInput
    upsert?: SubjectUpsertWithoutExamsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutExamsInput, SubjectUpdateWithoutExamsInput>, SubjectUncheckedUpdateWithoutExamsInput>
  }

  export type ApplicationCreatelanguagesInput = {
    set: string[]
  }

  export type StudentCreateNestedOneWithoutApplicationInput = {
    create?: XOR<StudentCreateWithoutApplicationInput, StudentUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutApplicationInput
    connect?: StudentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApplicationInput = {
    create?: XOR<UserCreateWithoutApplicationInput, UserUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<SchoolCreateWithoutApplicationsInput, SchoolUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutApplicationsInput
    connect?: SchoolWhereUniqueInput
  }

  export type AdmissionPaymentCreateNestedOneWithoutApplicationInput = {
    create?: XOR<AdmissionPaymentCreateWithoutApplicationInput, AdmissionPaymentUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: AdmissionPaymentCreateOrConnectWithoutApplicationInput
    connect?: AdmissionPaymentWhereUniqueInput
  }

  export type PreviousSchoolCreateNestedManyWithoutApplicationInput = {
    create?: XOR<PreviousSchoolCreateWithoutApplicationInput, PreviousSchoolUncheckedCreateWithoutApplicationInput> | PreviousSchoolCreateWithoutApplicationInput[] | PreviousSchoolUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: PreviousSchoolCreateOrConnectWithoutApplicationInput | PreviousSchoolCreateOrConnectWithoutApplicationInput[]
    createMany?: PreviousSchoolCreateManyApplicationInputEnvelope
    connect?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
  }

  export type FamilyMemberCreateNestedManyWithoutApplicationInput = {
    create?: XOR<FamilyMemberCreateWithoutApplicationInput, FamilyMemberUncheckedCreateWithoutApplicationInput> | FamilyMemberCreateWithoutApplicationInput[] | FamilyMemberUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutApplicationInput | FamilyMemberCreateOrConnectWithoutApplicationInput[]
    createMany?: FamilyMemberCreateManyApplicationInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type GradeCreateNestedOneWithoutApplicationInput = {
    create?: XOR<GradeCreateWithoutApplicationInput, GradeUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: GradeCreateOrConnectWithoutApplicationInput
    connect?: GradeWhereUniqueInput
  }

  export type PreviousSchoolUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<PreviousSchoolCreateWithoutApplicationInput, PreviousSchoolUncheckedCreateWithoutApplicationInput> | PreviousSchoolCreateWithoutApplicationInput[] | PreviousSchoolUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: PreviousSchoolCreateOrConnectWithoutApplicationInput | PreviousSchoolCreateOrConnectWithoutApplicationInput[]
    createMany?: PreviousSchoolCreateManyApplicationInputEnvelope
    connect?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
  }

  export type FamilyMemberUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<FamilyMemberCreateWithoutApplicationInput, FamilyMemberUncheckedCreateWithoutApplicationInput> | FamilyMemberCreateWithoutApplicationInput[] | FamilyMemberUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutApplicationInput | FamilyMemberCreateOrConnectWithoutApplicationInput[]
    createMany?: FamilyMemberCreateManyApplicationInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ApplicationUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<StudentCreateWithoutApplicationInput, StudentUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutApplicationInput
    upsert?: StudentUpsertWithoutApplicationInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutApplicationInput, StudentUpdateWithoutApplicationInput>, StudentUncheckedUpdateWithoutApplicationInput>
  }

  export type UserUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<UserCreateWithoutApplicationInput, UserUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationInput
    upsert?: UserUpsertWithoutApplicationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicationInput, UserUpdateWithoutApplicationInput>, UserUncheckedUpdateWithoutApplicationInput>
  }

  export type SchoolUpdateOneWithoutApplicationsNestedInput = {
    create?: XOR<SchoolCreateWithoutApplicationsInput, SchoolUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutApplicationsInput
    upsert?: SchoolUpsertWithoutApplicationsInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutApplicationsInput, SchoolUpdateWithoutApplicationsInput>, SchoolUncheckedUpdateWithoutApplicationsInput>
  }

  export type AdmissionPaymentUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<AdmissionPaymentCreateWithoutApplicationInput, AdmissionPaymentUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: AdmissionPaymentCreateOrConnectWithoutApplicationInput
    upsert?: AdmissionPaymentUpsertWithoutApplicationInput
    disconnect?: AdmissionPaymentWhereInput | boolean
    delete?: AdmissionPaymentWhereInput | boolean
    connect?: AdmissionPaymentWhereUniqueInput
    update?: XOR<XOR<AdmissionPaymentUpdateToOneWithWhereWithoutApplicationInput, AdmissionPaymentUpdateWithoutApplicationInput>, AdmissionPaymentUncheckedUpdateWithoutApplicationInput>
  }

  export type PreviousSchoolUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<PreviousSchoolCreateWithoutApplicationInput, PreviousSchoolUncheckedCreateWithoutApplicationInput> | PreviousSchoolCreateWithoutApplicationInput[] | PreviousSchoolUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: PreviousSchoolCreateOrConnectWithoutApplicationInput | PreviousSchoolCreateOrConnectWithoutApplicationInput[]
    upsert?: PreviousSchoolUpsertWithWhereUniqueWithoutApplicationInput | PreviousSchoolUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: PreviousSchoolCreateManyApplicationInputEnvelope
    set?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
    disconnect?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
    delete?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
    connect?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
    update?: PreviousSchoolUpdateWithWhereUniqueWithoutApplicationInput | PreviousSchoolUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: PreviousSchoolUpdateManyWithWhereWithoutApplicationInput | PreviousSchoolUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: PreviousSchoolScalarWhereInput | PreviousSchoolScalarWhereInput[]
  }

  export type FamilyMemberUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutApplicationInput, FamilyMemberUncheckedCreateWithoutApplicationInput> | FamilyMemberCreateWithoutApplicationInput[] | FamilyMemberUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutApplicationInput | FamilyMemberCreateOrConnectWithoutApplicationInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutApplicationInput | FamilyMemberUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: FamilyMemberCreateManyApplicationInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutApplicationInput | FamilyMemberUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutApplicationInput | FamilyMemberUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type GradeUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<GradeCreateWithoutApplicationInput, GradeUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: GradeCreateOrConnectWithoutApplicationInput
    upsert?: GradeUpsertWithoutApplicationInput
    disconnect?: GradeWhereInput | boolean
    delete?: GradeWhereInput | boolean
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutApplicationInput, GradeUpdateWithoutApplicationInput>, GradeUncheckedUpdateWithoutApplicationInput>
  }

  export type PreviousSchoolUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<PreviousSchoolCreateWithoutApplicationInput, PreviousSchoolUncheckedCreateWithoutApplicationInput> | PreviousSchoolCreateWithoutApplicationInput[] | PreviousSchoolUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: PreviousSchoolCreateOrConnectWithoutApplicationInput | PreviousSchoolCreateOrConnectWithoutApplicationInput[]
    upsert?: PreviousSchoolUpsertWithWhereUniqueWithoutApplicationInput | PreviousSchoolUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: PreviousSchoolCreateManyApplicationInputEnvelope
    set?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
    disconnect?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
    delete?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
    connect?: PreviousSchoolWhereUniqueInput | PreviousSchoolWhereUniqueInput[]
    update?: PreviousSchoolUpdateWithWhereUniqueWithoutApplicationInput | PreviousSchoolUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: PreviousSchoolUpdateManyWithWhereWithoutApplicationInput | PreviousSchoolUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: PreviousSchoolScalarWhereInput | PreviousSchoolScalarWhereInput[]
  }

  export type FamilyMemberUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutApplicationInput, FamilyMemberUncheckedCreateWithoutApplicationInput> | FamilyMemberCreateWithoutApplicationInput[] | FamilyMemberUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutApplicationInput | FamilyMemberCreateOrConnectWithoutApplicationInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutApplicationInput | FamilyMemberUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: FamilyMemberCreateManyApplicationInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutApplicationInput | FamilyMemberUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutApplicationInput | FamilyMemberUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type ApplicationCreateNestedOneWithoutPreviousSchoolsInput = {
    create?: XOR<ApplicationCreateWithoutPreviousSchoolsInput, ApplicationUncheckedCreateWithoutPreviousSchoolsInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutPreviousSchoolsInput
    connect?: ApplicationWhereUniqueInput
  }

  export type ApplicationUpdateOneRequiredWithoutPreviousSchoolsNestedInput = {
    create?: XOR<ApplicationCreateWithoutPreviousSchoolsInput, ApplicationUncheckedCreateWithoutPreviousSchoolsInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutPreviousSchoolsInput
    upsert?: ApplicationUpsertWithoutPreviousSchoolsInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutPreviousSchoolsInput, ApplicationUpdateWithoutPreviousSchoolsInput>, ApplicationUncheckedUpdateWithoutPreviousSchoolsInput>
  }

  export type ApplicationCreateNestedOneWithoutFamilyMembersInput = {
    create?: XOR<ApplicationCreateWithoutFamilyMembersInput, ApplicationUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutFamilyMembersInput
    connect?: ApplicationWhereUniqueInput
  }

  export type ApplicationUpdateOneRequiredWithoutFamilyMembersNestedInput = {
    create?: XOR<ApplicationCreateWithoutFamilyMembersInput, ApplicationUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutFamilyMembersInput
    upsert?: ApplicationUpsertWithoutFamilyMembersInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutFamilyMembersInput, ApplicationUpdateWithoutFamilyMembersInput>, ApplicationUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type StaffApplicationCreatelanguagesInput = {
    set: string[]
  }

  export type StaffCreateNestedOneWithoutStaffApplicationInput = {
    create?: XOR<StaffCreateWithoutStaffApplicationInput, StaffUncheckedCreateWithoutStaffApplicationInput>
    connectOrCreate?: StaffCreateOrConnectWithoutStaffApplicationInput
    connect?: StaffWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutStaffApplicationInput = {
    create?: XOR<SchoolCreateWithoutStaffApplicationInput, SchoolUncheckedCreateWithoutStaffApplicationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStaffApplicationInput
    connect?: SchoolWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutStaffApplicationInput = {
    create?: XOR<DepartmentCreateWithoutStaffApplicationInput, DepartmentUncheckedCreateWithoutStaffApplicationInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffApplicationInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutStaffApplicationsInput = {
    create?: XOR<SubjectCreateWithoutStaffApplicationsInput, SubjectUncheckedCreateWithoutStaffApplicationsInput> | SubjectCreateWithoutStaffApplicationsInput[] | SubjectUncheckedCreateWithoutStaffApplicationsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStaffApplicationsInput | SubjectCreateOrConnectWithoutStaffApplicationsInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type PreviousJobCreateNestedManyWithoutStaffApplicationInput = {
    create?: XOR<PreviousJobCreateWithoutStaffApplicationInput, PreviousJobUncheckedCreateWithoutStaffApplicationInput> | PreviousJobCreateWithoutStaffApplicationInput[] | PreviousJobUncheckedCreateWithoutStaffApplicationInput[]
    connectOrCreate?: PreviousJobCreateOrConnectWithoutStaffApplicationInput | PreviousJobCreateOrConnectWithoutStaffApplicationInput[]
    createMany?: PreviousJobCreateManyStaffApplicationInputEnvelope
    connect?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutStaffApplicationsInput = {
    create?: XOR<SubjectCreateWithoutStaffApplicationsInput, SubjectUncheckedCreateWithoutStaffApplicationsInput> | SubjectCreateWithoutStaffApplicationsInput[] | SubjectUncheckedCreateWithoutStaffApplicationsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStaffApplicationsInput | SubjectCreateOrConnectWithoutStaffApplicationsInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type PreviousJobUncheckedCreateNestedManyWithoutStaffApplicationInput = {
    create?: XOR<PreviousJobCreateWithoutStaffApplicationInput, PreviousJobUncheckedCreateWithoutStaffApplicationInput> | PreviousJobCreateWithoutStaffApplicationInput[] | PreviousJobUncheckedCreateWithoutStaffApplicationInput[]
    connectOrCreate?: PreviousJobCreateOrConnectWithoutStaffApplicationInput | PreviousJobCreateOrConnectWithoutStaffApplicationInput[]
    createMany?: PreviousJobCreateManyStaffApplicationInputEnvelope
    connect?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
  }

  export type StaffApplicationUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StaffUpdateOneWithoutStaffApplicationNestedInput = {
    create?: XOR<StaffCreateWithoutStaffApplicationInput, StaffUncheckedCreateWithoutStaffApplicationInput>
    connectOrCreate?: StaffCreateOrConnectWithoutStaffApplicationInput
    upsert?: StaffUpsertWithoutStaffApplicationInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutStaffApplicationInput, StaffUpdateWithoutStaffApplicationInput>, StaffUncheckedUpdateWithoutStaffApplicationInput>
  }

  export type SchoolUpdateOneRequiredWithoutStaffApplicationNestedInput = {
    create?: XOR<SchoolCreateWithoutStaffApplicationInput, SchoolUncheckedCreateWithoutStaffApplicationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStaffApplicationInput
    upsert?: SchoolUpsertWithoutStaffApplicationInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutStaffApplicationInput, SchoolUpdateWithoutStaffApplicationInput>, SchoolUncheckedUpdateWithoutStaffApplicationInput>
  }

  export type DepartmentUpdateOneWithoutStaffApplicationNestedInput = {
    create?: XOR<DepartmentCreateWithoutStaffApplicationInput, DepartmentUncheckedCreateWithoutStaffApplicationInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffApplicationInput
    upsert?: DepartmentUpsertWithoutStaffApplicationInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutStaffApplicationInput, DepartmentUpdateWithoutStaffApplicationInput>, DepartmentUncheckedUpdateWithoutStaffApplicationInput>
  }

  export type SubjectUpdateManyWithoutStaffApplicationsNestedInput = {
    create?: XOR<SubjectCreateWithoutStaffApplicationsInput, SubjectUncheckedCreateWithoutStaffApplicationsInput> | SubjectCreateWithoutStaffApplicationsInput[] | SubjectUncheckedCreateWithoutStaffApplicationsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStaffApplicationsInput | SubjectCreateOrConnectWithoutStaffApplicationsInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutStaffApplicationsInput | SubjectUpsertWithWhereUniqueWithoutStaffApplicationsInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutStaffApplicationsInput | SubjectUpdateWithWhereUniqueWithoutStaffApplicationsInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutStaffApplicationsInput | SubjectUpdateManyWithWhereWithoutStaffApplicationsInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type PreviousJobUpdateManyWithoutStaffApplicationNestedInput = {
    create?: XOR<PreviousJobCreateWithoutStaffApplicationInput, PreviousJobUncheckedCreateWithoutStaffApplicationInput> | PreviousJobCreateWithoutStaffApplicationInput[] | PreviousJobUncheckedCreateWithoutStaffApplicationInput[]
    connectOrCreate?: PreviousJobCreateOrConnectWithoutStaffApplicationInput | PreviousJobCreateOrConnectWithoutStaffApplicationInput[]
    upsert?: PreviousJobUpsertWithWhereUniqueWithoutStaffApplicationInput | PreviousJobUpsertWithWhereUniqueWithoutStaffApplicationInput[]
    createMany?: PreviousJobCreateManyStaffApplicationInputEnvelope
    set?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
    disconnect?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
    delete?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
    connect?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
    update?: PreviousJobUpdateWithWhereUniqueWithoutStaffApplicationInput | PreviousJobUpdateWithWhereUniqueWithoutStaffApplicationInput[]
    updateMany?: PreviousJobUpdateManyWithWhereWithoutStaffApplicationInput | PreviousJobUpdateManyWithWhereWithoutStaffApplicationInput[]
    deleteMany?: PreviousJobScalarWhereInput | PreviousJobScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutStaffApplicationsNestedInput = {
    create?: XOR<SubjectCreateWithoutStaffApplicationsInput, SubjectUncheckedCreateWithoutStaffApplicationsInput> | SubjectCreateWithoutStaffApplicationsInput[] | SubjectUncheckedCreateWithoutStaffApplicationsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStaffApplicationsInput | SubjectCreateOrConnectWithoutStaffApplicationsInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutStaffApplicationsInput | SubjectUpsertWithWhereUniqueWithoutStaffApplicationsInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutStaffApplicationsInput | SubjectUpdateWithWhereUniqueWithoutStaffApplicationsInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutStaffApplicationsInput | SubjectUpdateManyWithWhereWithoutStaffApplicationsInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type PreviousJobUncheckedUpdateManyWithoutStaffApplicationNestedInput = {
    create?: XOR<PreviousJobCreateWithoutStaffApplicationInput, PreviousJobUncheckedCreateWithoutStaffApplicationInput> | PreviousJobCreateWithoutStaffApplicationInput[] | PreviousJobUncheckedCreateWithoutStaffApplicationInput[]
    connectOrCreate?: PreviousJobCreateOrConnectWithoutStaffApplicationInput | PreviousJobCreateOrConnectWithoutStaffApplicationInput[]
    upsert?: PreviousJobUpsertWithWhereUniqueWithoutStaffApplicationInput | PreviousJobUpsertWithWhereUniqueWithoutStaffApplicationInput[]
    createMany?: PreviousJobCreateManyStaffApplicationInputEnvelope
    set?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
    disconnect?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
    delete?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
    connect?: PreviousJobWhereUniqueInput | PreviousJobWhereUniqueInput[]
    update?: PreviousJobUpdateWithWhereUniqueWithoutStaffApplicationInput | PreviousJobUpdateWithWhereUniqueWithoutStaffApplicationInput[]
    updateMany?: PreviousJobUpdateManyWithWhereWithoutStaffApplicationInput | PreviousJobUpdateManyWithWhereWithoutStaffApplicationInput[]
    deleteMany?: PreviousJobScalarWhereInput | PreviousJobScalarWhereInput[]
  }

  export type StaffApplicationCreateNestedOneWithoutPreviousJobsInput = {
    create?: XOR<StaffApplicationCreateWithoutPreviousJobsInput, StaffApplicationUncheckedCreateWithoutPreviousJobsInput>
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutPreviousJobsInput
    connect?: StaffApplicationWhereUniqueInput
  }

  export type StaffApplicationUpdateOneRequiredWithoutPreviousJobsNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutPreviousJobsInput, StaffApplicationUncheckedCreateWithoutPreviousJobsInput>
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutPreviousJobsInput
    upsert?: StaffApplicationUpsertWithoutPreviousJobsInput
    connect?: StaffApplicationWhereUniqueInput
    update?: XOR<XOR<StaffApplicationUpdateToOneWithWhereWithoutPreviousJobsInput, StaffApplicationUpdateWithoutPreviousJobsInput>, StaffApplicationUncheckedUpdateWithoutPreviousJobsInput>
  }

  export type UserCreateNestedOneWithoutStaffInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStaffInput = {
    create?: XOR<ClassCreateWithoutStaffInput, ClassUncheckedCreateWithoutStaffInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStaffInput
    connect?: ClassWhereUniqueInput
  }

  export type GradeCreateNestedManyWithoutStaffInput = {
    create?: XOR<GradeCreateWithoutStaffInput, GradeUncheckedCreateWithoutStaffInput> | GradeCreateWithoutStaffInput[] | GradeUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStaffInput | GradeCreateOrConnectWithoutStaffInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutStaffInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutStaffInput = {
    create?: XOR<SubjectCreateWithoutStaffInput, SubjectUncheckedCreateWithoutStaffInput> | SubjectCreateWithoutStaffInput[] | SubjectUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStaffInput | SubjectCreateOrConnectWithoutStaffInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type StaffAttendanceCreateNestedManyWithoutStaffInput = {
    create?: XOR<StaffAttendanceCreateWithoutStaffInput, StaffAttendanceUncheckedCreateWithoutStaffInput> | StaffAttendanceCreateWithoutStaffInput[] | StaffAttendanceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutStaffInput | StaffAttendanceCreateOrConnectWithoutStaffInput[]
    createMany?: StaffAttendanceCreateManyStaffInputEnvelope
    connect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
  }

  export type StaffApplicationCreateNestedOneWithoutStaffInput = {
    create?: XOR<StaffApplicationCreateWithoutStaffInput, StaffApplicationUncheckedCreateWithoutStaffInput>
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutStaffInput
    connect?: StaffApplicationWhereUniqueInput
  }

  export type GradeUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<GradeCreateWithoutStaffInput, GradeUncheckedCreateWithoutStaffInput> | GradeCreateWithoutStaffInput[] | GradeUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStaffInput | GradeCreateOrConnectWithoutStaffInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<SubjectCreateWithoutStaffInput, SubjectUncheckedCreateWithoutStaffInput> | SubjectCreateWithoutStaffInput[] | SubjectUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStaffInput | SubjectCreateOrConnectWithoutStaffInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type StaffAttendanceUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<StaffAttendanceCreateWithoutStaffInput, StaffAttendanceUncheckedCreateWithoutStaffInput> | StaffAttendanceCreateWithoutStaffInput[] | StaffAttendanceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutStaffInput | StaffAttendanceCreateOrConnectWithoutStaffInput[]
    createMany?: StaffAttendanceCreateManyStaffInputEnvelope
    connect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
  }

  export type StaffApplicationUncheckedCreateNestedOneWithoutStaffInput = {
    create?: XOR<StaffApplicationCreateWithoutStaffInput, StaffApplicationUncheckedCreateWithoutStaffInput>
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutStaffInput
    connect?: StaffApplicationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    upsert?: UserUpsertWithoutStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffInput, UserUpdateWithoutStaffInput>, UserUncheckedUpdateWithoutStaffInput>
  }

  export type ClassUpdateOneWithoutStaffNestedInput = {
    create?: XOR<ClassCreateWithoutStaffInput, ClassUncheckedCreateWithoutStaffInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStaffInput
    upsert?: ClassUpsertWithoutStaffInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStaffInput, ClassUpdateWithoutStaffInput>, ClassUncheckedUpdateWithoutStaffInput>
  }

  export type GradeUpdateManyWithoutStaffNestedInput = {
    create?: XOR<GradeCreateWithoutStaffInput, GradeUncheckedCreateWithoutStaffInput> | GradeCreateWithoutStaffInput[] | GradeUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStaffInput | GradeCreateOrConnectWithoutStaffInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStaffInput | GradeUpsertWithWhereUniqueWithoutStaffInput[]
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStaffInput | GradeUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStaffInput | GradeUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutStaffNestedInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    upsert?: DepartmentUpsertWithoutStaffInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutStaffInput, DepartmentUpdateWithoutStaffInput>, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type SubjectUpdateManyWithoutStaffNestedInput = {
    create?: XOR<SubjectCreateWithoutStaffInput, SubjectUncheckedCreateWithoutStaffInput> | SubjectCreateWithoutStaffInput[] | SubjectUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStaffInput | SubjectCreateOrConnectWithoutStaffInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutStaffInput | SubjectUpsertWithWhereUniqueWithoutStaffInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutStaffInput | SubjectUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutStaffInput | SubjectUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type StaffAttendanceUpdateManyWithoutStaffNestedInput = {
    create?: XOR<StaffAttendanceCreateWithoutStaffInput, StaffAttendanceUncheckedCreateWithoutStaffInput> | StaffAttendanceCreateWithoutStaffInput[] | StaffAttendanceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutStaffInput | StaffAttendanceCreateOrConnectWithoutStaffInput[]
    upsert?: StaffAttendanceUpsertWithWhereUniqueWithoutStaffInput | StaffAttendanceUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: StaffAttendanceCreateManyStaffInputEnvelope
    set?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    disconnect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    delete?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    connect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    update?: StaffAttendanceUpdateWithWhereUniqueWithoutStaffInput | StaffAttendanceUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: StaffAttendanceUpdateManyWithWhereWithoutStaffInput | StaffAttendanceUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: StaffAttendanceScalarWhereInput | StaffAttendanceScalarWhereInput[]
  }

  export type StaffApplicationUpdateOneWithoutStaffNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutStaffInput, StaffApplicationUncheckedCreateWithoutStaffInput>
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutStaffInput
    upsert?: StaffApplicationUpsertWithoutStaffInput
    disconnect?: StaffApplicationWhereInput | boolean
    delete?: StaffApplicationWhereInput | boolean
    connect?: StaffApplicationWhereUniqueInput
    update?: XOR<XOR<StaffApplicationUpdateToOneWithWhereWithoutStaffInput, StaffApplicationUpdateWithoutStaffInput>, StaffApplicationUncheckedUpdateWithoutStaffInput>
  }

  export type GradeUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<GradeCreateWithoutStaffInput, GradeUncheckedCreateWithoutStaffInput> | GradeCreateWithoutStaffInput[] | GradeUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStaffInput | GradeCreateOrConnectWithoutStaffInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStaffInput | GradeUpsertWithWhereUniqueWithoutStaffInput[]
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStaffInput | GradeUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStaffInput | GradeUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<SubjectCreateWithoutStaffInput, SubjectUncheckedCreateWithoutStaffInput> | SubjectCreateWithoutStaffInput[] | SubjectUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutStaffInput | SubjectCreateOrConnectWithoutStaffInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutStaffInput | SubjectUpsertWithWhereUniqueWithoutStaffInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutStaffInput | SubjectUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutStaffInput | SubjectUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type StaffAttendanceUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<StaffAttendanceCreateWithoutStaffInput, StaffAttendanceUncheckedCreateWithoutStaffInput> | StaffAttendanceCreateWithoutStaffInput[] | StaffAttendanceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StaffAttendanceCreateOrConnectWithoutStaffInput | StaffAttendanceCreateOrConnectWithoutStaffInput[]
    upsert?: StaffAttendanceUpsertWithWhereUniqueWithoutStaffInput | StaffAttendanceUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: StaffAttendanceCreateManyStaffInputEnvelope
    set?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    disconnect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    delete?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    connect?: StaffAttendanceWhereUniqueInput | StaffAttendanceWhereUniqueInput[]
    update?: StaffAttendanceUpdateWithWhereUniqueWithoutStaffInput | StaffAttendanceUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: StaffAttendanceUpdateManyWithWhereWithoutStaffInput | StaffAttendanceUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: StaffAttendanceScalarWhereInput | StaffAttendanceScalarWhereInput[]
  }

  export type StaffApplicationUncheckedUpdateOneWithoutStaffNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutStaffInput, StaffApplicationUncheckedCreateWithoutStaffInput>
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutStaffInput
    upsert?: StaffApplicationUpsertWithoutStaffInput
    disconnect?: StaffApplicationWhereInput | boolean
    delete?: StaffApplicationWhereInput | boolean
    connect?: StaffApplicationWhereUniqueInput
    update?: XOR<XOR<StaffApplicationUpdateToOneWithWhereWithoutStaffInput, StaffApplicationUpdateWithoutStaffInput>, StaffApplicationUncheckedUpdateWithoutStaffInput>
  }

  export type StaffCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type LibraryStaffCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<LibraryStaffCreateWithoutDepartmentInput, LibraryStaffUncheckedCreateWithoutDepartmentInput> | LibraryStaffCreateWithoutDepartmentInput[] | LibraryStaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: LibraryStaffCreateOrConnectWithoutDepartmentInput | LibraryStaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: LibraryStaffCreateManyDepartmentInputEnvelope
    connect?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
  }

  export type StaffApplicationCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffApplicationCreateWithoutDepartmentInput, StaffApplicationUncheckedCreateWithoutDepartmentInput> | StaffApplicationCreateWithoutDepartmentInput[] | StaffApplicationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutDepartmentInput | StaffApplicationCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffApplicationCreateManyDepartmentInputEnvelope
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type LibraryStaffUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<LibraryStaffCreateWithoutDepartmentInput, LibraryStaffUncheckedCreateWithoutDepartmentInput> | LibraryStaffCreateWithoutDepartmentInput[] | LibraryStaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: LibraryStaffCreateOrConnectWithoutDepartmentInput | LibraryStaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: LibraryStaffCreateManyDepartmentInputEnvelope
    connect?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
  }

  export type StaffApplicationUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffApplicationCreateWithoutDepartmentInput, StaffApplicationUncheckedCreateWithoutDepartmentInput> | StaffApplicationCreateWithoutDepartmentInput[] | StaffApplicationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutDepartmentInput | StaffApplicationCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffApplicationCreateManyDepartmentInputEnvelope
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
  }

  export type StaffUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutDepartmentInput | StaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutDepartmentInput | StaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutDepartmentInput | StaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type LibraryStaffUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<LibraryStaffCreateWithoutDepartmentInput, LibraryStaffUncheckedCreateWithoutDepartmentInput> | LibraryStaffCreateWithoutDepartmentInput[] | LibraryStaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: LibraryStaffCreateOrConnectWithoutDepartmentInput | LibraryStaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: LibraryStaffUpsertWithWhereUniqueWithoutDepartmentInput | LibraryStaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: LibraryStaffCreateManyDepartmentInputEnvelope
    set?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
    disconnect?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
    delete?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
    connect?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
    update?: LibraryStaffUpdateWithWhereUniqueWithoutDepartmentInput | LibraryStaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: LibraryStaffUpdateManyWithWhereWithoutDepartmentInput | LibraryStaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: LibraryStaffScalarWhereInput | LibraryStaffScalarWhereInput[]
  }

  export type StaffApplicationUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutDepartmentInput, StaffApplicationUncheckedCreateWithoutDepartmentInput> | StaffApplicationCreateWithoutDepartmentInput[] | StaffApplicationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutDepartmentInput | StaffApplicationCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffApplicationUpsertWithWhereUniqueWithoutDepartmentInput | StaffApplicationUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffApplicationCreateManyDepartmentInputEnvelope
    set?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    disconnect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    delete?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    update?: StaffApplicationUpdateWithWhereUniqueWithoutDepartmentInput | StaffApplicationUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffApplicationUpdateManyWithWhereWithoutDepartmentInput | StaffApplicationUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffApplicationScalarWhereInput | StaffApplicationScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutDepartmentInput | StaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutDepartmentInput | StaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutDepartmentInput | StaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type LibraryStaffUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<LibraryStaffCreateWithoutDepartmentInput, LibraryStaffUncheckedCreateWithoutDepartmentInput> | LibraryStaffCreateWithoutDepartmentInput[] | LibraryStaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: LibraryStaffCreateOrConnectWithoutDepartmentInput | LibraryStaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: LibraryStaffUpsertWithWhereUniqueWithoutDepartmentInput | LibraryStaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: LibraryStaffCreateManyDepartmentInputEnvelope
    set?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
    disconnect?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
    delete?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
    connect?: LibraryStaffWhereUniqueInput | LibraryStaffWhereUniqueInput[]
    update?: LibraryStaffUpdateWithWhereUniqueWithoutDepartmentInput | LibraryStaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: LibraryStaffUpdateManyWithWhereWithoutDepartmentInput | LibraryStaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: LibraryStaffScalarWhereInput | LibraryStaffScalarWhereInput[]
  }

  export type StaffApplicationUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffApplicationCreateWithoutDepartmentInput, StaffApplicationUncheckedCreateWithoutDepartmentInput> | StaffApplicationCreateWithoutDepartmentInput[] | StaffApplicationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffApplicationCreateOrConnectWithoutDepartmentInput | StaffApplicationCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffApplicationUpsertWithWhereUniqueWithoutDepartmentInput | StaffApplicationUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffApplicationCreateManyDepartmentInputEnvelope
    set?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    disconnect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    delete?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    connect?: StaffApplicationWhereUniqueInput | StaffApplicationWhereUniqueInput[]
    update?: StaffApplicationUpdateWithWhereUniqueWithoutDepartmentInput | StaffApplicationUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffApplicationUpdateManyWithWhereWithoutDepartmentInput | StaffApplicationUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffApplicationScalarWhereInput | StaffApplicationScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudentAttendanceInput = {
    create?: XOR<StudentCreateWithoutStudentAttendanceInput, StudentUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAttendanceInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type StudentUpdateOneRequiredWithoutStudentAttendanceNestedInput = {
    create?: XOR<StudentCreateWithoutStudentAttendanceInput, StudentUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAttendanceInput
    upsert?: StudentUpsertWithoutStudentAttendanceInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentAttendanceInput, StudentUpdateWithoutStudentAttendanceInput>, StudentUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type StaffCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<StaffCreateWithoutAttendancesInput, StaffUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAttendancesInput
    connect?: StaffWhereUniqueInput
  }

  export type StaffUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<StaffCreateWithoutAttendancesInput, StaffUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAttendancesInput
    upsert?: StaffUpsertWithoutAttendancesInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutAttendancesInput, StaffUpdateWithoutAttendancesInput>, StaffUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentCreateNestedOneWithoutParentInput = {
    create?: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutParentNestedInput = {
    create?: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentInput
    upsert?: StudentUpsertWithoutParentInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentInput, StudentUpdateWithoutParentInput>, StudentUncheckedUpdateWithoutParentInput>
  }

  export type BookCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BookCreateWithoutAuthorInput, BookUncheckedCreateWithoutAuthorInput> | BookCreateWithoutAuthorInput[] | BookUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BookCreateOrConnectWithoutAuthorInput | BookCreateOrConnectWithoutAuthorInput[]
    createMany?: BookCreateManyAuthorInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BookCreateWithoutAuthorInput, BookUncheckedCreateWithoutAuthorInput> | BookCreateWithoutAuthorInput[] | BookUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BookCreateOrConnectWithoutAuthorInput | BookCreateOrConnectWithoutAuthorInput[]
    createMany?: BookCreateManyAuthorInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BookCreateWithoutAuthorInput, BookUncheckedCreateWithoutAuthorInput> | BookCreateWithoutAuthorInput[] | BookUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BookCreateOrConnectWithoutAuthorInput | BookCreateOrConnectWithoutAuthorInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutAuthorInput | BookUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BookCreateManyAuthorInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutAuthorInput | BookUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BookUpdateManyWithWhereWithoutAuthorInput | BookUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BookCreateWithoutAuthorInput, BookUncheckedCreateWithoutAuthorInput> | BookCreateWithoutAuthorInput[] | BookUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BookCreateOrConnectWithoutAuthorInput | BookCreateOrConnectWithoutAuthorInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutAuthorInput | BookUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BookCreateManyAuthorInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutAuthorInput | BookUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BookUpdateManyWithWhereWithoutAuthorInput | BookUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BookCreateWithoutCategoryInput, BookUncheckedCreateWithoutCategoryInput> | BookCreateWithoutCategoryInput[] | BookUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCategoryInput | BookCreateOrConnectWithoutCategoryInput[]
    createMany?: BookCreateManyCategoryInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BookCreateWithoutCategoryInput, BookUncheckedCreateWithoutCategoryInput> | BookCreateWithoutCategoryInput[] | BookUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCategoryInput | BookCreateOrConnectWithoutCategoryInput[]
    createMany?: BookCreateManyCategoryInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BookCreateWithoutCategoryInput, BookUncheckedCreateWithoutCategoryInput> | BookCreateWithoutCategoryInput[] | BookUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCategoryInput | BookCreateOrConnectWithoutCategoryInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutCategoryInput | BookUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BookCreateManyCategoryInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutCategoryInput | BookUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BookUpdateManyWithWhereWithoutCategoryInput | BookUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BookCreateWithoutCategoryInput, BookUncheckedCreateWithoutCategoryInput> | BookCreateWithoutCategoryInput[] | BookUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCategoryInput | BookCreateOrConnectWithoutCategoryInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutCategoryInput | BookUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BookCreateManyCategoryInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutCategoryInput | BookUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BookUpdateManyWithWhereWithoutCategoryInput | BookUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type AuthorCreateNestedOneWithoutBooksInput = {
    create?: XOR<AuthorCreateWithoutBooksInput, AuthorUncheckedCreateWithoutBooksInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutBooksInput
    connect?: AuthorWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutBooksInput = {
    create?: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBooksInput
    connect?: CategoryWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutBookInput = {
    create?: XOR<SchoolCreateWithoutBookInput, SchoolUncheckedCreateWithoutBookInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutBookInput
    connect?: SchoolWhereUniqueInput
  }

  export type BorrowCreateNestedManyWithoutBookInput = {
    create?: XOR<BorrowCreateWithoutBookInput, BorrowUncheckedCreateWithoutBookInput> | BorrowCreateWithoutBookInput[] | BorrowUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutBookInput | BorrowCreateOrConnectWithoutBookInput[]
    createMany?: BorrowCreateManyBookInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<BorrowCreateWithoutBookInput, BorrowUncheckedCreateWithoutBookInput> | BorrowCreateWithoutBookInput[] | BorrowUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutBookInput | BorrowCreateOrConnectWithoutBookInput[]
    createMany?: BorrowCreateManyBookInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type AuthorUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<AuthorCreateWithoutBooksInput, AuthorUncheckedCreateWithoutBooksInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutBooksInput
    upsert?: AuthorUpsertWithoutBooksInput
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutBooksInput, AuthorUpdateWithoutBooksInput>, AuthorUncheckedUpdateWithoutBooksInput>
  }

  export type CategoryUpdateOneWithoutBooksNestedInput = {
    create?: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBooksInput
    upsert?: CategoryUpsertWithoutBooksInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutBooksInput, CategoryUpdateWithoutBooksInput>, CategoryUncheckedUpdateWithoutBooksInput>
  }

  export type SchoolUpdateOneRequiredWithoutBookNestedInput = {
    create?: XOR<SchoolCreateWithoutBookInput, SchoolUncheckedCreateWithoutBookInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutBookInput
    upsert?: SchoolUpsertWithoutBookInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutBookInput, SchoolUpdateWithoutBookInput>, SchoolUncheckedUpdateWithoutBookInput>
  }

  export type BorrowUpdateManyWithoutBookNestedInput = {
    create?: XOR<BorrowCreateWithoutBookInput, BorrowUncheckedCreateWithoutBookInput> | BorrowCreateWithoutBookInput[] | BorrowUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutBookInput | BorrowCreateOrConnectWithoutBookInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutBookInput | BorrowUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BorrowCreateManyBookInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutBookInput | BorrowUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutBookInput | BorrowUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<BorrowCreateWithoutBookInput, BorrowUncheckedCreateWithoutBookInput> | BorrowCreateWithoutBookInput[] | BorrowUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutBookInput | BorrowCreateOrConnectWithoutBookInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutBookInput | BorrowUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BorrowCreateManyBookInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutBookInput | BorrowUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutBookInput | BorrowUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BookCreateNestedOneWithoutBorrowsInput = {
    create?: XOR<BookCreateWithoutBorrowsInput, BookUncheckedCreateWithoutBorrowsInput>
    connectOrCreate?: BookCreateOrConnectWithoutBorrowsInput
    connect?: BookWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutBorrowInput = {
    create?: XOR<StudentCreateWithoutBorrowInput, StudentUncheckedCreateWithoutBorrowInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBorrowInput
    connect?: StudentWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookUpdateOneRequiredWithoutBorrowsNestedInput = {
    create?: XOR<BookCreateWithoutBorrowsInput, BookUncheckedCreateWithoutBorrowsInput>
    connectOrCreate?: BookCreateOrConnectWithoutBorrowsInput
    upsert?: BookUpsertWithoutBorrowsInput
    connect?: BookWhereUniqueInput
    update?: XOR<XOR<BookUpdateToOneWithWhereWithoutBorrowsInput, BookUpdateWithoutBorrowsInput>, BookUncheckedUpdateWithoutBorrowsInput>
  }

  export type StudentUpdateOneRequiredWithoutBorrowNestedInput = {
    create?: XOR<StudentCreateWithoutBorrowInput, StudentUncheckedCreateWithoutBorrowInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBorrowInput
    upsert?: StudentUpsertWithoutBorrowInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutBorrowInput, StudentUpdateWithoutBorrowInput>, StudentUncheckedUpdateWithoutBorrowInput>
  }

  export type UserCreateNestedOneWithoutLibraryStaffInput = {
    create?: XOR<UserCreateWithoutLibraryStaffInput, UserUncheckedCreateWithoutLibraryStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryStaffInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutLibraryStaffInput = {
    create?: XOR<DepartmentCreateWithoutLibraryStaffInput, DepartmentUncheckedCreateWithoutLibraryStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutLibraryStaffInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLibraryStaffNestedInput = {
    create?: XOR<UserCreateWithoutLibraryStaffInput, UserUncheckedCreateWithoutLibraryStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryStaffInput
    upsert?: UserUpsertWithoutLibraryStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLibraryStaffInput, UserUpdateWithoutLibraryStaffInput>, UserUncheckedUpdateWithoutLibraryStaffInput>
  }

  export type DepartmentUpdateOneRequiredWithoutLibraryStaffNestedInput = {
    create?: XOR<DepartmentCreateWithoutLibraryStaffInput, DepartmentUncheckedCreateWithoutLibraryStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutLibraryStaffInput
    upsert?: DepartmentUpsertWithoutLibraryStaffInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutLibraryStaffInput, DepartmentUpdateWithoutLibraryStaffInput>, DepartmentUncheckedUpdateWithoutLibraryStaffInput>
  }

  export type ApplicationCreateNestedManyWithoutAdmissionPaymentInput = {
    create?: XOR<ApplicationCreateWithoutAdmissionPaymentInput, ApplicationUncheckedCreateWithoutAdmissionPaymentInput> | ApplicationCreateWithoutAdmissionPaymentInput[] | ApplicationUncheckedCreateWithoutAdmissionPaymentInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutAdmissionPaymentInput | ApplicationCreateOrConnectWithoutAdmissionPaymentInput[]
    createMany?: ApplicationCreateManyAdmissionPaymentInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutAdmissionPaymentInput = {
    create?: XOR<ApplicationCreateWithoutAdmissionPaymentInput, ApplicationUncheckedCreateWithoutAdmissionPaymentInput> | ApplicationCreateWithoutAdmissionPaymentInput[] | ApplicationUncheckedCreateWithoutAdmissionPaymentInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutAdmissionPaymentInput | ApplicationCreateOrConnectWithoutAdmissionPaymentInput[]
    createMany?: ApplicationCreateManyAdmissionPaymentInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type ApplicationUpdateManyWithoutAdmissionPaymentNestedInput = {
    create?: XOR<ApplicationCreateWithoutAdmissionPaymentInput, ApplicationUncheckedCreateWithoutAdmissionPaymentInput> | ApplicationCreateWithoutAdmissionPaymentInput[] | ApplicationUncheckedCreateWithoutAdmissionPaymentInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutAdmissionPaymentInput | ApplicationCreateOrConnectWithoutAdmissionPaymentInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutAdmissionPaymentInput | ApplicationUpsertWithWhereUniqueWithoutAdmissionPaymentInput[]
    createMany?: ApplicationCreateManyAdmissionPaymentInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutAdmissionPaymentInput | ApplicationUpdateWithWhereUniqueWithoutAdmissionPaymentInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutAdmissionPaymentInput | ApplicationUpdateManyWithWhereWithoutAdmissionPaymentInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutAdmissionPaymentNestedInput = {
    create?: XOR<ApplicationCreateWithoutAdmissionPaymentInput, ApplicationUncheckedCreateWithoutAdmissionPaymentInput> | ApplicationCreateWithoutAdmissionPaymentInput[] | ApplicationUncheckedCreateWithoutAdmissionPaymentInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutAdmissionPaymentInput | ApplicationCreateOrConnectWithoutAdmissionPaymentInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutAdmissionPaymentInput | ApplicationUpsertWithWhereUniqueWithoutAdmissionPaymentInput[]
    createMany?: ApplicationCreateManyAdmissionPaymentInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutAdmissionPaymentInput | ApplicationUpdateWithWhereUniqueWithoutAdmissionPaymentInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutAdmissionPaymentInput | ApplicationUpdateManyWithWhereWithoutAdmissionPaymentInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutTransactionInput = {
    create?: XOR<StudentCreateWithoutTransactionInput, StudentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTransactionInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumFinanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.FinanceType
  }

  export type NullableEnumFeeTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeeType | null
  }

  export type StudentUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<StudentCreateWithoutTransactionInput, StudentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTransactionInput
    upsert?: StudentUpsertWithoutTransactionInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutTransactionInput, StudentUpdateWithoutTransactionInput>, StudentUncheckedUpdateWithoutTransactionInput>
  }

  export type SchoolCreateNestedOneWithoutFinancesInput = {
    create?: XOR<SchoolCreateWithoutFinancesInput, SchoolUncheckedCreateWithoutFinancesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFinancesInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutFinancesNestedInput = {
    create?: XOR<SchoolCreateWithoutFinancesInput, SchoolUncheckedCreateWithoutFinancesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFinancesInput
    upsert?: SchoolUpsertWithoutFinancesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFinancesInput, SchoolUpdateWithoutFinancesInput>, SchoolUncheckedUpdateWithoutFinancesInput>
  }

  export type SchoolCreateNestedOneWithoutResourcesInput = {
    create?: XOR<SchoolCreateWithoutResourcesInput, SchoolUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutResourcesInput
    connect?: SchoolWhereUniqueInput
  }

  export type PurchaseCreateNestedManyWithoutResourceInput = {
    create?: XOR<PurchaseCreateWithoutResourceInput, PurchaseUncheckedCreateWithoutResourceInput> | PurchaseCreateWithoutResourceInput[] | PurchaseUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutResourceInput | PurchaseCreateOrConnectWithoutResourceInput[]
    createMany?: PurchaseCreateManyResourceInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<PurchaseCreateWithoutResourceInput, PurchaseUncheckedCreateWithoutResourceInput> | PurchaseCreateWithoutResourceInput[] | PurchaseUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutResourceInput | PurchaseCreateOrConnectWithoutResourceInput[]
    createMany?: PurchaseCreateManyResourceInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<SchoolCreateWithoutResourcesInput, SchoolUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutResourcesInput
    upsert?: SchoolUpsertWithoutResourcesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutResourcesInput, SchoolUpdateWithoutResourcesInput>, SchoolUncheckedUpdateWithoutResourcesInput>
  }

  export type PurchaseUpdateManyWithoutResourceNestedInput = {
    create?: XOR<PurchaseCreateWithoutResourceInput, PurchaseUncheckedCreateWithoutResourceInput> | PurchaseCreateWithoutResourceInput[] | PurchaseUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutResourceInput | PurchaseCreateOrConnectWithoutResourceInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutResourceInput | PurchaseUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: PurchaseCreateManyResourceInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutResourceInput | PurchaseUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutResourceInput | PurchaseUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<PurchaseCreateWithoutResourceInput, PurchaseUncheckedCreateWithoutResourceInput> | PurchaseCreateWithoutResourceInput[] | PurchaseUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutResourceInput | PurchaseCreateOrConnectWithoutResourceInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutResourceInput | PurchaseUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: PurchaseCreateManyResourceInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutResourceInput | PurchaseUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutResourceInput | PurchaseUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<StudentCreateWithoutPurchaseInput, StudentUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPurchaseInput
    connect?: StudentWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<ResourceCreateWithoutPurchasesInput, ResourceUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutPurchasesInput
    connect?: ResourceWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<StudentCreateWithoutPurchaseInput, StudentUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPurchaseInput
    upsert?: StudentUpsertWithoutPurchaseInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPurchaseInput, StudentUpdateWithoutPurchaseInput>, StudentUncheckedUpdateWithoutPurchaseInput>
  }

  export type ResourceUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<ResourceCreateWithoutPurchasesInput, ResourceUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutPurchasesInput
    upsert?: ResourceUpsertWithoutPurchasesInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutPurchasesInput, ResourceUpdateWithoutPurchasesInput>, ResourceUncheckedUpdateWithoutPurchasesInput>
  }

  export type SchoolCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<SchoolCreateWithoutActivitiesInput, SchoolUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutActivitiesInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<SchoolCreateWithoutActivitiesInput, SchoolUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutActivitiesInput
    upsert?: SchoolUpsertWithoutActivitiesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutActivitiesInput, SchoolUpdateWithoutActivitiesInput>, SchoolUncheckedUpdateWithoutActivitiesInput>
  }

  export type SchoolCreateNestedOneWithoutBusesInput = {
    create?: XOR<SchoolCreateWithoutBusesInput, SchoolUncheckedCreateWithoutBusesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutBusesInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutBusesNestedInput = {
    create?: XOR<SchoolCreateWithoutBusesInput, SchoolUncheckedCreateWithoutBusesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutBusesInput
    upsert?: SchoolUpsertWithoutBusesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutBusesInput, SchoolUpdateWithoutBusesInput>, SchoolUncheckedUpdateWithoutBusesInput>
  }

  export type UserCreateNestedOneWithoutSkuunAiSessionInput = {
    create?: XOR<UserCreateWithoutSkuunAiSessionInput, UserUncheckedCreateWithoutSkuunAiSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkuunAiSessionInput
    connect?: UserWhereUniqueInput
  }

  export type SkuunAiMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<SkuunAiMessageCreateWithoutSessionInput, SkuunAiMessageUncheckedCreateWithoutSessionInput> | SkuunAiMessageCreateWithoutSessionInput[] | SkuunAiMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiMessageCreateOrConnectWithoutSessionInput | SkuunAiMessageCreateOrConnectWithoutSessionInput[]
    createMany?: SkuunAiMessageCreateManySessionInputEnvelope
    connect?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
  }

  export type SkuunAiActionCreateNestedManyWithoutSessionInput = {
    create?: XOR<SkuunAiActionCreateWithoutSessionInput, SkuunAiActionUncheckedCreateWithoutSessionInput> | SkuunAiActionCreateWithoutSessionInput[] | SkuunAiActionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiActionCreateOrConnectWithoutSessionInput | SkuunAiActionCreateOrConnectWithoutSessionInput[]
    createMany?: SkuunAiActionCreateManySessionInputEnvelope
    connect?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
  }

  export type SkuunAiRecommendationCreateNestedManyWithoutSessionInput = {
    create?: XOR<SkuunAiRecommendationCreateWithoutSessionInput, SkuunAiRecommendationUncheckedCreateWithoutSessionInput> | SkuunAiRecommendationCreateWithoutSessionInput[] | SkuunAiRecommendationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiRecommendationCreateOrConnectWithoutSessionInput | SkuunAiRecommendationCreateOrConnectWithoutSessionInput[]
    createMany?: SkuunAiRecommendationCreateManySessionInputEnvelope
    connect?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
  }

  export type SkuunAiMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SkuunAiMessageCreateWithoutSessionInput, SkuunAiMessageUncheckedCreateWithoutSessionInput> | SkuunAiMessageCreateWithoutSessionInput[] | SkuunAiMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiMessageCreateOrConnectWithoutSessionInput | SkuunAiMessageCreateOrConnectWithoutSessionInput[]
    createMany?: SkuunAiMessageCreateManySessionInputEnvelope
    connect?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
  }

  export type SkuunAiActionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SkuunAiActionCreateWithoutSessionInput, SkuunAiActionUncheckedCreateWithoutSessionInput> | SkuunAiActionCreateWithoutSessionInput[] | SkuunAiActionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiActionCreateOrConnectWithoutSessionInput | SkuunAiActionCreateOrConnectWithoutSessionInput[]
    createMany?: SkuunAiActionCreateManySessionInputEnvelope
    connect?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
  }

  export type SkuunAiRecommendationUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SkuunAiRecommendationCreateWithoutSessionInput, SkuunAiRecommendationUncheckedCreateWithoutSessionInput> | SkuunAiRecommendationCreateWithoutSessionInput[] | SkuunAiRecommendationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiRecommendationCreateOrConnectWithoutSessionInput | SkuunAiRecommendationCreateOrConnectWithoutSessionInput[]
    createMany?: SkuunAiRecommendationCreateManySessionInputEnvelope
    connect?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSkuunAiSessionNestedInput = {
    create?: XOR<UserCreateWithoutSkuunAiSessionInput, UserUncheckedCreateWithoutSkuunAiSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkuunAiSessionInput
    upsert?: UserUpsertWithoutSkuunAiSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSkuunAiSessionInput, UserUpdateWithoutSkuunAiSessionInput>, UserUncheckedUpdateWithoutSkuunAiSessionInput>
  }

  export type SkuunAiMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SkuunAiMessageCreateWithoutSessionInput, SkuunAiMessageUncheckedCreateWithoutSessionInput> | SkuunAiMessageCreateWithoutSessionInput[] | SkuunAiMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiMessageCreateOrConnectWithoutSessionInput | SkuunAiMessageCreateOrConnectWithoutSessionInput[]
    upsert?: SkuunAiMessageUpsertWithWhereUniqueWithoutSessionInput | SkuunAiMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SkuunAiMessageCreateManySessionInputEnvelope
    set?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
    disconnect?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
    delete?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
    connect?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
    update?: SkuunAiMessageUpdateWithWhereUniqueWithoutSessionInput | SkuunAiMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SkuunAiMessageUpdateManyWithWhereWithoutSessionInput | SkuunAiMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SkuunAiMessageScalarWhereInput | SkuunAiMessageScalarWhereInput[]
  }

  export type SkuunAiActionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SkuunAiActionCreateWithoutSessionInput, SkuunAiActionUncheckedCreateWithoutSessionInput> | SkuunAiActionCreateWithoutSessionInput[] | SkuunAiActionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiActionCreateOrConnectWithoutSessionInput | SkuunAiActionCreateOrConnectWithoutSessionInput[]
    upsert?: SkuunAiActionUpsertWithWhereUniqueWithoutSessionInput | SkuunAiActionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SkuunAiActionCreateManySessionInputEnvelope
    set?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
    disconnect?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
    delete?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
    connect?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
    update?: SkuunAiActionUpdateWithWhereUniqueWithoutSessionInput | SkuunAiActionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SkuunAiActionUpdateManyWithWhereWithoutSessionInput | SkuunAiActionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SkuunAiActionScalarWhereInput | SkuunAiActionScalarWhereInput[]
  }

  export type SkuunAiRecommendationUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SkuunAiRecommendationCreateWithoutSessionInput, SkuunAiRecommendationUncheckedCreateWithoutSessionInput> | SkuunAiRecommendationCreateWithoutSessionInput[] | SkuunAiRecommendationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiRecommendationCreateOrConnectWithoutSessionInput | SkuunAiRecommendationCreateOrConnectWithoutSessionInput[]
    upsert?: SkuunAiRecommendationUpsertWithWhereUniqueWithoutSessionInput | SkuunAiRecommendationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SkuunAiRecommendationCreateManySessionInputEnvelope
    set?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
    disconnect?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
    delete?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
    connect?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
    update?: SkuunAiRecommendationUpdateWithWhereUniqueWithoutSessionInput | SkuunAiRecommendationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SkuunAiRecommendationUpdateManyWithWhereWithoutSessionInput | SkuunAiRecommendationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SkuunAiRecommendationScalarWhereInput | SkuunAiRecommendationScalarWhereInput[]
  }

  export type SkuunAiMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SkuunAiMessageCreateWithoutSessionInput, SkuunAiMessageUncheckedCreateWithoutSessionInput> | SkuunAiMessageCreateWithoutSessionInput[] | SkuunAiMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiMessageCreateOrConnectWithoutSessionInput | SkuunAiMessageCreateOrConnectWithoutSessionInput[]
    upsert?: SkuunAiMessageUpsertWithWhereUniqueWithoutSessionInput | SkuunAiMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SkuunAiMessageCreateManySessionInputEnvelope
    set?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
    disconnect?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
    delete?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
    connect?: SkuunAiMessageWhereUniqueInput | SkuunAiMessageWhereUniqueInput[]
    update?: SkuunAiMessageUpdateWithWhereUniqueWithoutSessionInput | SkuunAiMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SkuunAiMessageUpdateManyWithWhereWithoutSessionInput | SkuunAiMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SkuunAiMessageScalarWhereInput | SkuunAiMessageScalarWhereInput[]
  }

  export type SkuunAiActionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SkuunAiActionCreateWithoutSessionInput, SkuunAiActionUncheckedCreateWithoutSessionInput> | SkuunAiActionCreateWithoutSessionInput[] | SkuunAiActionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiActionCreateOrConnectWithoutSessionInput | SkuunAiActionCreateOrConnectWithoutSessionInput[]
    upsert?: SkuunAiActionUpsertWithWhereUniqueWithoutSessionInput | SkuunAiActionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SkuunAiActionCreateManySessionInputEnvelope
    set?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
    disconnect?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
    delete?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
    connect?: SkuunAiActionWhereUniqueInput | SkuunAiActionWhereUniqueInput[]
    update?: SkuunAiActionUpdateWithWhereUniqueWithoutSessionInput | SkuunAiActionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SkuunAiActionUpdateManyWithWhereWithoutSessionInput | SkuunAiActionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SkuunAiActionScalarWhereInput | SkuunAiActionScalarWhereInput[]
  }

  export type SkuunAiRecommendationUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SkuunAiRecommendationCreateWithoutSessionInput, SkuunAiRecommendationUncheckedCreateWithoutSessionInput> | SkuunAiRecommendationCreateWithoutSessionInput[] | SkuunAiRecommendationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SkuunAiRecommendationCreateOrConnectWithoutSessionInput | SkuunAiRecommendationCreateOrConnectWithoutSessionInput[]
    upsert?: SkuunAiRecommendationUpsertWithWhereUniqueWithoutSessionInput | SkuunAiRecommendationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SkuunAiRecommendationCreateManySessionInputEnvelope
    set?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
    disconnect?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
    delete?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
    connect?: SkuunAiRecommendationWhereUniqueInput | SkuunAiRecommendationWhereUniqueInput[]
    update?: SkuunAiRecommendationUpdateWithWhereUniqueWithoutSessionInput | SkuunAiRecommendationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SkuunAiRecommendationUpdateManyWithWhereWithoutSessionInput | SkuunAiRecommendationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SkuunAiRecommendationScalarWhereInput | SkuunAiRecommendationScalarWhereInput[]
  }

  export type SkuunAiSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SkuunAiSessionCreateWithoutMessagesInput, SkuunAiSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutMessagesInput
    connect?: SkuunAiSessionWhereUniqueInput
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type SkuunAiSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SkuunAiSessionCreateWithoutMessagesInput, SkuunAiSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutMessagesInput
    upsert?: SkuunAiSessionUpsertWithoutMessagesInput
    connect?: SkuunAiSessionWhereUniqueInput
    update?: XOR<XOR<SkuunAiSessionUpdateToOneWithWhereWithoutMessagesInput, SkuunAiSessionUpdateWithoutMessagesInput>, SkuunAiSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type SkuunAiSessionCreateNestedOneWithoutActionsInput = {
    create?: XOR<SkuunAiSessionCreateWithoutActionsInput, SkuunAiSessionUncheckedCreateWithoutActionsInput>
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutActionsInput
    connect?: SkuunAiSessionWhereUniqueInput
  }

  export type EnumAIActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AIActionType
  }

  export type EnumActionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ActionStatus
  }

  export type SkuunAiSessionUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<SkuunAiSessionCreateWithoutActionsInput, SkuunAiSessionUncheckedCreateWithoutActionsInput>
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutActionsInput
    upsert?: SkuunAiSessionUpsertWithoutActionsInput
    connect?: SkuunAiSessionWhereUniqueInput
    update?: XOR<XOR<SkuunAiSessionUpdateToOneWithWhereWithoutActionsInput, SkuunAiSessionUpdateWithoutActionsInput>, SkuunAiSessionUncheckedUpdateWithoutActionsInput>
  }

  export type SkuunAiSessionCreateNestedOneWithoutSkuunAiRecommendationInput = {
    create?: XOR<SkuunAiSessionCreateWithoutSkuunAiRecommendationInput, SkuunAiSessionUncheckedCreateWithoutSkuunAiRecommendationInput>
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutSkuunAiRecommendationInput
    connect?: SkuunAiSessionWhereUniqueInput
  }

  export type SkuunAiSessionUpdateOneRequiredWithoutSkuunAiRecommendationNestedInput = {
    create?: XOR<SkuunAiSessionCreateWithoutSkuunAiRecommendationInput, SkuunAiSessionUncheckedCreateWithoutSkuunAiRecommendationInput>
    connectOrCreate?: SkuunAiSessionCreateOrConnectWithoutSkuunAiRecommendationInput
    upsert?: SkuunAiSessionUpsertWithoutSkuunAiRecommendationInput
    connect?: SkuunAiSessionWhereUniqueInput
    update?: XOR<XOR<SkuunAiSessionUpdateToOneWithWhereWithoutSkuunAiRecommendationInput, SkuunAiSessionUpdateWithoutSkuunAiRecommendationInput>, SkuunAiSessionUncheckedUpdateWithoutSkuunAiRecommendationInput>
  }

  export type DecisionRecordCreateNestedOneWithoutSupersededByInput = {
    create?: XOR<DecisionRecordCreateWithoutSupersededByInput, DecisionRecordUncheckedCreateWithoutSupersededByInput>
    connectOrCreate?: DecisionRecordCreateOrConnectWithoutSupersededByInput
    connect?: DecisionRecordWhereUniqueInput
  }

  export type DecisionRecordCreateNestedManyWithoutSupersedesInput = {
    create?: XOR<DecisionRecordCreateWithoutSupersedesInput, DecisionRecordUncheckedCreateWithoutSupersedesInput> | DecisionRecordCreateWithoutSupersedesInput[] | DecisionRecordUncheckedCreateWithoutSupersedesInput[]
    connectOrCreate?: DecisionRecordCreateOrConnectWithoutSupersedesInput | DecisionRecordCreateOrConnectWithoutSupersedesInput[]
    createMany?: DecisionRecordCreateManySupersedesInputEnvelope
    connect?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
  }

  export type DecisionRecordUncheckedCreateNestedManyWithoutSupersedesInput = {
    create?: XOR<DecisionRecordCreateWithoutSupersedesInput, DecisionRecordUncheckedCreateWithoutSupersedesInput> | DecisionRecordCreateWithoutSupersedesInput[] | DecisionRecordUncheckedCreateWithoutSupersedesInput[]
    connectOrCreate?: DecisionRecordCreateOrConnectWithoutSupersedesInput | DecisionRecordCreateOrConnectWithoutSupersedesInput[]
    createMany?: DecisionRecordCreateManySupersedesInputEnvelope
    connect?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
  }

  export type EnumDecisionStatusFieldUpdateOperationsInput = {
    set?: $Enums.DecisionStatus
  }

  export type DecisionRecordUpdateOneWithoutSupersededByNestedInput = {
    create?: XOR<DecisionRecordCreateWithoutSupersededByInput, DecisionRecordUncheckedCreateWithoutSupersededByInput>
    connectOrCreate?: DecisionRecordCreateOrConnectWithoutSupersededByInput
    upsert?: DecisionRecordUpsertWithoutSupersededByInput
    disconnect?: DecisionRecordWhereInput | boolean
    delete?: DecisionRecordWhereInput | boolean
    connect?: DecisionRecordWhereUniqueInput
    update?: XOR<XOR<DecisionRecordUpdateToOneWithWhereWithoutSupersededByInput, DecisionRecordUpdateWithoutSupersededByInput>, DecisionRecordUncheckedUpdateWithoutSupersededByInput>
  }

  export type DecisionRecordUpdateManyWithoutSupersedesNestedInput = {
    create?: XOR<DecisionRecordCreateWithoutSupersedesInput, DecisionRecordUncheckedCreateWithoutSupersedesInput> | DecisionRecordCreateWithoutSupersedesInput[] | DecisionRecordUncheckedCreateWithoutSupersedesInput[]
    connectOrCreate?: DecisionRecordCreateOrConnectWithoutSupersedesInput | DecisionRecordCreateOrConnectWithoutSupersedesInput[]
    upsert?: DecisionRecordUpsertWithWhereUniqueWithoutSupersedesInput | DecisionRecordUpsertWithWhereUniqueWithoutSupersedesInput[]
    createMany?: DecisionRecordCreateManySupersedesInputEnvelope
    set?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
    disconnect?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
    delete?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
    connect?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
    update?: DecisionRecordUpdateWithWhereUniqueWithoutSupersedesInput | DecisionRecordUpdateWithWhereUniqueWithoutSupersedesInput[]
    updateMany?: DecisionRecordUpdateManyWithWhereWithoutSupersedesInput | DecisionRecordUpdateManyWithWhereWithoutSupersedesInput[]
    deleteMany?: DecisionRecordScalarWhereInput | DecisionRecordScalarWhereInput[]
  }

  export type DecisionRecordUncheckedUpdateManyWithoutSupersedesNestedInput = {
    create?: XOR<DecisionRecordCreateWithoutSupersedesInput, DecisionRecordUncheckedCreateWithoutSupersedesInput> | DecisionRecordCreateWithoutSupersedesInput[] | DecisionRecordUncheckedCreateWithoutSupersedesInput[]
    connectOrCreate?: DecisionRecordCreateOrConnectWithoutSupersedesInput | DecisionRecordCreateOrConnectWithoutSupersedesInput[]
    upsert?: DecisionRecordUpsertWithWhereUniqueWithoutSupersedesInput | DecisionRecordUpsertWithWhereUniqueWithoutSupersedesInput[]
    createMany?: DecisionRecordCreateManySupersedesInputEnvelope
    set?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
    disconnect?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
    delete?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
    connect?: DecisionRecordWhereUniqueInput | DecisionRecordWhereUniqueInput[]
    update?: DecisionRecordUpdateWithWhereUniqueWithoutSupersedesInput | DecisionRecordUpdateWithWhereUniqueWithoutSupersedesInput[]
    updateMany?: DecisionRecordUpdateManyWithWhereWithoutSupersedesInput | DecisionRecordUpdateManyWithWhereWithoutSupersedesInput[]
    deleteMany?: DecisionRecordScalarWhereInput | DecisionRecordScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFinanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinanceType | EnumFinanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinanceType[] | ListEnumFinanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinanceType[] | ListEnumFinanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinanceTypeFilter<$PrismaModel> | $Enums.FinanceType
  }

  export type NestedEnumFeeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeeTypeNullableFilter<$PrismaModel> | $Enums.FeeType | null
  }

  export type NestedEnumFinanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinanceType | EnumFinanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinanceType[] | ListEnumFinanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinanceType[] | ListEnumFinanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinanceTypeFilter<$PrismaModel>
    _max?: NestedEnumFinanceTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FeeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFeeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFeeTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAIActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIActionType | EnumAIActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIActionType[] | ListEnumAIActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIActionType[] | ListEnumAIActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIActionTypeFilter<$PrismaModel> | $Enums.AIActionType
  }

  export type NestedEnumActionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionStatus | EnumActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionStatusFilter<$PrismaModel> | $Enums.ActionStatus
  }

  export type NestedEnumAIActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIActionType | EnumAIActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIActionType[] | ListEnumAIActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIActionType[] | ListEnumAIActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAIActionTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumActionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionStatus | EnumActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionStatusFilter<$PrismaModel>
    _max?: NestedEnumActionStatusFilter<$PrismaModel>
  }

  export type NestedEnumDecisionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionStatus | EnumDecisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionStatus[] | ListEnumDecisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionStatus[] | ListEnumDecisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionStatusFilter<$PrismaModel> | $Enums.DecisionStatus
  }

  export type NestedEnumDecisionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionStatus | EnumDecisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionStatus[] | ListEnumDecisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionStatus[] | ListEnumDecisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionStatusWithAggregatesFilter<$PrismaModel> | $Enums.DecisionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDecisionStatusFilter<$PrismaModel>
    _max?: NestedEnumDecisionStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    application?: ApplicationCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    application?: ApplicationUncheckedCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutSchoolInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    staff?: StaffCreateNestedManyWithoutClassInput
    exams?: ExamCreateNestedManyWithoutClassInput
    subjects?: SubjectCreateNestedManyWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    staff?: StaffUncheckedCreateNestedManyWithoutClassInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassesInput
  }

  export type ClassCreateOrConnectWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassCreateManySchoolInputEnvelope = {
    data: ClassCreateManySchoolInput | ClassCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type BusCreateWithoutSchoolInput = {
    id?: string
    plateNumber: string
    driverName: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusUncheckedCreateWithoutSchoolInput = {
    id?: string
    plateNumber: string
    driverName: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusCreateOrConnectWithoutSchoolInput = {
    where: BusWhereUniqueInput
    create: XOR<BusCreateWithoutSchoolInput, BusUncheckedCreateWithoutSchoolInput>
  }

  export type BusCreateManySchoolInputEnvelope = {
    data: BusCreateManySchoolInput | BusCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type FinanceCreateWithoutSchoolInput = {
    id?: string
    type?: $Enums.FinanceType
    amount: number
    description?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinanceUncheckedCreateWithoutSchoolInput = {
    id?: string
    type?: $Enums.FinanceType
    amount: number
    description?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinanceCreateOrConnectWithoutSchoolInput = {
    where: FinanceWhereUniqueInput
    create: XOR<FinanceCreateWithoutSchoolInput, FinanceUncheckedCreateWithoutSchoolInput>
  }

  export type FinanceCreateManySchoolInputEnvelope = {
    data: FinanceCreateManySchoolInput | FinanceCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutSchoolInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutSchoolInput, ActivityUncheckedCreateWithoutSchoolInput>
  }

  export type ActivityCreateManySchoolInputEnvelope = {
    data: ActivityCreateManySchoolInput | ActivityCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutSchoolInput = {
    id?: string
    name: string
    category?: string | null
    unitPrice: number
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    category?: string | null
    unitPrice: number
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutSchoolInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutSchoolInput, ResourceUncheckedCreateWithoutSchoolInput>
  }

  export type ResourceCreateManySchoolInputEnvelope = {
    data: ResourceCreateManySchoolInput | ResourceCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type BookCreateWithoutSchoolInput = {
    id?: string
    title: string
    isbn: string
    totalCopies?: number
    available?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AuthorCreateNestedOneWithoutBooksInput
    category?: CategoryCreateNestedOneWithoutBooksInput
    borrows?: BorrowCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    isbn: string
    authorId: string
    categoryId?: string | null
    totalCopies?: number
    available?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    borrows?: BorrowUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutSchoolInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutSchoolInput, BookUncheckedCreateWithoutSchoolInput>
  }

  export type BookCreateManySchoolInputEnvelope = {
    data: BookCreateManySchoolInput | BookCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationCreateWithoutSchoolInput = {
    id?: string
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutApplicationInput
    user?: UserCreateNestedOneWithoutApplicationInput
    admissionPayment?: AdmissionPaymentCreateNestedOneWithoutApplicationInput
    previousSchools?: PreviousSchoolCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutApplicationInput
    grade?: GradeCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutSchoolInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    previousSchools?: PreviousSchoolUncheckedCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutSchoolInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutSchoolInput, ApplicationUncheckedCreateWithoutSchoolInput>
  }

  export type ApplicationCreateManySchoolInputEnvelope = {
    data: ApplicationCreateManySchoolInput | ApplicationCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type StaffApplicationCreateWithoutSchoolInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutStaffApplicationInput
    department?: DepartmentCreateNestedOneWithoutStaffApplicationInput
    subjects?: SubjectCreateNestedManyWithoutStaffApplicationsInput
    previousJobs?: PreviousJobCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationUncheckedCreateWithoutSchoolInput = {
    id?: string
    staffId?: string | null
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    departmentId?: string | null
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffApplicationsInput
    previousJobs?: PreviousJobUncheckedCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationCreateOrConnectWithoutSchoolInput = {
    where: StaffApplicationWhereUniqueInput
    create: XOR<StaffApplicationCreateWithoutSchoolInput, StaffApplicationUncheckedCreateWithoutSchoolInput>
  }

  export type StaffApplicationCreateManySchoolInputEnvelope = {
    data: StaffApplicationCreateManySchoolInput | StaffApplicationCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutSchoolInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutSchoolInput = {
    id?: string
    userId: string
    name?: string | null
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentCreateManySchoolInputEnvelope = {
    data: StudentCreateManySchoolInput | StudentCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    surname?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    otherNames?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type BusUpsertWithWhereUniqueWithoutSchoolInput = {
    where: BusWhereUniqueInput
    update: XOR<BusUpdateWithoutSchoolInput, BusUncheckedUpdateWithoutSchoolInput>
    create: XOR<BusCreateWithoutSchoolInput, BusUncheckedCreateWithoutSchoolInput>
  }

  export type BusUpdateWithWhereUniqueWithoutSchoolInput = {
    where: BusWhereUniqueInput
    data: XOR<BusUpdateWithoutSchoolInput, BusUncheckedUpdateWithoutSchoolInput>
  }

  export type BusUpdateManyWithWhereWithoutSchoolInput = {
    where: BusScalarWhereInput
    data: XOR<BusUpdateManyMutationInput, BusUncheckedUpdateManyWithoutSchoolInput>
  }

  export type BusScalarWhereInput = {
    AND?: BusScalarWhereInput | BusScalarWhereInput[]
    OR?: BusScalarWhereInput[]
    NOT?: BusScalarWhereInput | BusScalarWhereInput[]
    id?: StringFilter<"Bus"> | string
    schoolId?: StringFilter<"Bus"> | string
    plateNumber?: StringFilter<"Bus"> | string
    driverName?: StringFilter<"Bus"> | string
    capacity?: IntFilter<"Bus"> | number
    createdAt?: DateTimeFilter<"Bus"> | Date | string
    updatedAt?: DateTimeFilter<"Bus"> | Date | string
  }

  export type FinanceUpsertWithWhereUniqueWithoutSchoolInput = {
    where: FinanceWhereUniqueInput
    update: XOR<FinanceUpdateWithoutSchoolInput, FinanceUncheckedUpdateWithoutSchoolInput>
    create: XOR<FinanceCreateWithoutSchoolInput, FinanceUncheckedCreateWithoutSchoolInput>
  }

  export type FinanceUpdateWithWhereUniqueWithoutSchoolInput = {
    where: FinanceWhereUniqueInput
    data: XOR<FinanceUpdateWithoutSchoolInput, FinanceUncheckedUpdateWithoutSchoolInput>
  }

  export type FinanceUpdateManyWithWhereWithoutSchoolInput = {
    where: FinanceScalarWhereInput
    data: XOR<FinanceUpdateManyMutationInput, FinanceUncheckedUpdateManyWithoutSchoolInput>
  }

  export type FinanceScalarWhereInput = {
    AND?: FinanceScalarWhereInput | FinanceScalarWhereInput[]
    OR?: FinanceScalarWhereInput[]
    NOT?: FinanceScalarWhereInput | FinanceScalarWhereInput[]
    id?: StringFilter<"Finance"> | string
    schoolId?: StringFilter<"Finance"> | string
    type?: EnumFinanceTypeFilter<"Finance"> | $Enums.FinanceType
    amount?: FloatFilter<"Finance"> | number
    description?: StringNullableFilter<"Finance"> | string | null
    date?: DateTimeFilter<"Finance"> | Date | string
    createdAt?: DateTimeFilter<"Finance"> | Date | string
    updatedAt?: DateTimeFilter<"Finance"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutSchoolInput, ActivityUncheckedUpdateWithoutSchoolInput>
    create: XOR<ActivityCreateWithoutSchoolInput, ActivityUncheckedCreateWithoutSchoolInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutSchoolInput, ActivityUncheckedUpdateWithoutSchoolInput>
  }

  export type ActivityUpdateManyWithWhereWithoutSchoolInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    schoolId?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ResourceUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutSchoolInput, ResourceUncheckedUpdateWithoutSchoolInput>
    create: XOR<ResourceCreateWithoutSchoolInput, ResourceUncheckedCreateWithoutSchoolInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutSchoolInput, ResourceUncheckedUpdateWithoutSchoolInput>
  }

  export type ResourceUpdateManyWithWhereWithoutSchoolInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: StringFilter<"Resource"> | string
    name?: StringFilter<"Resource"> | string
    category?: StringNullableFilter<"Resource"> | string | null
    unitPrice?: FloatFilter<"Resource"> | number
    quantity?: IntFilter<"Resource"> | number
    schoolId?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
  }

  export type BookUpsertWithWhereUniqueWithoutSchoolInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutSchoolInput, BookUncheckedUpdateWithoutSchoolInput>
    create: XOR<BookCreateWithoutSchoolInput, BookUncheckedCreateWithoutSchoolInput>
  }

  export type BookUpdateWithWhereUniqueWithoutSchoolInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutSchoolInput, BookUncheckedUpdateWithoutSchoolInput>
  }

  export type BookUpdateManyWithWhereWithoutSchoolInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutSchoolInput>
  }

  export type BookScalarWhereInput = {
    AND?: BookScalarWhereInput | BookScalarWhereInput[]
    OR?: BookScalarWhereInput[]
    NOT?: BookScalarWhereInput | BookScalarWhereInput[]
    id?: StringFilter<"Book"> | string
    title?: StringFilter<"Book"> | string
    isbn?: StringFilter<"Book"> | string
    authorId?: StringFilter<"Book"> | string
    categoryId?: StringNullableFilter<"Book"> | string | null
    totalCopies?: IntFilter<"Book"> | number
    available?: IntFilter<"Book"> | number
    schoolId?: StringFilter<"Book"> | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
  }

  export type ApplicationUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutSchoolInput, ApplicationUncheckedUpdateWithoutSchoolInput>
    create: XOR<ApplicationCreateWithoutSchoolInput, ApplicationUncheckedCreateWithoutSchoolInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutSchoolInput, ApplicationUncheckedUpdateWithoutSchoolInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutSchoolInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    id?: StringFilter<"Application"> | string
    studentId?: StringNullableFilter<"Application"> | string | null
    userId?: StringNullableFilter<"Application"> | string | null
    schoolId?: StringNullableFilter<"Application"> | string | null
    admissionPaymentId?: StringNullableFilter<"Application"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Application"> | Date | string | null
    nationality?: StringNullableFilter<"Application"> | string | null
    sex?: StringNullableFilter<"Application"> | string | null
    languages?: StringNullableListFilter<"Application">
    gradeId?: StringNullableFilter<"Application"> | string | null
    mothersTongue?: StringNullableFilter<"Application"> | string | null
    religion?: StringNullableFilter<"Application"> | string | null
    denomination?: StringNullableFilter<"Application"> | string | null
    hometown?: StringNullableFilter<"Application"> | string | null
    region?: StringNullableFilter<"Application"> | string | null
    profilePicture?: StringNullableFilter<"Application"> | string | null
    wardLivesWith?: StringNullableFilter<"Application"> | string | null
    numberOfSiblings?: IntNullableFilter<"Application"> | number | null
    siblingsOlder?: IntNullableFilter<"Application"> | number | null
    siblingsYounger?: IntNullableFilter<"Application"> | number | null
    postalAddress?: StringNullableFilter<"Application"> | string | null
    residentialAddress?: StringNullableFilter<"Application"> | string | null
    wardMobile?: StringNullableFilter<"Application"> | string | null
    emergencyContact?: StringNullableFilter<"Application"> | string | null
    emergencyMedicalContact?: StringNullableFilter<"Application"> | string | null
    medicalSummary?: StringNullableFilter<"Application"> | string | null
    bloodType?: StringNullableFilter<"Application"> | string | null
    specialDisability?: StringNullableFilter<"Application"> | string | null
    feesAcknowledged?: BoolFilter<"Application"> | boolean
    declarationSigned?: BoolFilter<"Application"> | boolean
    signature?: StringNullableFilter<"Application"> | string | null
    submissionDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    classification?: StringNullableFilter<"Application"> | string | null
    submittedBy?: StringNullableFilter<"Application"> | string | null
    receivedBy?: StringNullableFilter<"Application"> | string | null
    receivedDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    remarks?: StringNullableFilter<"Application"> | string | null
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    progress?: IntFilter<"Application"> | number
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
  }

  export type StaffApplicationUpsertWithWhereUniqueWithoutSchoolInput = {
    where: StaffApplicationWhereUniqueInput
    update: XOR<StaffApplicationUpdateWithoutSchoolInput, StaffApplicationUncheckedUpdateWithoutSchoolInput>
    create: XOR<StaffApplicationCreateWithoutSchoolInput, StaffApplicationUncheckedCreateWithoutSchoolInput>
  }

  export type StaffApplicationUpdateWithWhereUniqueWithoutSchoolInput = {
    where: StaffApplicationWhereUniqueInput
    data: XOR<StaffApplicationUpdateWithoutSchoolInput, StaffApplicationUncheckedUpdateWithoutSchoolInput>
  }

  export type StaffApplicationUpdateManyWithWhereWithoutSchoolInput = {
    where: StaffApplicationScalarWhereInput
    data: XOR<StaffApplicationUpdateManyMutationInput, StaffApplicationUncheckedUpdateManyWithoutSchoolInput>
  }

  export type StaffApplicationScalarWhereInput = {
    AND?: StaffApplicationScalarWhereInput | StaffApplicationScalarWhereInput[]
    OR?: StaffApplicationScalarWhereInput[]
    NOT?: StaffApplicationScalarWhereInput | StaffApplicationScalarWhereInput[]
    id?: StringFilter<"StaffApplication"> | string
    staffId?: StringNullableFilter<"StaffApplication"> | string | null
    schoolId?: StringFilter<"StaffApplication"> | string
    surname?: StringFilter<"StaffApplication"> | string
    firstName?: StringFilter<"StaffApplication"> | string
    otherNames?: StringNullableFilter<"StaffApplication"> | string | null
    dateOfBirth?: DateTimeFilter<"StaffApplication"> | Date | string
    nationality?: StringFilter<"StaffApplication"> | string
    sex?: StringFilter<"StaffApplication"> | string
    languages?: StringNullableListFilter<"StaffApplication">
    maritalStatus?: StringNullableFilter<"StaffApplication"> | string | null
    religion?: StringFilter<"StaffApplication"> | string
    denomination?: StringNullableFilter<"StaffApplication"> | string | null
    hometown?: StringFilter<"StaffApplication"> | string
    region?: StringFilter<"StaffApplication"> | string
    profilePicture?: StringNullableFilter<"StaffApplication"> | string | null
    residentialAddress?: StringFilter<"StaffApplication"> | string
    postalAddress?: StringFilter<"StaffApplication"> | string
    mobile?: StringNullableFilter<"StaffApplication"> | string | null
    email?: StringNullableFilter<"StaffApplication"> | string | null
    emergencyContact?: StringFilter<"StaffApplication"> | string
    nextOfKin?: StringNullableFilter<"StaffApplication"> | string | null
    position?: StringFilter<"StaffApplication"> | string
    departmentId?: StringNullableFilter<"StaffApplication"> | string | null
    hireDate?: DateTimeNullableFilter<"StaffApplication"> | Date | string | null
    salary?: FloatNullableFilter<"StaffApplication"> | number | null
    qualifications?: StringNullableFilter<"StaffApplication"> | string | null
    bloodType?: StringNullableFilter<"StaffApplication"> | string | null
    medicalConditions?: StringNullableFilter<"StaffApplication"> | string | null
    specialDisability?: StringNullableFilter<"StaffApplication"> | string | null
    declarationSigned?: BoolFilter<"StaffApplication"> | boolean
    signature?: StringNullableFilter<"StaffApplication"> | string | null
    submissionDate?: DateTimeFilter<"StaffApplication"> | Date | string
    classification?: StringNullableFilter<"StaffApplication"> | string | null
    submittedBy?: StringNullableFilter<"StaffApplication"> | string | null
    receivedBy?: StringNullableFilter<"StaffApplication"> | string | null
    remarks?: StringNullableFilter<"StaffApplication"> | string | null
    createdAt?: DateTimeFilter<"StaffApplication"> | Date | string
    updatedAt?: DateTimeFilter<"StaffApplication"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
  }

  export type StudentUpdateManyWithWhereWithoutSchoolInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutSchoolInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    name?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    enrolledAt?: DateTimeFilter<"Student"> | Date | string
    classId?: StringNullableFilter<"Student"> | string | null
    gradeId?: StringNullableFilter<"Student"> | string | null
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type StaffCreateWithoutUserInput = {
    id?: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutStaffInput
    grades?: GradeCreateNestedManyWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    subjects?: SubjectCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutUserInput = {
    id?: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStaffInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceUncheckedCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutUserInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
  }

  export type LibraryStaffCreateWithoutUserInput = {
    id?: string
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutLibraryStaffInput
  }

  export type LibraryStaffUncheckedCreateWithoutUserInput = {
    id?: string
    departmentId: string
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryStaffCreateOrConnectWithoutUserInput = {
    where: LibraryStaffWhereUniqueInput
    create: XOR<LibraryStaffCreateWithoutUserInput, LibraryStaffUncheckedCreateWithoutUserInput>
  }

  export type SubjectCreateWithoutCreatedByInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamCreateNestedManyWithoutSubjectInput
    staff?: StaffCreateNestedManyWithoutSubjectsInput
    students?: StudentCreateNestedManyWithoutSubjectsInput
    classes?: ClassCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    staff?: StaffUncheckedCreateNestedManyWithoutSubjectsInput
    students?: StudentUncheckedCreateNestedManyWithoutSubjectsInput
    classes?: ClassUncheckedCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutCreatedByInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput>
  }

  export type SubjectCreateManyCreatedByInputEnvelope = {
    data: SubjectCreateManyCreatedByInput | SubjectCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationCreateWithoutUserInput = {
    id?: string
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutApplicationInput
    school?: SchoolCreateNestedOneWithoutApplicationsInput
    admissionPayment?: AdmissionPaymentCreateNestedOneWithoutApplicationInput
    previousSchools?: PreviousSchoolCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutApplicationInput
    grade?: GradeCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    studentId?: string | null
    schoolId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    previousSchools?: PreviousSchoolUncheckedCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutUserInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
  }

  export type SkuunAiSessionCreateWithoutUserInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SkuunAiMessageCreateNestedManyWithoutSessionInput
    actions?: SkuunAiActionCreateNestedManyWithoutSessionInput
    SkuunAiRecommendation?: SkuunAiRecommendationCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionUncheckedCreateWithoutUserInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SkuunAiMessageUncheckedCreateNestedManyWithoutSessionInput
    actions?: SkuunAiActionUncheckedCreateNestedManyWithoutSessionInput
    SkuunAiRecommendation?: SkuunAiRecommendationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionCreateOrConnectWithoutUserInput = {
    where: SkuunAiSessionWhereUniqueInput
    create: XOR<SkuunAiSessionCreateWithoutUserInput, SkuunAiSessionUncheckedCreateWithoutUserInput>
  }

  export type SkuunAiSessionCreateManyUserInputEnvelope = {
    data: SkuunAiSessionCreateManyUserInput | SkuunAiSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StaffUpsertWithoutUserInput = {
    update: XOR<StaffUpdateWithoutUserInput, StaffUncheckedUpdateWithoutUserInput>
    create: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutUserInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutUserInput, StaffUncheckedUpdateWithoutUserInput>
  }

  export type StaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutStaffNestedInput
    grades?: GradeUpdateManyWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    subjects?: SubjectUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStaffNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUncheckedUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type LibraryStaffUpsertWithoutUserInput = {
    update: XOR<LibraryStaffUpdateWithoutUserInput, LibraryStaffUncheckedUpdateWithoutUserInput>
    create: XOR<LibraryStaffCreateWithoutUserInput, LibraryStaffUncheckedCreateWithoutUserInput>
    where?: LibraryStaffWhereInput
  }

  export type LibraryStaffUpdateToOneWithWhereWithoutUserInput = {
    where?: LibraryStaffWhereInput
    data: XOR<LibraryStaffUpdateWithoutUserInput, LibraryStaffUncheckedUpdateWithoutUserInput>
  }

  export type LibraryStaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutLibraryStaffNestedInput
  }

  export type LibraryStaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutCreatedByInput, SubjectUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutCreatedByInput, SubjectUncheckedUpdateWithoutCreatedByInput>
  }

  export type SubjectUpdateManyWithWhereWithoutCreatedByInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    createdById?: StringNullableFilter<"Subject"> | string | null
  }

  export type ApplicationUpsertWithoutUserInput = {
    update: XOR<ApplicationUpdateWithoutUserInput, ApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutUserInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutUserInput, ApplicationUncheckedUpdateWithoutUserInput>
  }

  export type ApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutApplicationNestedInput
    school?: SchoolUpdateOneWithoutApplicationsNestedInput
    admissionPayment?: AdmissionPaymentUpdateOneWithoutApplicationNestedInput
    previousSchools?: PreviousSchoolUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutApplicationNestedInput
    grade?: GradeUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousSchools?: PreviousSchoolUncheckedUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type SkuunAiSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SkuunAiSessionWhereUniqueInput
    update: XOR<SkuunAiSessionUpdateWithoutUserInput, SkuunAiSessionUncheckedUpdateWithoutUserInput>
    create: XOR<SkuunAiSessionCreateWithoutUserInput, SkuunAiSessionUncheckedCreateWithoutUserInput>
  }

  export type SkuunAiSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SkuunAiSessionWhereUniqueInput
    data: XOR<SkuunAiSessionUpdateWithoutUserInput, SkuunAiSessionUncheckedUpdateWithoutUserInput>
  }

  export type SkuunAiSessionUpdateManyWithWhereWithoutUserInput = {
    where: SkuunAiSessionScalarWhereInput
    data: XOR<SkuunAiSessionUpdateManyMutationInput, SkuunAiSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SkuunAiSessionScalarWhereInput = {
    AND?: SkuunAiSessionScalarWhereInput | SkuunAiSessionScalarWhereInput[]
    OR?: SkuunAiSessionScalarWhereInput[]
    NOT?: SkuunAiSessionScalarWhereInput | SkuunAiSessionScalarWhereInput[]
    id?: StringFilter<"SkuunAiSession"> | string
    userId?: StringFilter<"SkuunAiSession"> | string
    role?: EnumRoleFilter<"SkuunAiSession"> | $Enums.Role
    createdAt?: DateTimeFilter<"SkuunAiSession"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiSession"> | Date | string
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    application?: ApplicationCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    application?: ApplicationUncheckedCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type SchoolCreateWithoutStudentInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutStudentInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutStudentInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutStudentInput, SchoolUncheckedCreateWithoutStudentInput>
  }

  export type SubjectCreateWithoutStudentsInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
    staff?: StaffCreateNestedManyWithoutSubjectsInput
    classes?: ClassCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    staff?: StaffUncheckedCreateNestedManyWithoutSubjectsInput
    classes?: ClassUncheckedCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutStudentsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput>
  }

  export type ApplicationCreateWithoutStudentInput = {
    id?: string
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutApplicationInput
    school?: SchoolCreateNestedOneWithoutApplicationsInput
    admissionPayment?: AdmissionPaymentCreateNestedOneWithoutApplicationInput
    previousSchools?: PreviousSchoolCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutApplicationInput
    grade?: GradeCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutStudentInput = {
    id?: string
    userId?: string | null
    schoolId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    previousSchools?: PreviousSchoolUncheckedCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutStudentInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutStudentInput, ApplicationUncheckedCreateWithoutStudentInput>
  }

  export type ClassCreateWithoutStudentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    grades?: GradeCreateNestedManyWithoutClassInput
    staff?: StaffCreateNestedManyWithoutClassInput
    exams?: ExamCreateNestedManyWithoutClassInput
    subjects?: SubjectCreateNestedManyWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    staff?: StaffUncheckedCreateNestedManyWithoutClassInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassesInput
  }

  export type ClassCreateOrConnectWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type ExamCreateWithoutStudentInput = {
    id?: string
    title: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    classId?: string | null
    subjectId: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateOrConnectWithoutStudentInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutStudentInput, ExamUncheckedCreateWithoutStudentInput>
  }

  export type ExamCreateManyStudentInputEnvelope = {
    data: ExamCreateManyStudentInput | ExamCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAttendanceCreateWithoutStudentInput = {
    id?: string
    classId: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    classId: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceCreateManyStudentInputEnvelope = {
    data: StudentAttendanceCreateManyStudentInput | StudentAttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ParentCreateWithoutStudentInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUncheckedCreateWithoutStudentInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentCreateOrConnectWithoutStudentInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput>
  }

  export type ParentCreateManyStudentInputEnvelope = {
    data: ParentCreateManyStudentInput | ParentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type BorrowCreateWithoutStudentInput = {
    id?: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutBorrowsInput
  }

  export type BorrowUncheckedCreateWithoutStudentInput = {
    id?: string
    bookId: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowCreateOrConnectWithoutStudentInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutStudentInput, BorrowUncheckedCreateWithoutStudentInput>
  }

  export type BorrowCreateManyStudentInputEnvelope = {
    data: BorrowCreateManyStudentInput | BorrowCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutStudentInput = {
    id?: string
    type?: $Enums.FinanceType
    feeType?: $Enums.FeeType | null
    amount: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutStudentInput = {
    id?: string
    type?: $Enums.FinanceType
    feeType?: $Enums.FeeType | null
    amount: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutStudentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutStudentInput, TransactionUncheckedCreateWithoutStudentInput>
  }

  export type TransactionCreateManyStudentInputEnvelope = {
    data: TransactionCreateManyStudentInput | TransactionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutStudentInput = {
    id?: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    resource: ResourceCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutStudentInput = {
    id?: string
    resourceId: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutStudentInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutStudentInput, PurchaseUncheckedCreateWithoutStudentInput>
  }

  export type PurchaseCreateManyStudentInputEnvelope = {
    data: PurchaseCreateManyStudentInput | PurchaseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutStudentsInput = {
    id?: string
    name?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutGradesInput
    staff?: StaffCreateNestedManyWithoutGradesInput
    Application?: ApplicationCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutStudentsInput = {
    id?: string
    name?: string
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutGradesInput
    Application?: ApplicationUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutStudentsInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutStudentsInput, GradeUncheckedCreateWithoutStudentsInput>
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolUpsertWithoutStudentInput = {
    update: XOR<SchoolUpdateWithoutStudentInput, SchoolUncheckedUpdateWithoutStudentInput>
    create: XOR<SchoolCreateWithoutStudentInput, SchoolUncheckedCreateWithoutStudentInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutStudentInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutStudentInput, SchoolUncheckedUpdateWithoutStudentInput>
  }

  export type SchoolUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SubjectUpsertWithWhereUniqueWithoutStudentsInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutStudentsInput, SubjectUncheckedUpdateWithoutStudentsInput>
    create: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutStudentsInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutStudentsInput, SubjectUncheckedUpdateWithoutStudentsInput>
  }

  export type SubjectUpdateManyWithWhereWithoutStudentsInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutStudentsInput>
  }

  export type ApplicationUpsertWithoutStudentInput = {
    update: XOR<ApplicationUpdateWithoutStudentInput, ApplicationUncheckedUpdateWithoutStudentInput>
    create: XOR<ApplicationCreateWithoutStudentInput, ApplicationUncheckedCreateWithoutStudentInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutStudentInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutStudentInput, ApplicationUncheckedUpdateWithoutStudentInput>
  }

  export type ApplicationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutApplicationNestedInput
    school?: SchoolUpdateOneWithoutApplicationsNestedInput
    admissionPayment?: AdmissionPaymentUpdateOneWithoutApplicationNestedInput
    previousSchools?: PreviousSchoolUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutApplicationNestedInput
    grade?: GradeUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousSchools?: PreviousSchoolUncheckedUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ClassUpsertWithoutStudentsInput = {
    update: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    staff?: StaffUpdateManyWithoutClassNestedInput
    exams?: ExamUpdateManyWithoutClassNestedInput
    subjects?: SubjectUpdateManyWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    staff?: StaffUncheckedUpdateManyWithoutClassNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type ExamUpsertWithWhereUniqueWithoutStudentInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutStudentInput, ExamUncheckedUpdateWithoutStudentInput>
    create: XOR<ExamCreateWithoutStudentInput, ExamUncheckedCreateWithoutStudentInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutStudentInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutStudentInput, ExamUncheckedUpdateWithoutStudentInput>
  }

  export type ExamUpdateManyWithWhereWithoutStudentInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutStudentInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    studentId?: StringNullableFilter<"Exam"> | string | null
    classId?: StringNullableFilter<"Exam"> | string | null
    subjectId?: StringFilter<"Exam"> | string
    score?: FloatNullableFilter<"Exam"> | number | null
    maxScore?: FloatNullableFilter<"Exam"> | number | null
    date?: DateTimeFilter<"Exam"> | Date | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAttendanceScalarWhereInput = {
    AND?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    OR?: StudentAttendanceScalarWhereInput[]
    NOT?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    id?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    classId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    timeIn?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    remarks?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
  }

  export type ParentUpsertWithWhereUniqueWithoutStudentInput = {
    where: ParentWhereUniqueInput
    update: XOR<ParentUpdateWithoutStudentInput, ParentUncheckedUpdateWithoutStudentInput>
    create: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput>
  }

  export type ParentUpdateWithWhereUniqueWithoutStudentInput = {
    where: ParentWhereUniqueInput
    data: XOR<ParentUpdateWithoutStudentInput, ParentUncheckedUpdateWithoutStudentInput>
  }

  export type ParentUpdateManyWithWhereWithoutStudentInput = {
    where: ParentScalarWhereInput
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyWithoutStudentInput>
  }

  export type ParentScalarWhereInput = {
    AND?: ParentScalarWhereInput | ParentScalarWhereInput[]
    OR?: ParentScalarWhereInput[]
    NOT?: ParentScalarWhereInput | ParentScalarWhereInput[]
    id?: StringFilter<"Parent"> | string
    studentId?: StringFilter<"Parent"> | string
    name?: StringFilter<"Parent"> | string
    email?: StringFilter<"Parent"> | string
    phone?: StringNullableFilter<"Parent"> | string | null
    profilePicture?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
  }

  export type BorrowUpsertWithWhereUniqueWithoutStudentInput = {
    where: BorrowWhereUniqueInput
    update: XOR<BorrowUpdateWithoutStudentInput, BorrowUncheckedUpdateWithoutStudentInput>
    create: XOR<BorrowCreateWithoutStudentInput, BorrowUncheckedCreateWithoutStudentInput>
  }

  export type BorrowUpdateWithWhereUniqueWithoutStudentInput = {
    where: BorrowWhereUniqueInput
    data: XOR<BorrowUpdateWithoutStudentInput, BorrowUncheckedUpdateWithoutStudentInput>
  }

  export type BorrowUpdateManyWithWhereWithoutStudentInput = {
    where: BorrowScalarWhereInput
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyWithoutStudentInput>
  }

  export type BorrowScalarWhereInput = {
    AND?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
    OR?: BorrowScalarWhereInput[]
    NOT?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
    id?: StringFilter<"Borrow"> | string
    bookId?: StringFilter<"Borrow"> | string
    studentId?: StringFilter<"Borrow"> | string
    borrowedAt?: DateTimeFilter<"Borrow"> | Date | string
    dueAt?: DateTimeFilter<"Borrow"> | Date | string
    returnedAt?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    fine?: FloatFilter<"Borrow"> | number
    createdAt?: DateTimeFilter<"Borrow"> | Date | string
    updatedAt?: DateTimeFilter<"Borrow"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutStudentInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutStudentInput, TransactionUncheckedUpdateWithoutStudentInput>
    create: XOR<TransactionCreateWithoutStudentInput, TransactionUncheckedCreateWithoutStudentInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutStudentInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutStudentInput, TransactionUncheckedUpdateWithoutStudentInput>
  }

  export type TransactionUpdateManyWithWhereWithoutStudentInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutStudentInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    studentId?: StringFilter<"Transaction"> | string
    type?: EnumFinanceTypeFilter<"Transaction"> | $Enums.FinanceType
    feeType?: EnumFeeTypeNullableFilter<"Transaction"> | $Enums.FeeType | null
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutStudentInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutStudentInput, PurchaseUncheckedUpdateWithoutStudentInput>
    create: XOR<PurchaseCreateWithoutStudentInput, PurchaseUncheckedCreateWithoutStudentInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutStudentInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutStudentInput, PurchaseUncheckedUpdateWithoutStudentInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutStudentInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutStudentInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    studentId?: StringFilter<"Purchase"> | string
    resourceId?: StringFilter<"Purchase"> | string
    quantity?: IntFilter<"Purchase"> | number
    totalCost?: FloatFilter<"Purchase"> | number
    date?: DateTimeFilter<"Purchase"> | Date | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type GradeUpsertWithoutStudentsInput = {
    update: XOR<GradeUpdateWithoutStudentsInput, GradeUncheckedUpdateWithoutStudentsInput>
    create: XOR<GradeCreateWithoutStudentsInput, GradeUncheckedCreateWithoutStudentsInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutStudentsInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutStudentsInput, GradeUncheckedUpdateWithoutStudentsInput>
  }

  export type GradeUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutGradesNestedInput
    staff?: StaffUpdateManyWithoutGradesNestedInput
    Application?: ApplicationUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutGradesNestedInput
    Application?: ApplicationUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type SchoolCreateWithoutClassesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
  }

  export type GradeCreateWithoutClassInput = {
    id?: string
    name?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutGradeInput
    staff?: StaffCreateNestedManyWithoutGradesInput
    Application?: ApplicationCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutClassInput = {
    id?: string
    name?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutGradeInput
    staff?: StaffUncheckedCreateNestedManyWithoutGradesInput
    Application?: ApplicationUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutClassInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput>
  }

  export type GradeCreateManyClassInputEnvelope = {
    data: GradeCreateManyClassInput | GradeCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutClassInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentCreateManyClassInputEnvelope = {
    data: StudentCreateManyClassInput | StudentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutClassInput = {
    id?: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffInput
    grades?: GradeCreateNestedManyWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    subjects?: SubjectCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStaffInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceUncheckedCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutClassInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutClassInput, StaffUncheckedCreateWithoutClassInput>
  }

  export type StaffCreateManyClassInputEnvelope = {
    data: StaffCreateManyClassInput | StaffCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutClassInput = {
    id?: string
    title: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutExamInput
    subject: SubjectCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateWithoutClassInput = {
    id?: string
    title: string
    studentId?: string | null
    subjectId: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateOrConnectWithoutClassInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutClassInput, ExamUncheckedCreateWithoutClassInput>
  }

  export type ExamCreateManyClassInputEnvelope = {
    data: ExamCreateManyClassInput | ExamCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutClassesInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
    staff?: StaffCreateNestedManyWithoutSubjectsInput
    students?: StudentCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    staff?: StaffUncheckedCreateNestedManyWithoutSubjectsInput
    students?: StudentUncheckedCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutClassesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
  }

  export type SchoolUpsertWithoutClassesInput = {
    update: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type GradeUpsertWithWhereUniqueWithoutClassInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutClassInput, GradeUncheckedUpdateWithoutClassInput>
    create: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutClassInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutClassInput, GradeUncheckedUpdateWithoutClassInput>
  }

  export type GradeUpdateManyWithWhereWithoutClassInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutClassInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: StringFilter<"Grade"> | string
    name?: StringFilter<"Grade"> | string
    classId?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassInput>
  }

  export type StaffUpsertWithWhereUniqueWithoutClassInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutClassInput, StaffUncheckedUpdateWithoutClassInput>
    create: XOR<StaffCreateWithoutClassInput, StaffUncheckedCreateWithoutClassInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutClassInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutClassInput, StaffUncheckedUpdateWithoutClassInput>
  }

  export type StaffUpdateManyWithWhereWithoutClassInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutClassInput>
  }

  export type StaffScalarWhereInput = {
    AND?: StaffScalarWhereInput | StaffScalarWhereInput[]
    OR?: StaffScalarWhereInput[]
    NOT?: StaffScalarWhereInput | StaffScalarWhereInput[]
    id?: StringFilter<"Staff"> | string
    userId?: StringFilter<"Staff"> | string
    classId?: StringNullableFilter<"Staff"> | string | null
    position?: StringNullableFilter<"Staff"> | string | null
    salary?: FloatNullableFilter<"Staff"> | number | null
    hireDate?: DateTimeNullableFilter<"Staff"> | Date | string | null
    departmentId?: StringNullableFilter<"Staff"> | string | null
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutClassInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutClassInput, ExamUncheckedUpdateWithoutClassInput>
    create: XOR<ExamCreateWithoutClassInput, ExamUncheckedCreateWithoutClassInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutClassInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutClassInput, ExamUncheckedUpdateWithoutClassInput>
  }

  export type ExamUpdateManyWithWhereWithoutClassInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutClassInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutClassesInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutClassesInput, SubjectUncheckedUpdateWithoutClassesInput>
    create: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutClassesInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutClassesInput, SubjectUncheckedUpdateWithoutClassesInput>
  }

  export type SubjectUpdateManyWithWhereWithoutClassesInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutClassesInput>
  }

  export type ClassCreateWithoutGradesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
    staff?: StaffCreateNestedManyWithoutClassInput
    exams?: ExamCreateNestedManyWithoutClassInput
    subjects?: SubjectCreateNestedManyWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutGradesInput = {
    id?: string
    name: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    staff?: StaffUncheckedCreateNestedManyWithoutClassInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassesInput
  }

  export type ClassCreateOrConnectWithoutGradesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutGradesInput, ClassUncheckedCreateWithoutGradesInput>
  }

  export type StudentCreateWithoutGradeInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutGradeInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutGradeInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput>
  }

  export type StudentCreateManyGradeInputEnvelope = {
    data: StudentCreateManyGradeInput | StudentCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutGradesInput = {
    id?: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffInput
    class?: ClassCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    subjects?: SubjectCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutGradesInput = {
    id?: string
    userId: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceUncheckedCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutGradesInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutGradesInput, StaffUncheckedCreateWithoutGradesInput>
  }

  export type ApplicationCreateWithoutGradeInput = {
    id?: string
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutApplicationInput
    user?: UserCreateNestedOneWithoutApplicationInput
    school?: SchoolCreateNestedOneWithoutApplicationsInput
    admissionPayment?: AdmissionPaymentCreateNestedOneWithoutApplicationInput
    previousSchools?: PreviousSchoolCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutGradeInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    schoolId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    previousSchools?: PreviousSchoolUncheckedCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutGradeInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutGradeInput, ApplicationUncheckedCreateWithoutGradeInput>
  }

  export type ApplicationCreateManyGradeInputEnvelope = {
    data: ApplicationCreateManyGradeInput | ApplicationCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutGradesInput = {
    update: XOR<ClassUpdateWithoutGradesInput, ClassUncheckedUpdateWithoutGradesInput>
    create: XOR<ClassCreateWithoutGradesInput, ClassUncheckedCreateWithoutGradesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutGradesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutGradesInput, ClassUncheckedUpdateWithoutGradesInput>
  }

  export type ClassUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    staff?: StaffUpdateManyWithoutClassNestedInput
    exams?: ExamUpdateManyWithoutClassNestedInput
    subjects?: SubjectUpdateManyWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    staff?: StaffUncheckedUpdateManyWithoutClassNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutGradeInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutGradeInput, StudentUncheckedUpdateWithoutGradeInput>
    create: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutGradeInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutGradeInput, StudentUncheckedUpdateWithoutGradeInput>
  }

  export type StudentUpdateManyWithWhereWithoutGradeInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutGradeInput>
  }

  export type StaffUpsertWithWhereUniqueWithoutGradesInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutGradesInput, StaffUncheckedUpdateWithoutGradesInput>
    create: XOR<StaffCreateWithoutGradesInput, StaffUncheckedCreateWithoutGradesInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutGradesInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutGradesInput, StaffUncheckedUpdateWithoutGradesInput>
  }

  export type StaffUpdateManyWithWhereWithoutGradesInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutGradesInput>
  }

  export type ApplicationUpsertWithWhereUniqueWithoutGradeInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutGradeInput, ApplicationUncheckedUpdateWithoutGradeInput>
    create: XOR<ApplicationCreateWithoutGradeInput, ApplicationUncheckedCreateWithoutGradeInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutGradeInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutGradeInput, ApplicationUncheckedUpdateWithoutGradeInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutGradeInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutGradeInput>
  }

  export type UserCreateWithoutCreatedSubjectsInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffCreateNestedOneWithoutUserInput
    application?: ApplicationCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedSubjectsInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedOneWithoutUserInput
    application?: ApplicationUncheckedCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedSubjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSubjectsInput, UserUncheckedCreateWithoutCreatedSubjectsInput>
  }

  export type ExamCreateWithoutSubjectInput = {
    id?: string
    title: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutExamInput
    class?: ClassCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateWithoutSubjectInput = {
    id?: string
    title: string
    studentId?: string | null
    classId?: string | null
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateOrConnectWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput>
  }

  export type ExamCreateManySubjectInputEnvelope = {
    data: ExamCreateManySubjectInput | ExamCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutSubjectsInput = {
    id?: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffInput
    class?: ClassCreateNestedOneWithoutStaffInput
    grades?: GradeCreateNestedManyWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    attendances?: StaffAttendanceCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutSubjectsInput = {
    id?: string
    userId: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceUncheckedCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutSubjectsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutSubjectsInput, StaffUncheckedCreateWithoutSubjectsInput>
  }

  export type StudentCreateWithoutSubjectsInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutSubjectsInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSubjectsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
  }

  export type ClassCreateWithoutSubjectsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    grades?: GradeCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    staff?: StaffCreateNestedManyWithoutClassInput
    exams?: ExamCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    staff?: StaffUncheckedCreateNestedManyWithoutClassInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSubjectsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
  }

  export type StaffApplicationCreateWithoutSubjectsInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutStaffApplicationInput
    school: SchoolCreateNestedOneWithoutStaffApplicationInput
    department?: DepartmentCreateNestedOneWithoutStaffApplicationInput
    previousJobs?: PreviousJobCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationUncheckedCreateWithoutSubjectsInput = {
    id?: string
    staffId?: string | null
    schoolId: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    departmentId?: string | null
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    previousJobs?: PreviousJobUncheckedCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationCreateOrConnectWithoutSubjectsInput = {
    where: StaffApplicationWhereUniqueInput
    create: XOR<StaffApplicationCreateWithoutSubjectsInput, StaffApplicationUncheckedCreateWithoutSubjectsInput>
  }

  export type UserUpsertWithoutCreatedSubjectsInput = {
    update: XOR<UserUpdateWithoutCreatedSubjectsInput, UserUncheckedUpdateWithoutCreatedSubjectsInput>
    create: XOR<UserCreateWithoutCreatedSubjectsInput, UserUncheckedCreateWithoutCreatedSubjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSubjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSubjectsInput, UserUncheckedUpdateWithoutCreatedSubjectsInput>
  }

  export type UserUpdateWithoutCreatedSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUpdateOneWithoutUserNestedInput
    application?: ApplicationUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateOneWithoutUserNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExamUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutSubjectInput, ExamUncheckedUpdateWithoutSubjectInput>
    create: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutSubjectInput, ExamUncheckedUpdateWithoutSubjectInput>
  }

  export type ExamUpdateManyWithWhereWithoutSubjectInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutSubjectInput>
  }

  export type StaffUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutSubjectsInput, StaffUncheckedUpdateWithoutSubjectsInput>
    create: XOR<StaffCreateWithoutSubjectsInput, StaffUncheckedCreateWithoutSubjectsInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutSubjectsInput, StaffUncheckedUpdateWithoutSubjectsInput>
  }

  export type StaffUpdateManyWithWhereWithoutSubjectsInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSubjectsInput, StudentUncheckedUpdateWithoutSubjectsInput>
    create: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSubjectsInput, StudentUncheckedUpdateWithoutSubjectsInput>
  }

  export type StudentUpdateManyWithWhereWithoutSubjectsInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type ClassUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSubjectsInput, ClassUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSubjectsInput, ClassUncheckedUpdateWithoutSubjectsInput>
  }

  export type ClassUpdateManyWithWhereWithoutSubjectsInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type StaffApplicationUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: StaffApplicationWhereUniqueInput
    update: XOR<StaffApplicationUpdateWithoutSubjectsInput, StaffApplicationUncheckedUpdateWithoutSubjectsInput>
    create: XOR<StaffApplicationCreateWithoutSubjectsInput, StaffApplicationUncheckedCreateWithoutSubjectsInput>
  }

  export type StaffApplicationUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: StaffApplicationWhereUniqueInput
    data: XOR<StaffApplicationUpdateWithoutSubjectsInput, StaffApplicationUncheckedUpdateWithoutSubjectsInput>
  }

  export type StaffApplicationUpdateManyWithWhereWithoutSubjectsInput = {
    where: StaffApplicationScalarWhereInput
    data: XOR<StaffApplicationUpdateManyMutationInput, StaffApplicationUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type StudentCreateWithoutExamInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutExamInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutExamInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutExamInput, StudentUncheckedCreateWithoutExamInput>
  }

  export type ClassCreateWithoutExamsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    grades?: GradeCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    staff?: StaffCreateNestedManyWithoutClassInput
    subjects?: SubjectCreateNestedManyWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutExamsInput = {
    id?: string
    name: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    staff?: StaffUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassesInput
  }

  export type ClassCreateOrConnectWithoutExamsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutExamsInput, ClassUncheckedCreateWithoutExamsInput>
  }

  export type SubjectCreateWithoutExamsInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    staff?: StaffCreateNestedManyWithoutSubjectsInput
    students?: StudentCreateNestedManyWithoutSubjectsInput
    classes?: ClassCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutExamsInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    staff?: StaffUncheckedCreateNestedManyWithoutSubjectsInput
    students?: StudentUncheckedCreateNestedManyWithoutSubjectsInput
    classes?: ClassUncheckedCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutExamsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutExamsInput, SubjectUncheckedCreateWithoutExamsInput>
  }

  export type StudentUpsertWithoutExamInput = {
    update: XOR<StudentUpdateWithoutExamInput, StudentUncheckedUpdateWithoutExamInput>
    create: XOR<StudentCreateWithoutExamInput, StudentUncheckedCreateWithoutExamInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutExamInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutExamInput, StudentUncheckedUpdateWithoutExamInput>
  }

  export type StudentUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassUpsertWithoutExamsInput = {
    update: XOR<ClassUpdateWithoutExamsInput, ClassUncheckedUpdateWithoutExamsInput>
    create: XOR<ClassCreateWithoutExamsInput, ClassUncheckedCreateWithoutExamsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutExamsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutExamsInput, ClassUncheckedUpdateWithoutExamsInput>
  }

  export type ClassUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    staff?: StaffUpdateManyWithoutClassNestedInput
    subjects?: SubjectUpdateManyWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    staff?: StaffUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type SubjectUpsertWithoutExamsInput = {
    update: XOR<SubjectUpdateWithoutExamsInput, SubjectUncheckedUpdateWithoutExamsInput>
    create: XOR<SubjectCreateWithoutExamsInput, SubjectUncheckedCreateWithoutExamsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutExamsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutExamsInput, SubjectUncheckedUpdateWithoutExamsInput>
  }

  export type SubjectUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    staff?: StaffUpdateManyWithoutSubjectsNestedInput
    students?: StudentUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: StaffUncheckedUpdateManyWithoutSubjectsNestedInput
    students?: StudentUncheckedUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type StudentCreateWithoutApplicationInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutApplicationInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutApplicationInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutApplicationInput, StudentUncheckedCreateWithoutApplicationInput>
  }

  export type UserCreateWithoutApplicationInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    SkuunAiSession?: SkuunAiSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApplicationInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    SkuunAiSession?: SkuunAiSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApplicationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicationInput, UserUncheckedCreateWithoutApplicationInput>
  }

  export type SchoolCreateWithoutApplicationsInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutApplicationsInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutApplicationsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutApplicationsInput, SchoolUncheckedCreateWithoutApplicationsInput>
  }

  export type AdmissionPaymentCreateWithoutApplicationInput = {
    id?: string
    studentId: string
    schoolId: string
    amount: number
    pinCode: string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionPaymentUncheckedCreateWithoutApplicationInput = {
    id?: string
    studentId: string
    schoolId: string
    amount: number
    pinCode: string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionPaymentCreateOrConnectWithoutApplicationInput = {
    where: AdmissionPaymentWhereUniqueInput
    create: XOR<AdmissionPaymentCreateWithoutApplicationInput, AdmissionPaymentUncheckedCreateWithoutApplicationInput>
  }

  export type PreviousSchoolCreateWithoutApplicationInput = {
    id?: string
    name: string
    location: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousSchoolUncheckedCreateWithoutApplicationInput = {
    id?: string
    name: string
    location: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousSchoolCreateOrConnectWithoutApplicationInput = {
    where: PreviousSchoolWhereUniqueInput
    create: XOR<PreviousSchoolCreateWithoutApplicationInput, PreviousSchoolUncheckedCreateWithoutApplicationInput>
  }

  export type PreviousSchoolCreateManyApplicationInputEnvelope = {
    data: PreviousSchoolCreateManyApplicationInput | PreviousSchoolCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type FamilyMemberCreateWithoutApplicationInput = {
    id?: string
    relation: string
    name: string
    postalAddress: string
    residentialAddress: string
    phone?: string | null
    email?: string | null
    occupation?: string | null
    workplace?: string | null
    religion?: string | null
    isAlive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberUncheckedCreateWithoutApplicationInput = {
    id?: string
    relation: string
    name: string
    postalAddress: string
    residentialAddress: string
    phone?: string | null
    email?: string | null
    occupation?: string | null
    workplace?: string | null
    religion?: string | null
    isAlive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberCreateOrConnectWithoutApplicationInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutApplicationInput, FamilyMemberUncheckedCreateWithoutApplicationInput>
  }

  export type FamilyMemberCreateManyApplicationInputEnvelope = {
    data: FamilyMemberCreateManyApplicationInput | FamilyMemberCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutApplicationInput = {
    id?: string
    name?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutGradesInput
    students?: StudentCreateNestedManyWithoutGradeInput
    staff?: StaffCreateNestedManyWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutApplicationInput = {
    id?: string
    name?: string
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutGradeInput
    staff?: StaffUncheckedCreateNestedManyWithoutGradesInput
  }

  export type GradeCreateOrConnectWithoutApplicationInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutApplicationInput, GradeUncheckedCreateWithoutApplicationInput>
  }

  export type StudentUpsertWithoutApplicationInput = {
    update: XOR<StudentUpdateWithoutApplicationInput, StudentUncheckedUpdateWithoutApplicationInput>
    create: XOR<StudentCreateWithoutApplicationInput, StudentUncheckedCreateWithoutApplicationInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutApplicationInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutApplicationInput, StudentUncheckedUpdateWithoutApplicationInput>
  }

  export type StudentUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserUpsertWithoutApplicationInput = {
    update: XOR<UserUpdateWithoutApplicationInput, UserUncheckedUpdateWithoutApplicationInput>
    create: XOR<UserCreateWithoutApplicationInput, UserUncheckedCreateWithoutApplicationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicationInput, UserUncheckedUpdateWithoutApplicationInput>
  }

  export type UserUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    SkuunAiSession?: SkuunAiSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    SkuunAiSession?: SkuunAiSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolUpsertWithoutApplicationsInput = {
    update: XOR<SchoolUpdateWithoutApplicationsInput, SchoolUncheckedUpdateWithoutApplicationsInput>
    create: XOR<SchoolCreateWithoutApplicationsInput, SchoolUncheckedCreateWithoutApplicationsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutApplicationsInput, SchoolUncheckedUpdateWithoutApplicationsInput>
  }

  export type SchoolUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type AdmissionPaymentUpsertWithoutApplicationInput = {
    update: XOR<AdmissionPaymentUpdateWithoutApplicationInput, AdmissionPaymentUncheckedUpdateWithoutApplicationInput>
    create: XOR<AdmissionPaymentCreateWithoutApplicationInput, AdmissionPaymentUncheckedCreateWithoutApplicationInput>
    where?: AdmissionPaymentWhereInput
  }

  export type AdmissionPaymentUpdateToOneWithWhereWithoutApplicationInput = {
    where?: AdmissionPaymentWhereInput
    data: XOR<AdmissionPaymentUpdateWithoutApplicationInput, AdmissionPaymentUncheckedUpdateWithoutApplicationInput>
  }

  export type AdmissionPaymentUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    pinCode?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionPaymentUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    pinCode?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousSchoolUpsertWithWhereUniqueWithoutApplicationInput = {
    where: PreviousSchoolWhereUniqueInput
    update: XOR<PreviousSchoolUpdateWithoutApplicationInput, PreviousSchoolUncheckedUpdateWithoutApplicationInput>
    create: XOR<PreviousSchoolCreateWithoutApplicationInput, PreviousSchoolUncheckedCreateWithoutApplicationInput>
  }

  export type PreviousSchoolUpdateWithWhereUniqueWithoutApplicationInput = {
    where: PreviousSchoolWhereUniqueInput
    data: XOR<PreviousSchoolUpdateWithoutApplicationInput, PreviousSchoolUncheckedUpdateWithoutApplicationInput>
  }

  export type PreviousSchoolUpdateManyWithWhereWithoutApplicationInput = {
    where: PreviousSchoolScalarWhereInput
    data: XOR<PreviousSchoolUpdateManyMutationInput, PreviousSchoolUncheckedUpdateManyWithoutApplicationInput>
  }

  export type PreviousSchoolScalarWhereInput = {
    AND?: PreviousSchoolScalarWhereInput | PreviousSchoolScalarWhereInput[]
    OR?: PreviousSchoolScalarWhereInput[]
    NOT?: PreviousSchoolScalarWhereInput | PreviousSchoolScalarWhereInput[]
    id?: StringFilter<"PreviousSchool"> | string
    applicationId?: StringFilter<"PreviousSchool"> | string
    name?: StringFilter<"PreviousSchool"> | string
    location?: StringFilter<"PreviousSchool"> | string
    startDate?: DateTimeFilter<"PreviousSchool"> | Date | string
    endDate?: DateTimeFilter<"PreviousSchool"> | Date | string
    createdAt?: DateTimeFilter<"PreviousSchool"> | Date | string
    updatedAt?: DateTimeFilter<"PreviousSchool"> | Date | string
  }

  export type FamilyMemberUpsertWithWhereUniqueWithoutApplicationInput = {
    where: FamilyMemberWhereUniqueInput
    update: XOR<FamilyMemberUpdateWithoutApplicationInput, FamilyMemberUncheckedUpdateWithoutApplicationInput>
    create: XOR<FamilyMemberCreateWithoutApplicationInput, FamilyMemberUncheckedCreateWithoutApplicationInput>
  }

  export type FamilyMemberUpdateWithWhereUniqueWithoutApplicationInput = {
    where: FamilyMemberWhereUniqueInput
    data: XOR<FamilyMemberUpdateWithoutApplicationInput, FamilyMemberUncheckedUpdateWithoutApplicationInput>
  }

  export type FamilyMemberUpdateManyWithWhereWithoutApplicationInput = {
    where: FamilyMemberScalarWhereInput
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyWithoutApplicationInput>
  }

  export type FamilyMemberScalarWhereInput = {
    AND?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
    OR?: FamilyMemberScalarWhereInput[]
    NOT?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
    id?: StringFilter<"FamilyMember"> | string
    applicationId?: StringFilter<"FamilyMember"> | string
    relation?: StringFilter<"FamilyMember"> | string
    name?: StringFilter<"FamilyMember"> | string
    postalAddress?: StringFilter<"FamilyMember"> | string
    residentialAddress?: StringFilter<"FamilyMember"> | string
    phone?: StringNullableFilter<"FamilyMember"> | string | null
    email?: StringNullableFilter<"FamilyMember"> | string | null
    occupation?: StringNullableFilter<"FamilyMember"> | string | null
    workplace?: StringNullableFilter<"FamilyMember"> | string | null
    religion?: StringNullableFilter<"FamilyMember"> | string | null
    isAlive?: BoolFilter<"FamilyMember"> | boolean
    createdAt?: DateTimeFilter<"FamilyMember"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMember"> | Date | string
  }

  export type GradeUpsertWithoutApplicationInput = {
    update: XOR<GradeUpdateWithoutApplicationInput, GradeUncheckedUpdateWithoutApplicationInput>
    create: XOR<GradeCreateWithoutApplicationInput, GradeUncheckedCreateWithoutApplicationInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutApplicationInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutApplicationInput, GradeUncheckedUpdateWithoutApplicationInput>
  }

  export type GradeUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutGradesNestedInput
    students?: StudentUpdateManyWithoutGradeNestedInput
    staff?: StaffUpdateManyWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutGradeNestedInput
    staff?: StaffUncheckedUpdateManyWithoutGradesNestedInput
  }

  export type ApplicationCreateWithoutPreviousSchoolsInput = {
    id?: string
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutApplicationInput
    user?: UserCreateNestedOneWithoutApplicationInput
    school?: SchoolCreateNestedOneWithoutApplicationsInput
    admissionPayment?: AdmissionPaymentCreateNestedOneWithoutApplicationInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutApplicationInput
    grade?: GradeCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutPreviousSchoolsInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    schoolId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutPreviousSchoolsInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutPreviousSchoolsInput, ApplicationUncheckedCreateWithoutPreviousSchoolsInput>
  }

  export type ApplicationUpsertWithoutPreviousSchoolsInput = {
    update: XOR<ApplicationUpdateWithoutPreviousSchoolsInput, ApplicationUncheckedUpdateWithoutPreviousSchoolsInput>
    create: XOR<ApplicationCreateWithoutPreviousSchoolsInput, ApplicationUncheckedCreateWithoutPreviousSchoolsInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutPreviousSchoolsInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutPreviousSchoolsInput, ApplicationUncheckedUpdateWithoutPreviousSchoolsInput>
  }

  export type ApplicationUpdateWithoutPreviousSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutApplicationNestedInput
    user?: UserUpdateOneWithoutApplicationNestedInput
    school?: SchoolUpdateOneWithoutApplicationsNestedInput
    admissionPayment?: AdmissionPaymentUpdateOneWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutApplicationNestedInput
    grade?: GradeUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutPreviousSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationCreateWithoutFamilyMembersInput = {
    id?: string
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutApplicationInput
    user?: UserCreateNestedOneWithoutApplicationInput
    school?: SchoolCreateNestedOneWithoutApplicationsInput
    admissionPayment?: AdmissionPaymentCreateNestedOneWithoutApplicationInput
    previousSchools?: PreviousSchoolCreateNestedManyWithoutApplicationInput
    grade?: GradeCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutFamilyMembersInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    schoolId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    previousSchools?: PreviousSchoolUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutFamilyMembersInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutFamilyMembersInput, ApplicationUncheckedCreateWithoutFamilyMembersInput>
  }

  export type ApplicationUpsertWithoutFamilyMembersInput = {
    update: XOR<ApplicationUpdateWithoutFamilyMembersInput, ApplicationUncheckedUpdateWithoutFamilyMembersInput>
    create: XOR<ApplicationCreateWithoutFamilyMembersInput, ApplicationUncheckedCreateWithoutFamilyMembersInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutFamilyMembersInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutFamilyMembersInput, ApplicationUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type ApplicationUpdateWithoutFamilyMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutApplicationNestedInput
    user?: UserUpdateOneWithoutApplicationNestedInput
    school?: SchoolUpdateOneWithoutApplicationsNestedInput
    admissionPayment?: AdmissionPaymentUpdateOneWithoutApplicationNestedInput
    previousSchools?: PreviousSchoolUpdateManyWithoutApplicationNestedInput
    grade?: GradeUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutFamilyMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousSchools?: PreviousSchoolUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type StaffCreateWithoutStaffApplicationInput = {
    id?: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffInput
    class?: ClassCreateNestedOneWithoutStaffInput
    grades?: GradeCreateNestedManyWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    subjects?: SubjectCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutStaffApplicationInput = {
    id?: string
    userId: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStaffInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutStaffApplicationInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutStaffApplicationInput, StaffUncheckedCreateWithoutStaffApplicationInput>
  }

  export type SchoolCreateWithoutStaffApplicationInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutStaffApplicationInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutStaffApplicationInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutStaffApplicationInput, SchoolUncheckedCreateWithoutStaffApplicationInput>
  }

  export type DepartmentCreateWithoutStaffApplicationInput = {
    id?: string
    name: string
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    LibraryStaff?: LibraryStaffCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutStaffApplicationInput = {
    id?: string
    name: string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutStaffApplicationInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutStaffApplicationInput, DepartmentUncheckedCreateWithoutStaffApplicationInput>
  }

  export type SubjectCreateWithoutStaffApplicationsInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
    staff?: StaffCreateNestedManyWithoutSubjectsInput
    students?: StudentCreateNestedManyWithoutSubjectsInput
    classes?: ClassCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutStaffApplicationsInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    staff?: StaffUncheckedCreateNestedManyWithoutSubjectsInput
    students?: StudentUncheckedCreateNestedManyWithoutSubjectsInput
    classes?: ClassUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutStaffApplicationsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutStaffApplicationsInput, SubjectUncheckedCreateWithoutStaffApplicationsInput>
  }

  export type PreviousJobCreateWithoutStaffApplicationInput = {
    id?: string
    company: string
    role: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousJobUncheckedCreateWithoutStaffApplicationInput = {
    id?: string
    company: string
    role: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousJobCreateOrConnectWithoutStaffApplicationInput = {
    where: PreviousJobWhereUniqueInput
    create: XOR<PreviousJobCreateWithoutStaffApplicationInput, PreviousJobUncheckedCreateWithoutStaffApplicationInput>
  }

  export type PreviousJobCreateManyStaffApplicationInputEnvelope = {
    data: PreviousJobCreateManyStaffApplicationInput | PreviousJobCreateManyStaffApplicationInput[]
    skipDuplicates?: boolean
  }

  export type StaffUpsertWithoutStaffApplicationInput = {
    update: XOR<StaffUpdateWithoutStaffApplicationInput, StaffUncheckedUpdateWithoutStaffApplicationInput>
    create: XOR<StaffCreateWithoutStaffApplicationInput, StaffUncheckedCreateWithoutStaffApplicationInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutStaffApplicationInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutStaffApplicationInput, StaffUncheckedUpdateWithoutStaffApplicationInput>
  }

  export type StaffUpdateWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
    class?: ClassUpdateOneWithoutStaffNestedInput
    grades?: GradeUpdateManyWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    subjects?: SubjectUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStaffNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type SchoolUpsertWithoutStaffApplicationInput = {
    update: XOR<SchoolUpdateWithoutStaffApplicationInput, SchoolUncheckedUpdateWithoutStaffApplicationInput>
    create: XOR<SchoolCreateWithoutStaffApplicationInput, SchoolUncheckedCreateWithoutStaffApplicationInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutStaffApplicationInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutStaffApplicationInput, SchoolUncheckedUpdateWithoutStaffApplicationInput>
  }

  export type SchoolUpdateWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type DepartmentUpsertWithoutStaffApplicationInput = {
    update: XOR<DepartmentUpdateWithoutStaffApplicationInput, DepartmentUncheckedUpdateWithoutStaffApplicationInput>
    create: XOR<DepartmentCreateWithoutStaffApplicationInput, DepartmentUncheckedCreateWithoutStaffApplicationInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutStaffApplicationInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutStaffApplicationInput, DepartmentUncheckedUpdateWithoutStaffApplicationInput>
  }

  export type DepartmentUpdateWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    LibraryStaff?: LibraryStaffUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type SubjectUpsertWithWhereUniqueWithoutStaffApplicationsInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutStaffApplicationsInput, SubjectUncheckedUpdateWithoutStaffApplicationsInput>
    create: XOR<SubjectCreateWithoutStaffApplicationsInput, SubjectUncheckedCreateWithoutStaffApplicationsInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutStaffApplicationsInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutStaffApplicationsInput, SubjectUncheckedUpdateWithoutStaffApplicationsInput>
  }

  export type SubjectUpdateManyWithWhereWithoutStaffApplicationsInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutStaffApplicationsInput>
  }

  export type PreviousJobUpsertWithWhereUniqueWithoutStaffApplicationInput = {
    where: PreviousJobWhereUniqueInput
    update: XOR<PreviousJobUpdateWithoutStaffApplicationInput, PreviousJobUncheckedUpdateWithoutStaffApplicationInput>
    create: XOR<PreviousJobCreateWithoutStaffApplicationInput, PreviousJobUncheckedCreateWithoutStaffApplicationInput>
  }

  export type PreviousJobUpdateWithWhereUniqueWithoutStaffApplicationInput = {
    where: PreviousJobWhereUniqueInput
    data: XOR<PreviousJobUpdateWithoutStaffApplicationInput, PreviousJobUncheckedUpdateWithoutStaffApplicationInput>
  }

  export type PreviousJobUpdateManyWithWhereWithoutStaffApplicationInput = {
    where: PreviousJobScalarWhereInput
    data: XOR<PreviousJobUpdateManyMutationInput, PreviousJobUncheckedUpdateManyWithoutStaffApplicationInput>
  }

  export type PreviousJobScalarWhereInput = {
    AND?: PreviousJobScalarWhereInput | PreviousJobScalarWhereInput[]
    OR?: PreviousJobScalarWhereInput[]
    NOT?: PreviousJobScalarWhereInput | PreviousJobScalarWhereInput[]
    id?: StringFilter<"PreviousJob"> | string
    staffApplicationId?: StringFilter<"PreviousJob"> | string
    company?: StringFilter<"PreviousJob"> | string
    role?: StringFilter<"PreviousJob"> | string
    startDate?: DateTimeFilter<"PreviousJob"> | Date | string
    endDate?: DateTimeNullableFilter<"PreviousJob"> | Date | string | null
    createdAt?: DateTimeFilter<"PreviousJob"> | Date | string
    updatedAt?: DateTimeFilter<"PreviousJob"> | Date | string
  }

  export type StaffApplicationCreateWithoutPreviousJobsInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutStaffApplicationInput
    school: SchoolCreateNestedOneWithoutStaffApplicationInput
    department?: DepartmentCreateNestedOneWithoutStaffApplicationInput
    subjects?: SubjectCreateNestedManyWithoutStaffApplicationsInput
  }

  export type StaffApplicationUncheckedCreateWithoutPreviousJobsInput = {
    id?: string
    staffId?: string | null
    schoolId: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    departmentId?: string | null
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffApplicationsInput
  }

  export type StaffApplicationCreateOrConnectWithoutPreviousJobsInput = {
    where: StaffApplicationWhereUniqueInput
    create: XOR<StaffApplicationCreateWithoutPreviousJobsInput, StaffApplicationUncheckedCreateWithoutPreviousJobsInput>
  }

  export type StaffApplicationUpsertWithoutPreviousJobsInput = {
    update: XOR<StaffApplicationUpdateWithoutPreviousJobsInput, StaffApplicationUncheckedUpdateWithoutPreviousJobsInput>
    create: XOR<StaffApplicationCreateWithoutPreviousJobsInput, StaffApplicationUncheckedCreateWithoutPreviousJobsInput>
    where?: StaffApplicationWhereInput
  }

  export type StaffApplicationUpdateToOneWithWhereWithoutPreviousJobsInput = {
    where?: StaffApplicationWhereInput
    data: XOR<StaffApplicationUpdateWithoutPreviousJobsInput, StaffApplicationUncheckedUpdateWithoutPreviousJobsInput>
  }

  export type StaffApplicationUpdateWithoutPreviousJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutStaffApplicationNestedInput
    school?: SchoolUpdateOneRequiredWithoutStaffApplicationNestedInput
    department?: DepartmentUpdateOneWithoutStaffApplicationNestedInput
    subjects?: SubjectUpdateManyWithoutStaffApplicationsNestedInput
  }

  export type StaffApplicationUncheckedUpdateWithoutPreviousJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutStaffApplicationsNestedInput
  }

  export type UserCreateWithoutStaffInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    application?: ApplicationCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaffInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    application?: ApplicationUncheckedCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
  }

  export type ClassCreateWithoutStaffInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    grades?: GradeCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    exams?: ExamCreateNestedManyWithoutClassInput
    subjects?: SubjectCreateNestedManyWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassesInput
  }

  export type ClassCreateOrConnectWithoutStaffInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStaffInput, ClassUncheckedCreateWithoutStaffInput>
  }

  export type GradeCreateWithoutStaffInput = {
    id?: string
    name?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutGradesInput
    students?: StudentCreateNestedManyWithoutGradeInput
    Application?: ApplicationCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutStaffInput = {
    id?: string
    name?: string
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutGradeInput
    Application?: ApplicationUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutStaffInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutStaffInput, GradeUncheckedCreateWithoutStaffInput>
  }

  export type DepartmentCreateWithoutStaffInput = {
    id?: string
    name: string
    LibraryStaff?: LibraryStaffCreateNestedManyWithoutDepartmentInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    LibraryStaff?: LibraryStaffUncheckedCreateNestedManyWithoutDepartmentInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutStaffInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
  }

  export type SubjectCreateWithoutStaffInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
    students?: StudentCreateNestedManyWithoutSubjectsInput
    classes?: ClassCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    students?: StudentUncheckedCreateNestedManyWithoutSubjectsInput
    classes?: ClassUncheckedCreateNestedManyWithoutSubjectsInput
    staffApplications?: StaffApplicationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutStaffInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutStaffInput, SubjectUncheckedCreateWithoutStaffInput>
  }

  export type StaffAttendanceCreateWithoutStaffInput = {
    id?: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffAttendanceUncheckedCreateWithoutStaffInput = {
    id?: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffAttendanceCreateOrConnectWithoutStaffInput = {
    where: StaffAttendanceWhereUniqueInput
    create: XOR<StaffAttendanceCreateWithoutStaffInput, StaffAttendanceUncheckedCreateWithoutStaffInput>
  }

  export type StaffAttendanceCreateManyStaffInputEnvelope = {
    data: StaffAttendanceCreateManyStaffInput | StaffAttendanceCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type StaffApplicationCreateWithoutStaffInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStaffApplicationInput
    department?: DepartmentCreateNestedOneWithoutStaffApplicationInput
    subjects?: SubjectCreateNestedManyWithoutStaffApplicationsInput
    previousJobs?: PreviousJobCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationUncheckedCreateWithoutStaffInput = {
    id?: string
    schoolId: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    departmentId?: string | null
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffApplicationsInput
    previousJobs?: PreviousJobUncheckedCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationCreateOrConnectWithoutStaffInput = {
    where: StaffApplicationWhereUniqueInput
    create: XOR<StaffApplicationCreateWithoutStaffInput, StaffApplicationUncheckedCreateWithoutStaffInput>
  }

  export type UserUpsertWithoutStaffInput = {
    update: XOR<UserUpdateWithoutStaffInput, UserUncheckedUpdateWithoutStaffInput>
    create: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffInput, UserUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassUpsertWithoutStaffInput = {
    update: XOR<ClassUpdateWithoutStaffInput, ClassUncheckedUpdateWithoutStaffInput>
    create: XOR<ClassCreateWithoutStaffInput, ClassUncheckedCreateWithoutStaffInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStaffInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStaffInput, ClassUncheckedUpdateWithoutStaffInput>
  }

  export type ClassUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    exams?: ExamUpdateManyWithoutClassNestedInput
    subjects?: SubjectUpdateManyWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type GradeUpsertWithWhereUniqueWithoutStaffInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutStaffInput, GradeUncheckedUpdateWithoutStaffInput>
    create: XOR<GradeCreateWithoutStaffInput, GradeUncheckedCreateWithoutStaffInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutStaffInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutStaffInput, GradeUncheckedUpdateWithoutStaffInput>
  }

  export type GradeUpdateManyWithWhereWithoutStaffInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutStaffInput>
  }

  export type DepartmentUpsertWithoutStaffInput = {
    update: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutStaffInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    LibraryStaff?: LibraryStaffUpdateManyWithoutDepartmentNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    LibraryStaff?: LibraryStaffUncheckedUpdateManyWithoutDepartmentNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type SubjectUpsertWithWhereUniqueWithoutStaffInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutStaffInput, SubjectUncheckedUpdateWithoutStaffInput>
    create: XOR<SubjectCreateWithoutStaffInput, SubjectUncheckedCreateWithoutStaffInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutStaffInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutStaffInput, SubjectUncheckedUpdateWithoutStaffInput>
  }

  export type SubjectUpdateManyWithWhereWithoutStaffInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutStaffInput>
  }

  export type StaffAttendanceUpsertWithWhereUniqueWithoutStaffInput = {
    where: StaffAttendanceWhereUniqueInput
    update: XOR<StaffAttendanceUpdateWithoutStaffInput, StaffAttendanceUncheckedUpdateWithoutStaffInput>
    create: XOR<StaffAttendanceCreateWithoutStaffInput, StaffAttendanceUncheckedCreateWithoutStaffInput>
  }

  export type StaffAttendanceUpdateWithWhereUniqueWithoutStaffInput = {
    where: StaffAttendanceWhereUniqueInput
    data: XOR<StaffAttendanceUpdateWithoutStaffInput, StaffAttendanceUncheckedUpdateWithoutStaffInput>
  }

  export type StaffAttendanceUpdateManyWithWhereWithoutStaffInput = {
    where: StaffAttendanceScalarWhereInput
    data: XOR<StaffAttendanceUpdateManyMutationInput, StaffAttendanceUncheckedUpdateManyWithoutStaffInput>
  }

  export type StaffAttendanceScalarWhereInput = {
    AND?: StaffAttendanceScalarWhereInput | StaffAttendanceScalarWhereInput[]
    OR?: StaffAttendanceScalarWhereInput[]
    NOT?: StaffAttendanceScalarWhereInput | StaffAttendanceScalarWhereInput[]
    id?: StringFilter<"StaffAttendance"> | string
    staffId?: StringFilter<"StaffAttendance"> | string
    date?: DateTimeFilter<"StaffAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StaffAttendance"> | $Enums.AttendanceStatus
    timeIn?: DateTimeNullableFilter<"StaffAttendance"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"StaffAttendance"> | Date | string | null
    remarks?: StringNullableFilter<"StaffAttendance"> | string | null
    createdAt?: DateTimeFilter<"StaffAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StaffAttendance"> | Date | string
  }

  export type StaffApplicationUpsertWithoutStaffInput = {
    update: XOR<StaffApplicationUpdateWithoutStaffInput, StaffApplicationUncheckedUpdateWithoutStaffInput>
    create: XOR<StaffApplicationCreateWithoutStaffInput, StaffApplicationUncheckedCreateWithoutStaffInput>
    where?: StaffApplicationWhereInput
  }

  export type StaffApplicationUpdateToOneWithWhereWithoutStaffInput = {
    where?: StaffApplicationWhereInput
    data: XOR<StaffApplicationUpdateWithoutStaffInput, StaffApplicationUncheckedUpdateWithoutStaffInput>
  }

  export type StaffApplicationUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStaffApplicationNestedInput
    department?: DepartmentUpdateOneWithoutStaffApplicationNestedInput
    subjects?: SubjectUpdateManyWithoutStaffApplicationsNestedInput
    previousJobs?: PreviousJobUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutStaffApplicationsNestedInput
    previousJobs?: PreviousJobUncheckedUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffCreateWithoutDepartmentInput = {
    id?: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffInput
    class?: ClassCreateNestedOneWithoutStaffInput
    grades?: GradeCreateNestedManyWithoutStaffInput
    subjects?: SubjectCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStaffInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffInput
    attendances?: StaffAttendanceUncheckedCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffCreateManyDepartmentInputEnvelope = {
    data: StaffCreateManyDepartmentInput | StaffCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type LibraryStaffCreateWithoutDepartmentInput = {
    id?: string
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLibraryStaffInput
  }

  export type LibraryStaffUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryStaffCreateOrConnectWithoutDepartmentInput = {
    where: LibraryStaffWhereUniqueInput
    create: XOR<LibraryStaffCreateWithoutDepartmentInput, LibraryStaffUncheckedCreateWithoutDepartmentInput>
  }

  export type LibraryStaffCreateManyDepartmentInputEnvelope = {
    data: LibraryStaffCreateManyDepartmentInput | LibraryStaffCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type StaffApplicationCreateWithoutDepartmentInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutStaffApplicationInput
    school: SchoolCreateNestedOneWithoutStaffApplicationInput
    subjects?: SubjectCreateNestedManyWithoutStaffApplicationsInput
    previousJobs?: PreviousJobCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationUncheckedCreateWithoutDepartmentInput = {
    id?: string
    staffId?: string | null
    schoolId: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffApplicationsInput
    previousJobs?: PreviousJobUncheckedCreateNestedManyWithoutStaffApplicationInput
  }

  export type StaffApplicationCreateOrConnectWithoutDepartmentInput = {
    where: StaffApplicationWhereUniqueInput
    create: XOR<StaffApplicationCreateWithoutDepartmentInput, StaffApplicationUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffApplicationCreateManyDepartmentInputEnvelope = {
    data: StaffApplicationCreateManyDepartmentInput | StaffApplicationCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type StaffUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutDepartmentInput, StaffUncheckedUpdateWithoutDepartmentInput>
    create: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutDepartmentInput, StaffUncheckedUpdateWithoutDepartmentInput>
  }

  export type StaffUpdateManyWithWhereWithoutDepartmentInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type LibraryStaffUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: LibraryStaffWhereUniqueInput
    update: XOR<LibraryStaffUpdateWithoutDepartmentInput, LibraryStaffUncheckedUpdateWithoutDepartmentInput>
    create: XOR<LibraryStaffCreateWithoutDepartmentInput, LibraryStaffUncheckedCreateWithoutDepartmentInput>
  }

  export type LibraryStaffUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: LibraryStaffWhereUniqueInput
    data: XOR<LibraryStaffUpdateWithoutDepartmentInput, LibraryStaffUncheckedUpdateWithoutDepartmentInput>
  }

  export type LibraryStaffUpdateManyWithWhereWithoutDepartmentInput = {
    where: LibraryStaffScalarWhereInput
    data: XOR<LibraryStaffUpdateManyMutationInput, LibraryStaffUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type LibraryStaffScalarWhereInput = {
    AND?: LibraryStaffScalarWhereInput | LibraryStaffScalarWhereInput[]
    OR?: LibraryStaffScalarWhereInput[]
    NOT?: LibraryStaffScalarWhereInput | LibraryStaffScalarWhereInput[]
    id?: StringFilter<"LibraryStaff"> | string
    userId?: StringFilter<"LibraryStaff"> | string
    departmentId?: StringFilter<"LibraryStaff"> | string
    position?: StringNullableFilter<"LibraryStaff"> | string | null
    hireDate?: DateTimeNullableFilter<"LibraryStaff"> | Date | string | null
    createdAt?: DateTimeFilter<"LibraryStaff"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryStaff"> | Date | string
  }

  export type StaffApplicationUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: StaffApplicationWhereUniqueInput
    update: XOR<StaffApplicationUpdateWithoutDepartmentInput, StaffApplicationUncheckedUpdateWithoutDepartmentInput>
    create: XOR<StaffApplicationCreateWithoutDepartmentInput, StaffApplicationUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffApplicationUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: StaffApplicationWhereUniqueInput
    data: XOR<StaffApplicationUpdateWithoutDepartmentInput, StaffApplicationUncheckedUpdateWithoutDepartmentInput>
  }

  export type StaffApplicationUpdateManyWithWhereWithoutDepartmentInput = {
    where: StaffApplicationScalarWhereInput
    data: XOR<StaffApplicationUpdateManyMutationInput, StaffApplicationUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type StudentCreateWithoutStudentAttendanceInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutStudentAttendanceInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentAttendanceInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentAttendanceInput, StudentUncheckedCreateWithoutStudentAttendanceInput>
  }

  export type StudentUpsertWithoutStudentAttendanceInput = {
    update: XOR<StudentUpdateWithoutStudentAttendanceInput, StudentUncheckedUpdateWithoutStudentAttendanceInput>
    create: XOR<StudentCreateWithoutStudentAttendanceInput, StudentUncheckedCreateWithoutStudentAttendanceInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentAttendanceInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentAttendanceInput, StudentUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type StudentUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StaffCreateWithoutAttendancesInput = {
    id?: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffInput
    class?: ClassCreateNestedOneWithoutStaffInput
    grades?: GradeCreateNestedManyWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    subjects?: SubjectCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutAttendancesInput = {
    id?: string
    userId: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStaffInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutStaffInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutAttendancesInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutAttendancesInput, StaffUncheckedCreateWithoutAttendancesInput>
  }

  export type StaffUpsertWithoutAttendancesInput = {
    update: XOR<StaffUpdateWithoutAttendancesInput, StaffUncheckedUpdateWithoutAttendancesInput>
    create: XOR<StaffCreateWithoutAttendancesInput, StaffUncheckedCreateWithoutAttendancesInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutAttendancesInput, StaffUncheckedUpdateWithoutAttendancesInput>
  }

  export type StaffUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
    class?: ClassUpdateOneWithoutStaffNestedInput
    grades?: GradeUpdateManyWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    subjects?: SubjectUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStaffNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StudentCreateWithoutParentInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutParentInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput>
  }

  export type StudentUpsertWithoutParentInput = {
    update: XOR<StudentUpdateWithoutParentInput, StudentUncheckedUpdateWithoutParentInput>
    create: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentInput, StudentUncheckedUpdateWithoutParentInput>
  }

  export type StudentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type BookCreateWithoutAuthorInput = {
    id?: string
    title: string
    isbn: string
    totalCopies?: number
    available?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutBooksInput
    school: SchoolCreateNestedOneWithoutBookInput
    borrows?: BorrowCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    isbn: string
    categoryId?: string | null
    totalCopies?: number
    available?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrows?: BorrowUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutAuthorInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutAuthorInput, BookUncheckedCreateWithoutAuthorInput>
  }

  export type BookCreateManyAuthorInputEnvelope = {
    data: BookCreateManyAuthorInput | BookCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type BookUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutAuthorInput, BookUncheckedUpdateWithoutAuthorInput>
    create: XOR<BookCreateWithoutAuthorInput, BookUncheckedCreateWithoutAuthorInput>
  }

  export type BookUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutAuthorInput, BookUncheckedUpdateWithoutAuthorInput>
  }

  export type BookUpdateManyWithWhereWithoutAuthorInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BookCreateWithoutCategoryInput = {
    id?: string
    title: string
    isbn: string
    totalCopies?: number
    available?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AuthorCreateNestedOneWithoutBooksInput
    school: SchoolCreateNestedOneWithoutBookInput
    borrows?: BorrowCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    isbn: string
    authorId: string
    totalCopies?: number
    available?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrows?: BorrowUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutCategoryInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutCategoryInput, BookUncheckedCreateWithoutCategoryInput>
  }

  export type BookCreateManyCategoryInputEnvelope = {
    data: BookCreateManyCategoryInput | BookCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BookUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutCategoryInput, BookUncheckedUpdateWithoutCategoryInput>
    create: XOR<BookCreateWithoutCategoryInput, BookUncheckedCreateWithoutCategoryInput>
  }

  export type BookUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutCategoryInput, BookUncheckedUpdateWithoutCategoryInput>
  }

  export type BookUpdateManyWithWhereWithoutCategoryInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutCategoryInput>
  }

  export type AuthorCreateWithoutBooksInput = {
    id?: string
    name: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUncheckedCreateWithoutBooksInput = {
    id?: string
    name: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorCreateOrConnectWithoutBooksInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutBooksInput, AuthorUncheckedCreateWithoutBooksInput>
  }

  export type CategoryCreateWithoutBooksInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutBooksInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutBooksInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
  }

  export type SchoolCreateWithoutBookInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutBookInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutBookInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutBookInput, SchoolUncheckedCreateWithoutBookInput>
  }

  export type BorrowCreateWithoutBookInput = {
    id?: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutBorrowInput
  }

  export type BorrowUncheckedCreateWithoutBookInput = {
    id?: string
    studentId: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowCreateOrConnectWithoutBookInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutBookInput, BorrowUncheckedCreateWithoutBookInput>
  }

  export type BorrowCreateManyBookInputEnvelope = {
    data: BorrowCreateManyBookInput | BorrowCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type AuthorUpsertWithoutBooksInput = {
    update: XOR<AuthorUpdateWithoutBooksInput, AuthorUncheckedUpdateWithoutBooksInput>
    create: XOR<AuthorCreateWithoutBooksInput, AuthorUncheckedCreateWithoutBooksInput>
    where?: AuthorWhereInput
  }

  export type AuthorUpdateToOneWithWhereWithoutBooksInput = {
    where?: AuthorWhereInput
    data: XOR<AuthorUpdateWithoutBooksInput, AuthorUncheckedUpdateWithoutBooksInput>
  }

  export type AuthorUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutBooksInput = {
    update: XOR<CategoryUpdateWithoutBooksInput, CategoryUncheckedUpdateWithoutBooksInput>
    create: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutBooksInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutBooksInput, CategoryUncheckedUpdateWithoutBooksInput>
  }

  export type CategoryUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpsertWithoutBookInput = {
    update: XOR<SchoolUpdateWithoutBookInput, SchoolUncheckedUpdateWithoutBookInput>
    create: XOR<SchoolCreateWithoutBookInput, SchoolUncheckedCreateWithoutBookInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutBookInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutBookInput, SchoolUncheckedUpdateWithoutBookInput>
  }

  export type SchoolUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type BorrowUpsertWithWhereUniqueWithoutBookInput = {
    where: BorrowWhereUniqueInput
    update: XOR<BorrowUpdateWithoutBookInput, BorrowUncheckedUpdateWithoutBookInput>
    create: XOR<BorrowCreateWithoutBookInput, BorrowUncheckedCreateWithoutBookInput>
  }

  export type BorrowUpdateWithWhereUniqueWithoutBookInput = {
    where: BorrowWhereUniqueInput
    data: XOR<BorrowUpdateWithoutBookInput, BorrowUncheckedUpdateWithoutBookInput>
  }

  export type BorrowUpdateManyWithWhereWithoutBookInput = {
    where: BorrowScalarWhereInput
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyWithoutBookInput>
  }

  export type BookCreateWithoutBorrowsInput = {
    id?: string
    title: string
    isbn: string
    totalCopies?: number
    available?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AuthorCreateNestedOneWithoutBooksInput
    category?: CategoryCreateNestedOneWithoutBooksInput
    school: SchoolCreateNestedOneWithoutBookInput
  }

  export type BookUncheckedCreateWithoutBorrowsInput = {
    id?: string
    title: string
    isbn: string
    authorId: string
    categoryId?: string | null
    totalCopies?: number
    available?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateOrConnectWithoutBorrowsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutBorrowsInput, BookUncheckedCreateWithoutBorrowsInput>
  }

  export type StudentCreateWithoutBorrowInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutBorrowInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutBorrowInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutBorrowInput, StudentUncheckedCreateWithoutBorrowInput>
  }

  export type BookUpsertWithoutBorrowsInput = {
    update: XOR<BookUpdateWithoutBorrowsInput, BookUncheckedUpdateWithoutBorrowsInput>
    create: XOR<BookCreateWithoutBorrowsInput, BookUncheckedCreateWithoutBorrowsInput>
    where?: BookWhereInput
  }

  export type BookUpdateToOneWithWhereWithoutBorrowsInput = {
    where?: BookWhereInput
    data: XOR<BookUpdateWithoutBorrowsInput, BookUncheckedUpdateWithoutBorrowsInput>
  }

  export type BookUpdateWithoutBorrowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutBooksNestedInput
    category?: CategoryUpdateOneWithoutBooksNestedInput
    school?: SchoolUpdateOneRequiredWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutBorrowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithoutBorrowInput = {
    update: XOR<StudentUpdateWithoutBorrowInput, StudentUncheckedUpdateWithoutBorrowInput>
    create: XOR<StudentCreateWithoutBorrowInput, StudentUncheckedCreateWithoutBorrowInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutBorrowInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutBorrowInput, StudentUncheckedUpdateWithoutBorrowInput>
  }

  export type StudentUpdateWithoutBorrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutBorrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutLibraryStaffInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    application?: ApplicationCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLibraryStaffInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    application?: ApplicationUncheckedCreateNestedOneWithoutUserInput
    SkuunAiSession?: SkuunAiSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLibraryStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLibraryStaffInput, UserUncheckedCreateWithoutLibraryStaffInput>
  }

  export type DepartmentCreateWithoutLibraryStaffInput = {
    id?: string
    name: string
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutLibraryStaffInput = {
    id?: string
    name: string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutLibraryStaffInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutLibraryStaffInput, DepartmentUncheckedCreateWithoutLibraryStaffInput>
  }

  export type UserUpsertWithoutLibraryStaffInput = {
    update: XOR<UserUpdateWithoutLibraryStaffInput, UserUncheckedUpdateWithoutLibraryStaffInput>
    create: XOR<UserCreateWithoutLibraryStaffInput, UserUncheckedCreateWithoutLibraryStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLibraryStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLibraryStaffInput, UserUncheckedUpdateWithoutLibraryStaffInput>
  }

  export type UserUpdateWithoutLibraryStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLibraryStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DepartmentUpsertWithoutLibraryStaffInput = {
    update: XOR<DepartmentUpdateWithoutLibraryStaffInput, DepartmentUncheckedUpdateWithoutLibraryStaffInput>
    create: XOR<DepartmentCreateWithoutLibraryStaffInput, DepartmentUncheckedCreateWithoutLibraryStaffInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutLibraryStaffInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutLibraryStaffInput, DepartmentUncheckedUpdateWithoutLibraryStaffInput>
  }

  export type DepartmentUpdateWithoutLibraryStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutLibraryStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ApplicationCreateWithoutAdmissionPaymentInput = {
    id?: string
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutApplicationInput
    user?: UserCreateNestedOneWithoutApplicationInput
    school?: SchoolCreateNestedOneWithoutApplicationsInput
    previousSchools?: PreviousSchoolCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutApplicationInput
    grade?: GradeCreateNestedOneWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutAdmissionPaymentInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    schoolId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    previousSchools?: PreviousSchoolUncheckedCreateNestedManyWithoutApplicationInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutAdmissionPaymentInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutAdmissionPaymentInput, ApplicationUncheckedCreateWithoutAdmissionPaymentInput>
  }

  export type ApplicationCreateManyAdmissionPaymentInputEnvelope = {
    data: ApplicationCreateManyAdmissionPaymentInput | ApplicationCreateManyAdmissionPaymentInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationUpsertWithWhereUniqueWithoutAdmissionPaymentInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutAdmissionPaymentInput, ApplicationUncheckedUpdateWithoutAdmissionPaymentInput>
    create: XOR<ApplicationCreateWithoutAdmissionPaymentInput, ApplicationUncheckedCreateWithoutAdmissionPaymentInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutAdmissionPaymentInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutAdmissionPaymentInput, ApplicationUncheckedUpdateWithoutAdmissionPaymentInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutAdmissionPaymentInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutAdmissionPaymentInput>
  }

  export type StudentCreateWithoutTransactionInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutTransactionInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTransactionInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTransactionInput, StudentUncheckedCreateWithoutTransactionInput>
  }

  export type StudentUpsertWithoutTransactionInput = {
    update: XOR<StudentUpdateWithoutTransactionInput, StudentUncheckedUpdateWithoutTransactionInput>
    create: XOR<StudentCreateWithoutTransactionInput, StudentUncheckedCreateWithoutTransactionInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutTransactionInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutTransactionInput, StudentUncheckedUpdateWithoutTransactionInput>
  }

  export type StudentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SchoolCreateWithoutFinancesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFinancesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFinancesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFinancesInput, SchoolUncheckedCreateWithoutFinancesInput>
  }

  export type SchoolUpsertWithoutFinancesInput = {
    update: XOR<SchoolUpdateWithoutFinancesInput, SchoolUncheckedUpdateWithoutFinancesInput>
    create: XOR<SchoolCreateWithoutFinancesInput, SchoolUncheckedCreateWithoutFinancesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFinancesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFinancesInput, SchoolUncheckedUpdateWithoutFinancesInput>
  }

  export type SchoolUpdateWithoutFinancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFinancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutResourcesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutResourcesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutResourcesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutResourcesInput, SchoolUncheckedCreateWithoutResourcesInput>
  }

  export type PurchaseCreateWithoutResourceInput = {
    id?: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutResourceInput = {
    id?: string
    studentId: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutResourceInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutResourceInput, PurchaseUncheckedCreateWithoutResourceInput>
  }

  export type PurchaseCreateManyResourceInputEnvelope = {
    data: PurchaseCreateManyResourceInput | PurchaseCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutResourcesInput = {
    update: XOR<SchoolUpdateWithoutResourcesInput, SchoolUncheckedUpdateWithoutResourcesInput>
    create: XOR<SchoolCreateWithoutResourcesInput, SchoolUncheckedCreateWithoutResourcesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutResourcesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutResourcesInput, SchoolUncheckedUpdateWithoutResourcesInput>
  }

  export type SchoolUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type PurchaseUpsertWithWhereUniqueWithoutResourceInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutResourceInput, PurchaseUncheckedUpdateWithoutResourceInput>
    create: XOR<PurchaseCreateWithoutResourceInput, PurchaseUncheckedCreateWithoutResourceInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutResourceInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutResourceInput, PurchaseUncheckedUpdateWithoutResourceInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutResourceInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutResourceInput>
  }

  export type StudentCreateWithoutPurchaseInput = {
    id?: string
    name?: string | null
    enrolledAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentInput
    subjects?: SubjectCreateNestedManyWithoutStudentsInput
    application?: ApplicationCreateNestedOneWithoutStudentInput
    Class?: ClassCreateNestedOneWithoutStudentsInput
    Exam?: ExamCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    Parent?: ParentCreateNestedManyWithoutStudentInput
    Borrow?: BorrowCreateNestedManyWithoutStudentInput
    Transaction?: TransactionCreateNestedManyWithoutStudentInput
    Grade?: GradeCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutPurchaseInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutStudentsInput
    application?: ApplicationUncheckedCreateNestedOneWithoutStudentInput
    Exam?: ExamUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    Parent?: ParentUncheckedCreateNestedManyWithoutStudentInput
    Borrow?: BorrowUncheckedCreateNestedManyWithoutStudentInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPurchaseInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPurchaseInput, StudentUncheckedCreateWithoutPurchaseInput>
  }

  export type ResourceCreateWithoutPurchasesInput = {
    id?: string
    name: string
    category?: string | null
    unitPrice: number
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name: string
    category?: string | null
    unitPrice: number
    quantity?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceCreateOrConnectWithoutPurchasesInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutPurchasesInput, ResourceUncheckedCreateWithoutPurchasesInput>
  }

  export type StudentUpsertWithoutPurchaseInput = {
    update: XOR<StudentUpdateWithoutPurchaseInput, StudentUncheckedUpdateWithoutPurchaseInput>
    create: XOR<StudentCreateWithoutPurchaseInput, StudentUncheckedCreateWithoutPurchaseInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPurchaseInput, StudentUncheckedUpdateWithoutPurchaseInput>
  }

  export type StudentUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ResourceUpsertWithoutPurchasesInput = {
    update: XOR<ResourceUpdateWithoutPurchasesInput, ResourceUncheckedUpdateWithoutPurchasesInput>
    create: XOR<ResourceCreateWithoutPurchasesInput, ResourceUncheckedCreateWithoutPurchasesInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutPurchasesInput, ResourceUncheckedUpdateWithoutPurchasesInput>
  }

  export type ResourceUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateWithoutActivitiesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    buses?: BusCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    buses?: BusUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutActivitiesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutActivitiesInput, SchoolUncheckedCreateWithoutActivitiesInput>
  }

  export type SchoolUpsertWithoutActivitiesInput = {
    update: XOR<SchoolUpdateWithoutActivitiesInput, SchoolUncheckedUpdateWithoutActivitiesInput>
    create: XOR<SchoolCreateWithoutActivitiesInput, SchoolUncheckedCreateWithoutActivitiesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutActivitiesInput, SchoolUncheckedUpdateWithoutActivitiesInput>
  }

  export type SchoolUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    buses?: BusUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    buses?: BusUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutBusesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    finances?: FinanceCreateNestedManyWithoutSchoolInput
    activities?: ActivityCreateNestedManyWithoutSchoolInput
    resources?: ResourceCreateNestedManyWithoutSchoolInput
    Book?: BookCreateNestedManyWithoutSchoolInput
    applications?: ApplicationCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationCreateNestedManyWithoutSchoolInput
    Student?: StudentCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutBusesInput = {
    id?: string
    name: string
    domain: string
    email: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    finances?: FinanceUncheckedCreateNestedManyWithoutSchoolInput
    activities?: ActivityUncheckedCreateNestedManyWithoutSchoolInput
    resources?: ResourceUncheckedCreateNestedManyWithoutSchoolInput
    Book?: BookUncheckedCreateNestedManyWithoutSchoolInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutSchoolInput
    StaffApplication?: StaffApplicationUncheckedCreateNestedManyWithoutSchoolInput
    Student?: StudentUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutBusesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutBusesInput, SchoolUncheckedCreateWithoutBusesInput>
  }

  export type SchoolUpsertWithoutBusesInput = {
    update: XOR<SchoolUpdateWithoutBusesInput, SchoolUncheckedUpdateWithoutBusesInput>
    create: XOR<SchoolCreateWithoutBusesInput, SchoolUncheckedCreateWithoutBusesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutBusesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutBusesInput, SchoolUncheckedUpdateWithoutBusesInput>
  }

  export type SchoolUpdateWithoutBusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUpdateManyWithoutSchoolNestedInput
    Book?: BookUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUpdateManyWithoutSchoolNestedInput
    Student?: StudentUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutBusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    finances?: FinanceUncheckedUpdateManyWithoutSchoolNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutSchoolNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutSchoolNestedInput
    Book?: BookUncheckedUpdateManyWithoutSchoolNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateManyWithoutSchoolNestedInput
    Student?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserCreateWithoutSkuunAiSessionInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    application?: ApplicationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSkuunAiSessionInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    LibraryStaff?: LibraryStaffUncheckedCreateNestedOneWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    application?: ApplicationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSkuunAiSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSkuunAiSessionInput, UserUncheckedCreateWithoutSkuunAiSessionInput>
  }

  export type SkuunAiMessageCreateWithoutSessionInput = {
    id?: string
    sender: $Enums.SenderType
    type: $Enums.MessageType
    content: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiMessageUncheckedCreateWithoutSessionInput = {
    id?: string
    sender: $Enums.SenderType
    type: $Enums.MessageType
    content: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiMessageCreateOrConnectWithoutSessionInput = {
    where: SkuunAiMessageWhereUniqueInput
    create: XOR<SkuunAiMessageCreateWithoutSessionInput, SkuunAiMessageUncheckedCreateWithoutSessionInput>
  }

  export type SkuunAiMessageCreateManySessionInputEnvelope = {
    data: SkuunAiMessageCreateManySessionInput | SkuunAiMessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SkuunAiActionCreateWithoutSessionInput = {
    id?: string
    type: $Enums.AIActionType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ActionStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiActionUncheckedCreateWithoutSessionInput = {
    id?: string
    type: $Enums.AIActionType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ActionStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiActionCreateOrConnectWithoutSessionInput = {
    where: SkuunAiActionWhereUniqueInput
    create: XOR<SkuunAiActionCreateWithoutSessionInput, SkuunAiActionUncheckedCreateWithoutSessionInput>
  }

  export type SkuunAiActionCreateManySessionInputEnvelope = {
    data: SkuunAiActionCreateManySessionInput | SkuunAiActionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SkuunAiRecommendationCreateWithoutSessionInput = {
    id?: string
    category: string
    targetId?: string | null
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiRecommendationUncheckedCreateWithoutSessionInput = {
    id?: string
    category: string
    targetId?: string | null
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiRecommendationCreateOrConnectWithoutSessionInput = {
    where: SkuunAiRecommendationWhereUniqueInput
    create: XOR<SkuunAiRecommendationCreateWithoutSessionInput, SkuunAiRecommendationUncheckedCreateWithoutSessionInput>
  }

  export type SkuunAiRecommendationCreateManySessionInputEnvelope = {
    data: SkuunAiRecommendationCreateManySessionInput | SkuunAiRecommendationCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSkuunAiSessionInput = {
    update: XOR<UserUpdateWithoutSkuunAiSessionInput, UserUncheckedUpdateWithoutSkuunAiSessionInput>
    create: XOR<UserCreateWithoutSkuunAiSessionInput, UserUncheckedCreateWithoutSkuunAiSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSkuunAiSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSkuunAiSessionInput, UserUncheckedUpdateWithoutSkuunAiSessionInput>
  }

  export type UserUpdateWithoutSkuunAiSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSkuunAiSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SkuunAiMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: SkuunAiMessageWhereUniqueInput
    update: XOR<SkuunAiMessageUpdateWithoutSessionInput, SkuunAiMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<SkuunAiMessageCreateWithoutSessionInput, SkuunAiMessageUncheckedCreateWithoutSessionInput>
  }

  export type SkuunAiMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: SkuunAiMessageWhereUniqueInput
    data: XOR<SkuunAiMessageUpdateWithoutSessionInput, SkuunAiMessageUncheckedUpdateWithoutSessionInput>
  }

  export type SkuunAiMessageUpdateManyWithWhereWithoutSessionInput = {
    where: SkuunAiMessageScalarWhereInput
    data: XOR<SkuunAiMessageUpdateManyMutationInput, SkuunAiMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type SkuunAiMessageScalarWhereInput = {
    AND?: SkuunAiMessageScalarWhereInput | SkuunAiMessageScalarWhereInput[]
    OR?: SkuunAiMessageScalarWhereInput[]
    NOT?: SkuunAiMessageScalarWhereInput | SkuunAiMessageScalarWhereInput[]
    id?: StringFilter<"SkuunAiMessage"> | string
    sessionId?: StringFilter<"SkuunAiMessage"> | string
    sender?: EnumSenderTypeFilter<"SkuunAiMessage"> | $Enums.SenderType
    type?: EnumMessageTypeFilter<"SkuunAiMessage"> | $Enums.MessageType
    content?: StringFilter<"SkuunAiMessage"> | string
    payload?: JsonNullableFilter<"SkuunAiMessage">
    createdAt?: DateTimeFilter<"SkuunAiMessage"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiMessage"> | Date | string
  }

  export type SkuunAiActionUpsertWithWhereUniqueWithoutSessionInput = {
    where: SkuunAiActionWhereUniqueInput
    update: XOR<SkuunAiActionUpdateWithoutSessionInput, SkuunAiActionUncheckedUpdateWithoutSessionInput>
    create: XOR<SkuunAiActionCreateWithoutSessionInput, SkuunAiActionUncheckedCreateWithoutSessionInput>
  }

  export type SkuunAiActionUpdateWithWhereUniqueWithoutSessionInput = {
    where: SkuunAiActionWhereUniqueInput
    data: XOR<SkuunAiActionUpdateWithoutSessionInput, SkuunAiActionUncheckedUpdateWithoutSessionInput>
  }

  export type SkuunAiActionUpdateManyWithWhereWithoutSessionInput = {
    where: SkuunAiActionScalarWhereInput
    data: XOR<SkuunAiActionUpdateManyMutationInput, SkuunAiActionUncheckedUpdateManyWithoutSessionInput>
  }

  export type SkuunAiActionScalarWhereInput = {
    AND?: SkuunAiActionScalarWhereInput | SkuunAiActionScalarWhereInput[]
    OR?: SkuunAiActionScalarWhereInput[]
    NOT?: SkuunAiActionScalarWhereInput | SkuunAiActionScalarWhereInput[]
    id?: StringFilter<"SkuunAiAction"> | string
    sessionId?: StringFilter<"SkuunAiAction"> | string
    type?: EnumAIActionTypeFilter<"SkuunAiAction"> | $Enums.AIActionType
    payload?: JsonFilter<"SkuunAiAction">
    status?: EnumActionStatusFilter<"SkuunAiAction"> | $Enums.ActionStatus
    executedAt?: DateTimeNullableFilter<"SkuunAiAction"> | Date | string | null
    createdAt?: DateTimeFilter<"SkuunAiAction"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiAction"> | Date | string
  }

  export type SkuunAiRecommendationUpsertWithWhereUniqueWithoutSessionInput = {
    where: SkuunAiRecommendationWhereUniqueInput
    update: XOR<SkuunAiRecommendationUpdateWithoutSessionInput, SkuunAiRecommendationUncheckedUpdateWithoutSessionInput>
    create: XOR<SkuunAiRecommendationCreateWithoutSessionInput, SkuunAiRecommendationUncheckedCreateWithoutSessionInput>
  }

  export type SkuunAiRecommendationUpdateWithWhereUniqueWithoutSessionInput = {
    where: SkuunAiRecommendationWhereUniqueInput
    data: XOR<SkuunAiRecommendationUpdateWithoutSessionInput, SkuunAiRecommendationUncheckedUpdateWithoutSessionInput>
  }

  export type SkuunAiRecommendationUpdateManyWithWhereWithoutSessionInput = {
    where: SkuunAiRecommendationScalarWhereInput
    data: XOR<SkuunAiRecommendationUpdateManyMutationInput, SkuunAiRecommendationUncheckedUpdateManyWithoutSessionInput>
  }

  export type SkuunAiRecommendationScalarWhereInput = {
    AND?: SkuunAiRecommendationScalarWhereInput | SkuunAiRecommendationScalarWhereInput[]
    OR?: SkuunAiRecommendationScalarWhereInput[]
    NOT?: SkuunAiRecommendationScalarWhereInput | SkuunAiRecommendationScalarWhereInput[]
    id?: StringFilter<"SkuunAiRecommendation"> | string
    sessionId?: StringFilter<"SkuunAiRecommendation"> | string
    category?: StringFilter<"SkuunAiRecommendation"> | string
    targetId?: StringNullableFilter<"SkuunAiRecommendation"> | string | null
    message?: StringFilter<"SkuunAiRecommendation"> | string
    data?: JsonNullableFilter<"SkuunAiRecommendation">
    resolved?: BoolFilter<"SkuunAiRecommendation"> | boolean
    createdAt?: DateTimeFilter<"SkuunAiRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"SkuunAiRecommendation"> | Date | string
  }

  export type SkuunAiSessionCreateWithoutMessagesInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSkuunAiSessionInput
    actions?: SkuunAiActionCreateNestedManyWithoutSessionInput
    SkuunAiRecommendation?: SkuunAiRecommendationCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: SkuunAiActionUncheckedCreateNestedManyWithoutSessionInput
    SkuunAiRecommendation?: SkuunAiRecommendationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionCreateOrConnectWithoutMessagesInput = {
    where: SkuunAiSessionWhereUniqueInput
    create: XOR<SkuunAiSessionCreateWithoutMessagesInput, SkuunAiSessionUncheckedCreateWithoutMessagesInput>
  }

  export type SkuunAiSessionUpsertWithoutMessagesInput = {
    update: XOR<SkuunAiSessionUpdateWithoutMessagesInput, SkuunAiSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<SkuunAiSessionCreateWithoutMessagesInput, SkuunAiSessionUncheckedCreateWithoutMessagesInput>
    where?: SkuunAiSessionWhereInput
  }

  export type SkuunAiSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SkuunAiSessionWhereInput
    data: XOR<SkuunAiSessionUpdateWithoutMessagesInput, SkuunAiSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type SkuunAiSessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkuunAiSessionNestedInput
    actions?: SkuunAiActionUpdateManyWithoutSessionNestedInput
    SkuunAiRecommendation?: SkuunAiRecommendationUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: SkuunAiActionUncheckedUpdateManyWithoutSessionNestedInput
    SkuunAiRecommendation?: SkuunAiRecommendationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionCreateWithoutActionsInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSkuunAiSessionInput
    messages?: SkuunAiMessageCreateNestedManyWithoutSessionInput
    SkuunAiRecommendation?: SkuunAiRecommendationCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionUncheckedCreateWithoutActionsInput = {
    id?: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SkuunAiMessageUncheckedCreateNestedManyWithoutSessionInput
    SkuunAiRecommendation?: SkuunAiRecommendationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionCreateOrConnectWithoutActionsInput = {
    where: SkuunAiSessionWhereUniqueInput
    create: XOR<SkuunAiSessionCreateWithoutActionsInput, SkuunAiSessionUncheckedCreateWithoutActionsInput>
  }

  export type SkuunAiSessionUpsertWithoutActionsInput = {
    update: XOR<SkuunAiSessionUpdateWithoutActionsInput, SkuunAiSessionUncheckedUpdateWithoutActionsInput>
    create: XOR<SkuunAiSessionCreateWithoutActionsInput, SkuunAiSessionUncheckedCreateWithoutActionsInput>
    where?: SkuunAiSessionWhereInput
  }

  export type SkuunAiSessionUpdateToOneWithWhereWithoutActionsInput = {
    where?: SkuunAiSessionWhereInput
    data: XOR<SkuunAiSessionUpdateWithoutActionsInput, SkuunAiSessionUncheckedUpdateWithoutActionsInput>
  }

  export type SkuunAiSessionUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkuunAiSessionNestedInput
    messages?: SkuunAiMessageUpdateManyWithoutSessionNestedInput
    SkuunAiRecommendation?: SkuunAiRecommendationUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SkuunAiMessageUncheckedUpdateManyWithoutSessionNestedInput
    SkuunAiRecommendation?: SkuunAiRecommendationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionCreateWithoutSkuunAiRecommendationInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSkuunAiSessionInput
    messages?: SkuunAiMessageCreateNestedManyWithoutSessionInput
    actions?: SkuunAiActionCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionUncheckedCreateWithoutSkuunAiRecommendationInput = {
    id?: string
    userId: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SkuunAiMessageUncheckedCreateNestedManyWithoutSessionInput
    actions?: SkuunAiActionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SkuunAiSessionCreateOrConnectWithoutSkuunAiRecommendationInput = {
    where: SkuunAiSessionWhereUniqueInput
    create: XOR<SkuunAiSessionCreateWithoutSkuunAiRecommendationInput, SkuunAiSessionUncheckedCreateWithoutSkuunAiRecommendationInput>
  }

  export type SkuunAiSessionUpsertWithoutSkuunAiRecommendationInput = {
    update: XOR<SkuunAiSessionUpdateWithoutSkuunAiRecommendationInput, SkuunAiSessionUncheckedUpdateWithoutSkuunAiRecommendationInput>
    create: XOR<SkuunAiSessionCreateWithoutSkuunAiRecommendationInput, SkuunAiSessionUncheckedCreateWithoutSkuunAiRecommendationInput>
    where?: SkuunAiSessionWhereInput
  }

  export type SkuunAiSessionUpdateToOneWithWhereWithoutSkuunAiRecommendationInput = {
    where?: SkuunAiSessionWhereInput
    data: XOR<SkuunAiSessionUpdateWithoutSkuunAiRecommendationInput, SkuunAiSessionUncheckedUpdateWithoutSkuunAiRecommendationInput>
  }

  export type SkuunAiSessionUpdateWithoutSkuunAiRecommendationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkuunAiSessionNestedInput
    messages?: SkuunAiMessageUpdateManyWithoutSessionNestedInput
    actions?: SkuunAiActionUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionUncheckedUpdateWithoutSkuunAiRecommendationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SkuunAiMessageUncheckedUpdateManyWithoutSessionNestedInput
    actions?: SkuunAiActionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type DecisionRecordCreateWithoutSupersededByInput = {
    id?: string
    title: string
    context: string
    decision: string
    consequences: string
    status?: $Enums.DecisionStatus
    authorId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    implementedAt?: Date | string | null
    supersedes?: DecisionRecordCreateNestedOneWithoutSupersededByInput
  }

  export type DecisionRecordUncheckedCreateWithoutSupersededByInput = {
    id?: string
    title: string
    context: string
    decision: string
    consequences: string
    status?: $Enums.DecisionStatus
    supersedesId?: string | null
    authorId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    implementedAt?: Date | string | null
  }

  export type DecisionRecordCreateOrConnectWithoutSupersededByInput = {
    where: DecisionRecordWhereUniqueInput
    create: XOR<DecisionRecordCreateWithoutSupersededByInput, DecisionRecordUncheckedCreateWithoutSupersededByInput>
  }

  export type DecisionRecordCreateWithoutSupersedesInput = {
    id?: string
    title: string
    context: string
    decision: string
    consequences: string
    status?: $Enums.DecisionStatus
    authorId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    implementedAt?: Date | string | null
    supersededBy?: DecisionRecordCreateNestedManyWithoutSupersedesInput
  }

  export type DecisionRecordUncheckedCreateWithoutSupersedesInput = {
    id?: string
    title: string
    context: string
    decision: string
    consequences: string
    status?: $Enums.DecisionStatus
    authorId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    implementedAt?: Date | string | null
    supersededBy?: DecisionRecordUncheckedCreateNestedManyWithoutSupersedesInput
  }

  export type DecisionRecordCreateOrConnectWithoutSupersedesInput = {
    where: DecisionRecordWhereUniqueInput
    create: XOR<DecisionRecordCreateWithoutSupersedesInput, DecisionRecordUncheckedCreateWithoutSupersedesInput>
  }

  export type DecisionRecordCreateManySupersedesInputEnvelope = {
    data: DecisionRecordCreateManySupersedesInput | DecisionRecordCreateManySupersedesInput[]
    skipDuplicates?: boolean
  }

  export type DecisionRecordUpsertWithoutSupersededByInput = {
    update: XOR<DecisionRecordUpdateWithoutSupersededByInput, DecisionRecordUncheckedUpdateWithoutSupersededByInput>
    create: XOR<DecisionRecordCreateWithoutSupersededByInput, DecisionRecordUncheckedCreateWithoutSupersededByInput>
    where?: DecisionRecordWhereInput
  }

  export type DecisionRecordUpdateToOneWithWhereWithoutSupersededByInput = {
    where?: DecisionRecordWhereInput
    data: XOR<DecisionRecordUpdateWithoutSupersededByInput, DecisionRecordUncheckedUpdateWithoutSupersededByInput>
  }

  export type DecisionRecordUpdateWithoutSupersededByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supersedes?: DecisionRecordUpdateOneWithoutSupersededByNestedInput
  }

  export type DecisionRecordUncheckedUpdateWithoutSupersededByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    supersedesId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DecisionRecordUpsertWithWhereUniqueWithoutSupersedesInput = {
    where: DecisionRecordWhereUniqueInput
    update: XOR<DecisionRecordUpdateWithoutSupersedesInput, DecisionRecordUncheckedUpdateWithoutSupersedesInput>
    create: XOR<DecisionRecordCreateWithoutSupersedesInput, DecisionRecordUncheckedCreateWithoutSupersedesInput>
  }

  export type DecisionRecordUpdateWithWhereUniqueWithoutSupersedesInput = {
    where: DecisionRecordWhereUniqueInput
    data: XOR<DecisionRecordUpdateWithoutSupersedesInput, DecisionRecordUncheckedUpdateWithoutSupersedesInput>
  }

  export type DecisionRecordUpdateManyWithWhereWithoutSupersedesInput = {
    where: DecisionRecordScalarWhereInput
    data: XOR<DecisionRecordUpdateManyMutationInput, DecisionRecordUncheckedUpdateManyWithoutSupersedesInput>
  }

  export type DecisionRecordScalarWhereInput = {
    AND?: DecisionRecordScalarWhereInput | DecisionRecordScalarWhereInput[]
    OR?: DecisionRecordScalarWhereInput[]
    NOT?: DecisionRecordScalarWhereInput | DecisionRecordScalarWhereInput[]
    id?: StringFilter<"DecisionRecord"> | string
    title?: StringFilter<"DecisionRecord"> | string
    context?: StringFilter<"DecisionRecord"> | string
    decision?: StringFilter<"DecisionRecord"> | string
    consequences?: StringFilter<"DecisionRecord"> | string
    status?: EnumDecisionStatusFilter<"DecisionRecord"> | $Enums.DecisionStatus
    supersedesId?: StringNullableFilter<"DecisionRecord"> | string | null
    authorId?: StringFilter<"DecisionRecord"> | string
    schoolId?: StringFilter<"DecisionRecord"> | string
    createdAt?: DateTimeFilter<"DecisionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"DecisionRecord"> | Date | string
    implementedAt?: DateTimeNullableFilter<"DecisionRecord"> | Date | string | null
  }

  export type UserCreateManySchoolInput = {
    id?: string
    surname: string
    firstName: string
    otherNames?: string | null
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManySchoolInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusCreateManySchoolInput = {
    id?: string
    plateNumber: string
    driverName: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinanceCreateManySchoolInput = {
    id?: string
    type?: $Enums.FinanceType
    amount: number
    description?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManySchoolInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceCreateManySchoolInput = {
    id?: string
    name: string
    category?: string | null
    unitPrice: number
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateManySchoolInput = {
    id?: string
    title: string
    isbn: string
    authorId: string
    categoryId?: string | null
    totalCopies?: number
    available?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationCreateManySchoolInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffApplicationCreateManySchoolInput = {
    id?: string
    staffId?: string | null
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    departmentId?: string | null
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManySchoolInput = {
    id?: string
    userId: string
    name?: string | null
    enrolledAt?: Date | string
    classId?: string | null
    gradeId?: string | null
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    LibraryStaff?: LibraryStaffUncheckedUpdateOneWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutUserNestedInput
    SkuunAiSession?: SkuunAiSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    staff?: StaffUpdateManyWithoutClassNestedInput
    exams?: ExamUpdateManyWithoutClassNestedInput
    subjects?: SubjectUpdateManyWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    staff?: StaffUncheckedUpdateManyWithoutClassNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    driverName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    driverName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    driverName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinanceUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinanceUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinanceUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutBooksNestedInput
    category?: CategoryUpdateOneWithoutBooksNestedInput
    borrows?: BorrowUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrows?: BorrowUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutApplicationNestedInput
    user?: UserUpdateOneWithoutApplicationNestedInput
    admissionPayment?: AdmissionPaymentUpdateOneWithoutApplicationNestedInput
    previousSchools?: PreviousSchoolUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutApplicationNestedInput
    grade?: GradeUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousSchools?: PreviousSchoolUncheckedUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffApplicationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutStaffApplicationNestedInput
    department?: DepartmentUpdateOneWithoutStaffApplicationNestedInput
    subjects?: SubjectUpdateManyWithoutStaffApplicationsNestedInput
    previousJobs?: PreviousJobUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutStaffApplicationsNestedInput
    previousJobs?: PreviousJobUncheckedUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectCreateManyCreatedByInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiSessionCreateManyUserInput = {
    id?: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUpdateManyWithoutSubjectNestedInput
    staff?: StaffUpdateManyWithoutSubjectsNestedInput
    students?: StudentUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    staff?: StaffUncheckedUpdateManyWithoutSubjectsNestedInput
    students?: StudentUncheckedUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SkuunAiMessageUpdateManyWithoutSessionNestedInput
    actions?: SkuunAiActionUpdateManyWithoutSessionNestedInput
    SkuunAiRecommendation?: SkuunAiRecommendationUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SkuunAiMessageUncheckedUpdateManyWithoutSessionNestedInput
    actions?: SkuunAiActionUncheckedUpdateManyWithoutSessionNestedInput
    SkuunAiRecommendation?: SkuunAiRecommendationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SkuunAiSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyStudentInput = {
    id?: string
    title: string
    classId?: string | null
    subjectId: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateManyStudentInput = {
    id?: string
    classId: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentCreateManyStudentInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowCreateManyStudentInput = {
    id?: string
    bookId: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyStudentInput = {
    id?: string
    type?: $Enums.FinanceType
    feeType?: $Enums.FeeType | null
    amount: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyStudentInput = {
    id?: string
    resourceId: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
    staff?: StaffUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    staff?: StaffUncheckedUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutBorrowsNestedInput
  }

  export type BorrowUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    feeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    feeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinanceTypeFieldUpdateOperationsInput | $Enums.FinanceType
    feeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: ResourceUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyClassInput = {
    id?: string
    name?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyClassInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    gradeId?: string | null
  }

  export type StaffCreateManyClassInput = {
    id?: string
    userId: string
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyClassInput = {
    id?: string
    title: string
    studentId?: string | null
    subjectId: string
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutGradeNestedInput
    staff?: StaffUpdateManyWithoutGradesNestedInput
    Application?: ApplicationUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutGradeNestedInput
    staff?: StaffUncheckedUpdateManyWithoutGradesNestedInput
    Application?: ApplicationUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaffUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
    grades?: GradeUpdateManyWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    subjects?: SubjectUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStaffNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUncheckedUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutExamNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
    staff?: StaffUpdateManyWithoutSubjectsNestedInput
    students?: StudentUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    staff?: StaffUncheckedUpdateManyWithoutSubjectsNestedInput
    students?: StudentUncheckedUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentCreateManyGradeInput = {
    id?: string
    userId: string
    name?: string | null
    schoolId: string
    enrolledAt?: Date | string
    classId?: string | null
  }

  export type ApplicationCreateManyGradeInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    schoolId?: string | null
    admissionPaymentId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    subjects?: SubjectUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SubjectUncheckedUpdateManyWithoutStudentsNestedInput
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaffUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
    class?: ClassUpdateOneWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    subjects?: SubjectUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUncheckedUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutApplicationNestedInput
    user?: UserUpdateOneWithoutApplicationNestedInput
    school?: SchoolUpdateOneWithoutApplicationsNestedInput
    admissionPayment?: AdmissionPaymentUpdateOneWithoutApplicationNestedInput
    previousSchools?: PreviousSchoolUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousSchools?: PreviousSchoolUncheckedUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManySubjectInput = {
    id?: string
    title: string
    studentId?: string | null
    classId?: string | null
    score?: number | null
    maxScore?: number | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutExamNestedInput
    class?: ClassUpdateOneWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
    class?: ClassUpdateOneWithoutStaffNestedInput
    grades?: GradeUpdateManyWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    attendances?: StaffAttendanceUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUncheckedUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentNestedInput
    application?: ApplicationUpdateOneWithoutStudentNestedInput
    Class?: ClassUpdateOneWithoutStudentsNestedInput
    Exam?: ExamUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    Parent?: ParentUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUpdateManyWithoutStudentNestedInput
    Grade?: GradeUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    application?: ApplicationUncheckedUpdateOneWithoutStudentNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Parent?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    Borrow?: BorrowUncheckedUpdateManyWithoutStudentNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutStudentNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    staff?: StaffUpdateManyWithoutClassNestedInput
    exams?: ExamUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    staff?: StaffUncheckedUpdateManyWithoutClassNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffApplicationUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutStaffApplicationNestedInput
    school?: SchoolUpdateOneRequiredWithoutStaffApplicationNestedInput
    department?: DepartmentUpdateOneWithoutStaffApplicationNestedInput
    previousJobs?: PreviousJobUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousJobs?: PreviousJobUncheckedUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationUncheckedUpdateManyWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousSchoolCreateManyApplicationInput = {
    id?: string
    name: string
    location: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberCreateManyApplicationInput = {
    id?: string
    relation: string
    name: string
    postalAddress: string
    residentialAddress: string
    phone?: string | null
    email?: string | null
    occupation?: string | null
    workplace?: string | null
    religion?: string | null
    isAlive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreviousSchoolUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousSchoolUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousSchoolUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    residentialAddress?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    residentialAddress?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    residentialAddress?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousJobCreateManyStaffApplicationInput = {
    id?: string
    company: string
    role: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateWithoutStaffApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
    staff?: StaffUpdateManyWithoutSubjectsNestedInput
    students?: StudentUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutStaffApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    staff?: StaffUncheckedUpdateManyWithoutSubjectsNestedInput
    students?: StudentUncheckedUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutStaffApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreviousJobUpdateWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousJobUncheckedUpdateWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreviousJobUncheckedUpdateManyWithoutStaffApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceCreateManyStaffInput = {
    id?: string
    date?: Date | string
    status: $Enums.AttendanceStatus
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutGradesNestedInput
    students?: StudentUpdateManyWithoutGradeNestedInput
    Application?: ApplicationUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutGradeNestedInput
    Application?: ApplicationUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
    students?: StudentUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    students?: StudentUncheckedUpdateManyWithoutSubjectsNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSubjectsNestedInput
    staffApplications?: StaffApplicationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaffAttendanceUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffAttendanceUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManyDepartmentInput = {
    id?: string
    userId: string
    classId?: string | null
    position?: string | null
    salary?: number | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryStaffCreateManyDepartmentInput = {
    id?: string
    userId: string
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffApplicationCreateManyDepartmentInput = {
    id?: string
    staffId?: string | null
    schoolId: string
    surname: string
    firstName: string
    otherNames?: string | null
    dateOfBirth: Date | string
    nationality: string
    sex: string
    languages?: StaffApplicationCreatelanguagesInput | string[]
    maritalStatus?: string | null
    religion: string
    denomination?: string | null
    hometown: string
    region: string
    profilePicture?: string | null
    residentialAddress: string
    postalAddress: string
    mobile?: string | null
    email?: string | null
    emergencyContact: string
    nextOfKin?: string | null
    position: string
    hireDate?: Date | string | null
    salary?: number | null
    qualifications?: string | null
    bloodType?: string | null
    medicalConditions?: string | null
    specialDisability?: string | null
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
    class?: ClassUpdateOneWithoutStaffNestedInput
    grades?: GradeUpdateManyWithoutStaffNestedInput
    subjects?: SubjectUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStaffNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutStaffNestedInput
    attendances?: StaffAttendanceUncheckedUpdateManyWithoutStaffNestedInput
    StaffApplication?: StaffApplicationUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStaffUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLibraryStaffNestedInput
  }

  export type LibraryStaffUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStaffUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffApplicationUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutStaffApplicationNestedInput
    school?: SchoolUpdateOneRequiredWithoutStaffApplicationNestedInput
    subjects?: SubjectUpdateManyWithoutStaffApplicationsNestedInput
    previousJobs?: PreviousJobUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutStaffApplicationsNestedInput
    previousJobs?: PreviousJobUncheckedUpdateManyWithoutStaffApplicationNestedInput
  }

  export type StaffApplicationUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    languages?: StaffApplicationUpdatelanguagesInput | string[]
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: StringFieldUpdateOperationsInput | string
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: StringFieldUpdateOperationsInput | string
    postalAddress?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    nextOfKin?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateManyAuthorInput = {
    id?: string
    title: string
    isbn: string
    categoryId?: string | null
    totalCopies?: number
    available?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutBooksNestedInput
    school?: SchoolUpdateOneRequiredWithoutBookNestedInput
    borrows?: BorrowUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrows?: BorrowUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateManyCategoryInput = {
    id?: string
    title: string
    isbn: string
    authorId: string
    totalCopies?: number
    available?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutBooksNestedInput
    school?: SchoolUpdateOneRequiredWithoutBookNestedInput
    borrows?: BorrowUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrows?: BorrowUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    totalCopies?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowCreateManyBookInput = {
    id?: string
    studentId: string
    borrowedAt?: Date | string
    dueAt: Date | string
    returnedAt?: Date | string | null
    fine?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fine?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyAdmissionPaymentInput = {
    id?: string
    studentId?: string | null
    userId?: string | null
    schoolId?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    sex?: string | null
    languages?: ApplicationCreatelanguagesInput | string[]
    gradeId?: string | null
    mothersTongue?: string | null
    religion?: string | null
    denomination?: string | null
    hometown?: string | null
    region?: string | null
    profilePicture?: string | null
    wardLivesWith?: string | null
    numberOfSiblings?: number | null
    siblingsOlder?: number | null
    siblingsYounger?: number | null
    postalAddress?: string | null
    residentialAddress?: string | null
    wardMobile?: string | null
    emergencyContact?: string | null
    emergencyMedicalContact?: string | null
    medicalSummary?: string | null
    bloodType?: string | null
    specialDisability?: string | null
    feesAcknowledged?: boolean
    declarationSigned?: boolean
    signature?: string | null
    submissionDate?: Date | string | null
    classification?: string | null
    submittedBy?: string | null
    receivedBy?: string | null
    receivedDate?: Date | string | null
    remarks?: string | null
    status?: $Enums.ApplicationStatus
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateWithoutAdmissionPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutApplicationNestedInput
    user?: UserUpdateOneWithoutApplicationNestedInput
    school?: SchoolUpdateOneWithoutApplicationsNestedInput
    previousSchools?: PreviousSchoolUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutApplicationNestedInput
    grade?: GradeUpdateOneWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutAdmissionPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousSchools?: PreviousSchoolUncheckedUpdateManyWithoutApplicationNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutAdmissionPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: ApplicationUpdatelanguagesInput | string[]
    gradeId?: NullableStringFieldUpdateOperationsInput | string | null
    mothersTongue?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    denomination?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    wardLivesWith?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfSiblings?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsOlder?: NullableIntFieldUpdateOperationsInput | number | null
    siblingsYounger?: NullableIntFieldUpdateOperationsInput | number | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    wardMobile?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalSummary?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    specialDisability?: NullableStringFieldUpdateOperationsInput | string | null
    feesAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    declarationSigned?: BoolFieldUpdateOperationsInput | boolean
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyResourceInput = {
    id?: string
    studentId: string
    quantity?: number
    totalCost: number
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiMessageCreateManySessionInput = {
    id?: string
    sender: $Enums.SenderType
    type: $Enums.MessageType
    content: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiActionCreateManySessionInput = {
    id?: string
    type: $Enums.AIActionType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ActionStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiRecommendationCreateManySessionInput = {
    id?: string
    category: string
    targetId?: string | null
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuunAiMessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiMessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiActionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAIActionTypeFieldUpdateOperationsInput | $Enums.AIActionType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiActionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAIActionTypeFieldUpdateOperationsInput | $Enums.AIActionType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiActionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAIActionTypeFieldUpdateOperationsInput | $Enums.AIActionType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiRecommendationUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiRecommendationUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuunAiRecommendationUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionRecordCreateManySupersedesInput = {
    id?: string
    title: string
    context: string
    decision: string
    consequences: string
    status?: $Enums.DecisionStatus
    authorId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    implementedAt?: Date | string | null
  }

  export type DecisionRecordUpdateWithoutSupersedesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supersededBy?: DecisionRecordUpdateManyWithoutSupersedesNestedInput
  }

  export type DecisionRecordUncheckedUpdateWithoutSupersedesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supersededBy?: DecisionRecordUncheckedUpdateManyWithoutSupersedesNestedInput
  }

  export type DecisionRecordUncheckedUpdateManyWithoutSupersedesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    status?: EnumDecisionStatusFieldUpdateOperationsInput | $Enums.DecisionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}